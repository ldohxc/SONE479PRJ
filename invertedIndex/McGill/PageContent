1docContentStartContact information Office: 106N McConnell Engineering Building Tel: 514-398-5432 Fax: 514-398-3883 Email: jpineau  "at"  cs.mcgill.ca Mailing address: McConnell Eng. Bldg, Room 318 School of Computer Science McGill University 3480 University st Montreal, Quebec H3A 0E9 CanadadocContentEnd
2docContentStartResearch projects (somewhat out of date... see  publications page  for recent work.) Research interests: Planning, learning and decision-making Learning and representation of probabilistic systems Reinforcement learning, MDPs, POMDPs Machine learning Mobile robotics, human-robot interaction. Design of an intelligent robotic wheelchair (Smartwheeler project) Large-scale dialogue management Adaptive treatment design Automated learning of adaptive treatment strategies for chronic depression Computational modelling and adaptive treatment of epilepsy Preference elicitation in medical decision-makingdocContentEnd
3docContentStartCOMP-598: Topics in Computer Science: Applied Machine Learning (Fall 2014) INSTRUCTOR: Joelle Pineau TA: T.b.d. Term: Fall 2014. When: Tuesday / Thursday, 11:30am-1:00pm Where: ENGTR 2120 Course syllabus Course schedule  (including lecture slides, homeworks, solutions.) Description The course will cover selected topics and new developments in data mining and applied machine learning, with a particular emphasis on good methods and practices for effective deployment of real systems.  We will study commonly used algorithms and techniques, including linear and logistic regression, clustering, neural networks, support vector machines, decision trees and more.  We will also discuss methods to address practical issues such as feature selection and dimensionality reduction, error estimation and empirical validation, algorithm design and parallelization, and handling of large datasets. Important note: Students who took COMP-652 in 2013 or before CANNOT take COMP-598.  Students who took COMP-652 in Winter 2014 (or intend to take it later) can take COMP-598. Contents of both courses have been designed to avoid too much overlap. COMP-598 focuses on the practical application of machine learning, whereas COMP-652 (starting in Winter 2014) focuses on theoretical analysis of machine learning, reinforcement learning, bandits and analysis of time series. List of topics (subject to minor changes): Linear regression. Performance evaluation, overfitting, cross-validation, bias-variance analysis, error estimation. Dataset analysis. Naive Bayes. Decision trees. Regression trees and ensemble methods. Cost-sensitive learning. Support vector machines. Logistic regression. Feedforward neural networks. Deep learning. Feature selection. Dimensionality reduction. Regularization. Online / streaming data. Data structures and Map-Reduce. Time-series analysis. Unsupervised learning and clustering. Semi-supervised learning. Recommendation systems. Ranking and preference learning. Applications. IMPORTANT:  The schedule is subject to change. Up-to-date information about the schedule and assigned readings will be posted on the class web page.docContentEnd
4docContentStartdocContentEnd
5docContentStartCOMP-598 Topics in Computer Science: Applied Machine Learning Syllabus - Fall 2014 General Information Location: Trottier, ENGTR 2120 Times: Tuesday / Thursday, 11:30am-1:00pm Instructor: Prof. Joelle Pineau , School of Computer Science Email:  jpineau@cs.mcgill.ca Office: McConnell 106N Office hours: Thursday, 1:00-2:30pm Teaching assistants: Pierre-Luc Bacon Email:  pbacon@cs.mcgill.ca Office: McConnell 111 Office hours: Wednesday, 11am Angus Leigh Email:  angus.leigh@cs.mcgill.ca Office: McConnell 111 Office hours: Wednesday, 11am Class web page:   http://www.cs.mcgill.ca/~jpineau/comp598 Course Description The course will cover selected topics and new developments in Data mining and Machine learning, with a particular emphasis on good methods and practices for effective deployment of real systems.  We will study commonly used algorithms and techniques, including clustering, neural networks, support vector machines, decision trees.  We will also discuss methods to address practical issues such as feature selection and dimensionality reduction, error estimation and empirical validation, algorithm design and parallelization, and handling of large datasets. Course content (subject to minor changes): Linear regression. Linear classification. Performance evaluation, overfitting, cross-validation, bias-variance analysis, error estimation. Naive Bayes. Decision trees.  Regression trees and ensemble methods. Cost-sensitive learning. Support vector machines. Artificial neural networks. Deep learning. Feature selection. Dimensionality reduction. Regularization. Online / streaming data. Data structures and Map-Reduce. Unsupervised learning and clustering. Semi-supervised learning. Applications. Reference Materials There is no required textbook. Lecture notes and references will be available from the course web page. The following texts can also be very useful: Trevor Hastie, Robert Tibshirani and Jerome Friedman.  The Elements of Statistical Learning: Data Mining, Inference, and Prediction, 2nd Edition . Springer. 2009. Available  free online . Christopher Bishop.  Pattern Recognition and Machine Learning . Springer. 2007. Kevin Murphy.  Machine Learning: A Probabilistic Perspective . The MIT Press. 2012. David MacKay.  Information Theory, Inference and Learning Algorithms . Cambridge University Press. 2003. Richard Duda, Peter Hard and David Stork.  Pattern Classification. 2nd Edition . Wiley & Sons. 2001. Prerequisites / Anterequesites Basic knowledge of a programming language is required. Basic knowledge of probabilities/statistics, calculus and linear algebra is required. Example courses at McGill providing sufficient background in probability are MATH-323 or ECSE-305. Some AI background is recommended, as provided, for instance by COMP-424 or ECSE-526, but not required. If you have doubts regarding your background, please contact me to discuss it. Students who took COMP-652 in 2012 or before CANNOT take COMP-598. Starting in Fall 2013, COMP-598 and COMP-652 were designed to avoid significant overlap; you can take either or both. The courses is intended for hard-working, technically skilled, highly motivated students.  Participants will be expected to display initiative, creativity, scientific rigour, critical thinking, and good communication skills. Evaluation Criteria The class grade will be based on the following components: Weekly quizzes and exercises - 5% One in-class written midterm examination - 35% Four data analysis case studies + peer reviews - 60% The weekly exercises will consist of quizzes (in class) or practical work (take-home) designed to develop basic understanding of the course material as we progress through the topics. These are designed to provide some practice for the midterm. The midterm is designed to assess in-depth understanding of fundamental methods and algorithms. It will be scheduled towards the later end of the semester (mid-November).  There is no final exam. The data analysis case studies will require reading, writing, programming and experiments to gain hands-on experience with the application of recent machine learning methods, including concepts covered in the lectures, and concepts drawn from the literature.  Students will be responsible for characterizing the problem, developing methods of analysis, and presenting the results of their work.  Some case studies may be individual, most will be done in groups (usually of 3 or less). We will use a peer-review system to evaluate the data analysis case studies.  Each student will be asked to read and evaluate submissions of their colleagues.  The emphasis will be placed on providing constructive feedback on the methodology and presentation. Evaluation Policy All course work should be submitted online (details to be given in class), by 11:59pm, on the assigned due date. Late work will be automatically subject to a 30% penalty, and can be submitted up to 1 week after the deadline. No make-up midterm will be given.docContentEnd
6docContentStartSupervision I currently work with the following students: Borja de Balle Pigem , postdoctoral researcher Eric Crawford , Ph.D. candidate Martin Gerdzhev , Ph.D. candidate Boyu Wang , Ph.D. candidate Ouais Alsharif , MSc. candidate Emmanuel Bengio, MSc. candidate Ali Emami, MSc. candidate Gabriel Forgues, MSc. candidate Angus Leigh , M.Sc. candidate Benedicte Leonard-Cannon, MSc. candidate Ryan Lowe, MSc. candidate Andrew Sutcliffe, M.Sc. candidate Hiu Kim Yuen, MSc. candidate Stephanie Laflamme, undergraduate project Chenghui Zhou, undergraduate project In the past, I supervised the following students: Andre Barreto, post-doc (2011-2013), co-supervised with Doina Precup, now a faculty member in Brazil Sylvie Ong, post-doc (2010-2012), now at Nuance Keith Bush , post-doc (2008-2010), now Assistant Professor at U. of Arkansas at Little Rock Susan Shortreed, post-doc (2009-2010), now at Group Health Research Institute Mahdi Milani Fard , Ph.D. (2014) Robert Vincent , Ph.D. (2014) Cosmin Paduraru , Ph.D. (2013), co-supervised with Doina Precup, now a post-doc at McGill. Amin Atrash , Ph.D. (2011), now a post-doc at USC. William Hamilton , MSc.(2014), now a Ph.D. candidate at Stanford. Hang Ma , M.Sc. (2014), now a Ph.D. candidate at USC Ghazi Majdoub, MSc. candidate at Ecole Polytechnique de Montreal (2014), co-supervised with Richard Gourdeau Beomjoon Kim , M.Sc.(2013), now a Ph.D. candidate at MIT Athena Kardehi Moghaddam , M.Sc.(2013), now at Facebook (California) Guillaume Saulnier , M.Sc.(2013), now at Google (Seattle) Shaowei Png , M.Sc.(2011), now at Google (Seattle). Robert West , M.Sc. (2010), now a Ph.D. candidate at Stanford. Robert Kaplow , M.Sc. (2010), now at Google (Montreal). Arthur Guez , M.Sc. (2010), now a Ph.D. candidate at the Gatsby Unit, Univ. College London Julien Villemure , M.Sc. (2010), now at Nuance Communcations (Montreal). Hiba Yamani , M.Sc. (2009), now at Nuance Communications (Montreal). Stephane Ross , M.Sc. (2008), graduated with Ph.D. (2013) from CMU, now at Google-X. Zaid Zawaideh, M.Sc. (2007), founded a start-up in Toronto Daniel Burfoot , M.Sc. (2006), graduated with Ph.D. from the University of Tokyo. Robin Jaulmes , M.Sc. (2006). Philippe Nguyen, undergraduate project (2014) Alan Do-Omri, undergraduate project (2014) Angus MacIsaac, undergraduate project (2013) Raheem Adams, research intern (2013) William Hamilton, undergraduate project (2012), MSc candidate at McGill Andrew Sutcliffe, undergraduate project (2012) Jonathon Volkmar, undergraduate project (2011), B.Sc. candidate at McGill Emily Tsang, undergraduate project (2011), B.Sc. candidate at McGill Aaron Spring, undergraduate project (2011), B.Sc. candidate at McGill Julieta Jakubowicz, undergraduate project (2010-2011), B.Sc. candidate at McGill. Beomjoon Kim, undergraduate project (winter 2011), B.Sc. candidate at U.Waterloo. Olivier Remillard, undergraduate project (summer 2009), now M.Sc. candidate at McGill. Marcos Ginestra, undergraduate project (summer 2009), now M.Sc. candidate at UBC. Laura Lewis, undergraduate project (summer 2008), now a Ph.D. candidate at MIT. Caitlin Phillips, undergraduate research project (summer 2007). Milena Scaccia , undergraduate project (summer 2007). Nan Lin, undergraduate project (summer 2006). Adrian Ghizaru , undergraduate project (summer 2005).docContentEnd
7docContentStartCOMP-102: Computers and Computing (Fall 2011) INSTRUCTOR:  Joelle Pineau  (Office hours: Tues 1:00-2:00pm, MC106N) TAs:  Robert Vincent  and   Athena Kardehi Moghaddam CLASS DAY/TIME: Tuesday / Thursday 11:35am-12:55pm WHERE: ENGTR 1090 Course schedule Course syllabus Announcements Sep.1  First day of classes. Description A course for students with no previous knowledge of computer science. The course is intended to provide a survey of selected topics in computer science starting from how computers store data (text, numbers, image, sound, and video), to the inner workings of computers (hardware) and moving on to more advanced topics such as computability, complexity, web design, AI, robotics, cryptography, and social implications of computing. (3 credits; 3 hours per week) We will also explore concrete questions such as: What are the origins of computation? Are there things that computers cannot do? How do we build internet search engines? How do you teach a robot to walk and talk? How can we safely communicate confidential information? How can computers help treat individuals with chronic illnesses?docContentEnd
8docContentStartdocContentEnd
9docContentStartComputers and Computing (COMP-102) Syllabus - Fall 2011 General Information Location: ENGTR 1090 Times: Tuesday and Thursday, 11:35-12:55am. Instructor: Prof. Joelle Pineau , School of Computer Science Email:  jpineau@cs.mcgill.ca Office: McConnell 106N Office hours: Tuesdays 1:00-2:00pm Teaching assistants: Robert Vincent Email:  bert@cs.mcgill.ca Office: McConnell 111 Office hours: Wednesdays 2:00-3:00pm Athena Kardehi Moghaddam Email:  akarde@cs.mcgill.ca Office: McConnell 111 Office hours: Thursdays 10:00-11:00am Class web page:   http://www.cs.mcgill.ca/~jpineau/comp102 Course Description A course for students with no previous knowledge of computer science. The course is intended to provide a survey of selected topics in computer science starting from how computers store data (text, numbers, image, sound, and video), to the inner workings of computers (hardware) and moving on to more advanced topics such as computability, complexity, web design, AI, robotics, cryptography, and social implications of computing. (3 credits; 3 hours per week) Prerequisite:  The course is appropriate for both novice and experienced computer users. It is intended for any student with high-school-level math and science background who has a keen interest in learning how the science of computation is impacting the world in which we live. Restrictions:  Credit will not be given for COMP-102 if it is taken concurrently with, or after, any of COMP-202, COMP-203, COMP-208, or COMP-250.  Management students cannot receive credit for COMP-102. Course Outline Introduction to Computer Science. A brief history of computing.(1 week). How is information represented in a computer? Bits and bytes, data structures, sounds and images, data compression. (2 weeks) How do we tell computers what to do?  Basic ideas in algorithms, scripting, sorting and searching. (2 weeks). Computer systems. (1 week). Networks and networking. (1 week). Computability. (1 week) Special topics: Cryptography, Artificial intelligence, Robotics, Graphics, Computational biology (4 weeks) Reference Materials Required textbook:  None. Suggested reading:   The Information: A History, a Theory, a Flood  by James Gleick (Available in most local and online bookstores.) Lecture notes:  Available from the course web page as we go. Class Requirements The class grade will be based on the following components: Weekly individual assignments - 40% One in-class written midterm examinations - 20% One final exam - 40% The assignments will include some practical problems, some applications, and some writing. No formal programming is required. Homework Policy Assignments and projects must be submitted IN CLASS on the day when they are due. Assignments submitted BEFORE the due date (in class or directly to my office) will also be accepted. Late assignments will NOT be accepted (no exception).  Only the marks from the 8 best assignments will be counted towards the final grade. No make-up exams will be given.docContentEnd
10docContentStartRefereed Publications 2014 W. Hamilton, M.M. Fard, J. Pineau. "Efficient Learning and Planning with Compressed Predictive States". Journal of Machine Learning Research (JMLR). To appear. See  arXiv link  for an early version. B. Kim, J. Pineau. "Socially Adaptive Path Planning in Dynamic Environments Using Inverse Reinforcement Learning". International Journal of Social Robotics (SORO). To appear. Contact authors for an advanced copy. J. Pineau, A.K. Moghaddam, H.K.Yuen, P. Archambault, F. Routhier, F. Michaud, P. Boissy. "Automatic Detection and Classification of Unsafe Events during Power Wheelchair Use". IEEE Journal of Translational Engineering in Health and Medicine (JTEHM). To appear. [ paper ] B. Balle, W. Hamilton, J. Pineau. "Methods of Moments for Learning Stochastic Languages: Unified Presentation and Empirical Comparison". International Conference on Machine Learning (ICML). 2014. [ paper ] [ supplementary material ] S.M. Shortreed, E. Laber, T.S. Stroup, J. Pineau, S.A. Murphy. "A multiple imputation strategy for sequential multiple assignment randomized trials". Statistics in Medicine. vol.33(24). pp.4202-4214. Contact authors for an advanced copy. A.M.S. Barreto, J. Pineau, D. Precup. "Policy Iteration Based on Stochastic Factorization". Journal of Artificial Intelligence Research (JAIR). vol.50, pp.763-803. [ paper ] P. Rushton, D. Kairy, P. Archambault, E. Pituch, C. Torkia, A. El-Fathi, P. Stone, F. Routhier, R. Forget, J. Pineau, R. Gourdeau, L. Demers. "The Potential Impact of Intelligent Power Wheelchair Use on Social Participation: Perspectives of Users, Caregivers, and Clinicians". Disability and Rehabilitation: Assistive Technology. 2014. 7p. [ .pdf ] D. Kairy, P. Rushton, P. Archambault, E. Pituch, C. Torkia, A. El Fathi, P. Stone, F. Routhier, R. Forget, L. Demers, J. Pineau, R. Gourdeau. "Exploring Powered Wheelchair Users and Their Caregivers' Perspectives on Potential Intelligent Power Wheelchair Use: A Qualitative Study". International Journal of Environmental Research and Public Health. 2014. vol.11. pp.2244-2261. [ .pdf ] 2013 B. Kim, A.M. Farahmand, J. Pineau, D. Precup, "Learning from Limited Demonstrations". Neural Information Processing Systems (NIPS). 2013. [ .pdf ] M. M. Fard, Y. Grinberg, A.M. Farahmand, J. Pineau, D. Precup, "Bellman Error Based Feature Generation using Random Projections on Sparse Spaces". Neural Information Processing Systems (NIPS). 2013. [ .pdf ] Patrice Boucher, Amin Atrash, Sousso Kelouwani, Wormser Honoré, Hai Nguyen, Julien Villemure, François Routhier, Paul Cohen, Louise Demers, Robert Forget, Joelle Pineau, "Design and validation of an intelligent wheelchair towards a clinically-functional outcome", Journal of NeuroEngineering and Rehabilitation, vol.10:58. pp.1-16. 2013. [ .pdf ] W. Hamilton, M. M. Fard, J. Pineau "Modelling sparse dynamical systems with compressed predictive state representations". International Conference on Machine Learning (ICML). 2013. [ .pdf ] B. Kim, J. Pineau. "Maximum Mean Discrepancy Imitation Learning". Robotics: Science and Systems (RSS). 2013. [ .pdf ] S.C.W. Ong, Y. Grinberg, J. Pineau. "Mixed Observability Predictive State Representations". AAAI Conference on Artificial Intelligence. 2013. [ .pdf ] G. Panuccio, A. Guez, R. Vincent, M. Avoli, J. Pineau. "Adaptive control of epileptiform excitability in an in vivo model of limbic seizures". Experimental Neurology. 241: 179-83. [ .pdf (unformatted) ] J. Frank, S. Mannor, J. Pineau, D. Precup. "Time Series Analysis Using Geometric Template Matching". Transactions on Pattern Matching and Machine Intelligence (PAMI). 35(3): 740-754. [ Link ] C. Hundt, P. Panagaden, J. Pineau, D. Precup, M. Dinculescu. "The duality of state and observation in probabilistic transition systems". Lecture Notes in Computer Science (LNCS) 7758 (proceedings of TbiLLC 2011). Springer. pp.206-230. 2013. [ .pdf ] C. Paduraru, D. Precup, J. Pineau, G. Comanici. "An empirical analysis of off-policy learning in discrete MDPs.". JMLR: Workshop and Conference Proceedings. 10th European Workshop on Reinforcement Learning. vol.24. pp.89-101. [ .pdf ] D. Kairy, P. Archambault, P.W. Rushton, E. Pituch, A. El Fathi, C. Torkia, P. Stone, F. Routhier, R. Forget, L. Demers, J. Pineau, R. Gourdeau. "Users' Perspectives of Intelligent Power Wheelchair Use". RESNA Annual Conference. 2013. 2012 A.M.S. Barreto, D. Precup, J. Pineau. "On-line reinforcement learning using incremental kernal-based stochastic factorization". Neural Information Processing Systems (NIPS). 2012. [ .pdf ] (main paper) [ .pdf ] (supplemental material) S. Png, J. Pineau, B. Chaib-draa. "Buildling adaptive dialogue systems via Bayes-adaptive POMDP". IEEE Journal of Selected Topics in Signal Processing. vol.6(8). 2012. [ .pdf ] G. Shani, J. Pineau, R. Kaplow. "A survey of point-based POMDP solvers". Autonomous Agents and Multi-Agent Systems. 2012. [ .pdf ] K. Bush, G. Panuccio, M. Avoli, J. Pineau. "Evidence-based modeling of network discharge dynamics during periodic pacing to control epileptiform activity". Journal of Neuroscience Methods. 2012. vol.204. pp.318-325. [ .pdf ] F. Doshi-Velez, J. Pineau, N. Roy. "Reinforcement learning with limited reinforcement: Using Bayes risk for active learning in POMDPs". Artifical Intelligence. vol.187-188. August 2012. pp.115-132. [ .pdf ] M. M. Fard, Y. Grinberg, J. Pineau, D. Precup, "Compressed Least-Squares Regression on Sparse Spaces", Twenty-Sixth AAAI Conference on Artificial Intelligence (AAAI'12). 2012. [ .pdf ] M. M. Fard, Y. Grinberg, J. Pineau, D. Precup. "Random Projections Preserve Linearity in Sparse Spaces. Technical Report. 2012.  (Companion to our AAAI'12 paper.) [ .pdf ] E. Tsang, S. C. W. Ong, J. Pineau. "Design and Evaluation of a Flexible Interface for Spatial Navigation". Canadian Conference on Computer and Robot Vision. 2012. [ .pdf ] C. Paduraru, D. Precup, J. Pineau, G. Comanici. "A Study of Off-policy Learning in Computational Sustainabiity". European Workshop on Reinforcement Learning (EWRL). 2012. [ .pdf ] M. M. Fard, Y. Grinberg, J. Pineau, D. Precup. "Bellman Error Based Feature Generation Using Random Projections".  European Workshop on Reinforcement Learning (EWRL). 2012. [ .pdf ] 2011 A. M. S. Barreto, D. Precup, J. Pineau. "Reinforcement Learning using Kernel-Based Stochastic Factorization". Neural Information Processing Systems (NIPS-24). 2011. [ .pdf ] S. Ross, J. Pineau, B. Chaib-draa, P. Kreitmann. "A Bayesian Approach for Learning and Planning in Partially Observable Markov Decision Processes". Journal of Machine Learning. 12. pp.1655-1696. 2011. [ .pdf ] M. M. Fard, J. Pineau. "Non-Deterministic Policies in Markovian Decision Processes". Journal of Artificial Intelligence Research (JAIR). 40. pp.1-24. 2011. [ .pdf ] S. M. Shortreed, E. Laber, D. J. Lizotte, S. Stroup, J. Pineau, S. Murphy. "Informing sequential clinical decision-making through reinforcement learning:  an empirical study". Machine Learning. 84(1). pp.109-136. 2011. [ Link ] (Or email me for a copy.) J. Pineau, R. West, A. Atrash, J. Villemure, F. Routhier. "On the Feasibility of Using a Standardized Test for Evaluating a Speech-Controlled Smart Wheelchair". International Journal of Intelligent Control and Systems. 16(2). pp.121-128. 2011. [ .pdf ] R.D. Vincent, A. Courville, J. Pineau. "A bistable computational model of recurring epileptiform activity as observed in rodent slice preparation". Neural Networks. 24(6) pp.526-537. 2011.  	[ .pdf ] M. Fard, J. Pineau, C. Szepesvari. "PAC-Bayesian Policy Evaluation for Reinforcement Learning". Proceedings of the Conference on Uncertainty in Artificial Intelligence (UAI). 2011. [ .pdf ] K. Deng, J. Pineau and S.A. Murphy. "Active Learning for Developing Personalizing Treatment". Proceedings of the Conference on Uncertainty in Artificial Intelligence (UAI). 2011. [ .pdf ] S. Png, J. Pineau. "Bayesian Reinforcement Learning for POMDP-based dialogue systems". International Conference on Acoustics, Speech and Signal Processing (ICASSP). 2011. [ .pdf ] A. K. Moghaddam, J. Pineau, J. Frank, P. S. Archambault, F. Routhier, T. Audet, J. Polgar, F. Michaud, P. Boissy. "Mobility Profile and Wheelchair Driving Skills of Powered Wheelchair Users: Sensor-Based Event Recognition Using a Support Vector Machine Classifier". 33rd Annual International IEEE EMBS Conference. 2011. [ .pdf ] S.C.W. Ong, Y. Grinberg, J. Pineau. "Goal-directed online learning of predictive models". European Workshop on Reinforcement Learning (EWRL). LNCS. Springer. 2011. C. Paduraru, D. Precup, J. Pineau. "A framework for computing bounds for the return of a policy". European Workshop on Reinforcement Learning (EWRL). LNCS. Springer. 2011. K. Deng, J. Pineau, S. Murphy. "Active Learning for Personalizing Treatment". IEEE Symposium on Adaptive Dynamic Programming and Reinforcement Learning (ADPRL). 2011. [ .pdf ] Y. Grinberg, M. M. Fard, J. Pineau, "Least-Squares Regression on Sparse Spaces", NIPS Workshop on Sparse Representation and Low-rank Approximation (NIPS'11). 2011. [ .pdf ] Y. Grinberg, M. M. Fard, J. Pineau, "LSTD on Sparse Spaces", NIPS Workshop on New Frontiers in Model Order Selection (NIPS'11). 2011. [ .pdf ] 2010 M. M. Fard, J. Pineau. "PAC-Bayesian Model Selection for Reinforcement Learning". Neural Information Processing Systems (NIPS-23). 2010. [ .pdf ] R. West, D. Precup, J. Pineau. "Automatically Suggesting Topics for Augmenting Text Documents". The 19th ACM Conference on Information and Knowledge Management (CIKM). 2010. [ .pdf ] W. Honore, A. Atrash, P. Boucher, R. Kaplow, S. Kelouwani, H. Nguyen, J. Villemure, R. West, F. Routhier, P. Stone, C. Dufour, J.-P. Dussault, D. Rock, P. Cohen, L. Demers, R. Forget, J. Pineau. "Human-Oriented Design and Initial Validation of an Intelligent Powered Wheelchair". RESNA Annual Conference. 2010. [ .pdf ] [ .html ] A. Guez, J. Pineau. "Multi-Tasking SLAM". International Conference on Robotics and Automation (ICRA). 2010. [ .pdf ] R. Kaplow, A. Atrash, J. Pineau. "Variable Resolution Decomposition For Robotic Navigation Under a POMDP Framework". International Conference on Robotics and Automation (ICRA). 2010. [ .pdf ] J. Pineau, R. West, A. Atrash, J. Villemure, F. Routhier. "Towards a Standardized Test for Intelligent Wheelchairs". Performance Metrics for Intelligent Systems (PerMIS). 2010. [ .pdf ] J. Pineau, A. Atrash, R. Kaplow, J. Villemure. "On the design and validation of an intelligent powered wheelchair: Lessons from the SmartWheeler project". CIM Symposium on Brain, Body and Machine. 2010. [ .pdf ] 2009 A. Atrash, R. Kaplow, J. Villemure, R. West, H. Yamani, J. Pineau. "Development and Validation of a Robust Interface for Improved Human-Robot Interaction". International Journal of Social Robotics. 2009. [ .pdf ] J. Pineau, A. Guez, R. Vincent, G. Panuccio, M. Avoli. "Treating epilepsy via adaptive neurostimulation: A reinforcement learning approach". International Journal of Neural Systems. 19(4). pp.227-240. 2009.   (Email me for a copy.) K. Bush, J. Pineau. "Manifold Embeddings for Model-Based Reinforcement Learning under Partial Observability". Neural Information Processing Systems (NIPS-22). 2009. [ .pdf ] R. West, D. Precup, J. Pineau. "Completing Wikipedia's Hyperlink Structure through Dimensionality Reduction". The 18th ACM Conference on Information and Knowledge Management (CIKM). 2009. [ .pdf ] R. West, J. Pineau and D. Precup. "Wikispeedia: An Online Game for Inferring Semantic Distances between Concepts". International Joint Conferences on Artificial Intelligence (IJCAI). 2009. [ .pdf ] A. Atrash and J. Pineau. "A Bayesian Reinforcement Learning Approach for Customizing Human-Robot Interfaces". International Conference on Intelligent User Interfaces (IUI). 2009. [ .pdf ] K. Bush, J. Pineau & M. Avoli. "Manifold Embeddings for Model-Based Reinforcement Learning of Neurostimulation Policies". ICML/UAI/COLT Workshop on Abstraction in Reinforcement Learning. 2009. [ .pdf ] 2008 S. Ross, J. Pineau, S. Paquet, B. Chaib-draa. "Online Planning Algorithms for POMDPs". Journal of Artificial Intelligence Research (JAIR). 32. pp.663-704. 2008. [ .pdf ] M. M. Fard and J. Pineau. "MDPs with Non-Deterministic Policies". Neural Information Processing Systems (NIPS-21). 2008. [ .pdf ] S. Ross & J. Pineau. "Model-Based Bayesian Reinforcement Learning in Large Structured Domains".  Uncertainty in Artificial Intelligence (UAI). 2008. [ .pdf ] M. M. Fard, J. Pineau and P. Sun. "A Variance Analysis for POMDP Policy Evaluation". AAAI Conference on Artificial Intelligence. 2008. [ .pdf ] A. Guez, R. Vincent, M. Avoli, & J. Pineau. "Adaptive Treatment of Epilepsy via Batch-mode Reinforcement Learning". Innovative Applications of Artificial Intelligence (IAAI). 2008. [ .pdf ] F. Doshi, J. Pineau and N. Roy. "Reinforcement Learning with Limited Reinforcement: Using Bayes Risk for Active Learning in POMDPs". International Conference on Machine Learning (ICML). 2008. [ .pdf ] S. Ross, B. Chaib-draa, & J. Pineau. "Bayesian Reinforcement Learning in Continuous POMDPs with Application to Robot Navigation". International Conference on Robotics and Automation (ICRA). 2008. [ .pdf ] 2007 J. Pineau, M.G. Bellemare, A.J. Rush, A. Ghizaru, & S.A. Murphy. "Constructing evidence-based treatment strategies using methods from computer science." Drug and Alcohol Dependence. 88S Elsevier. p.S52-S60. 2007. (Email me for a copy.) R. Jaulmes, J. Pineau & D. Precup. "Apprentissage actif dans les Processus Decisionnels de Markov Partiellement Observables''. Revue d'Intelligence Artificielle. 2(1). pp.9-34. 2007. [ .pdf ] S. Ross, B. Chaib-draa, & J. Pineau. "Bayes-Adaptive POMDPs". Neural Information Processing Systems (NIPS-20). 2007. [ .pdf ] Tech report version with the proofs: [ .pdf ] S. Ross, J. Pineau & B. Chaib-draa. "Theoretical Analysis of Heuristic Search Methods for Online POMDPs". Neural Information Processing Systems (NIPS-20). 2007. [ .pdf ] R. Jaulmes, J. Pineau & D. Precup. "A formal framework for robot learning and control under model uncertainty." IEEE International Conference on Robotics and Automation (ICRA). 2007. [ .pdf ] R. Vincent, J. Pineau, P. de Guzman & M. Avoli. "Recurrent Boosting for Classification of Natural and Synthetic Time-Series Data". Canadian Conference on Artificial Intelligence (CanAI). pp.192-293. 2007. [ .pdf ] J. Pineau & A. Atrash for the SmartWheeler team. "SmartWheeler: A robotic wheelchair test-bed for investigating new models of human-robot interaction." AAAI Spring Symposium on Multidisciplinary Collaboration for Socially Assistive Robotics. 2007. [ .pdf ] 2006 J. Pineau, G. Gordon & S. Thrun. "Anytime point-based approximations for large POMDPs." Journal of Artificial Intelligence Research (JAIR). 27. pp.335-380. 2006. [ .pdf ] R. Gavalda, P.W. Keller, J. Pineau and D. Precup. "PAC-Learning of Markov Models with Hidden State". European Conference on Machine Learning (ECML). 2006. [ .pdf ] C. Hundt, P. Panangaden, J. Pineau & D. Precup "Representing systems with hidden state''. National Conference of Artificial Intelligence (AAAI). 2006. [ .pdf ] D. Burfoot, J. Pineau & D. Dudek "RRT-Plan: a Randomized Algorithm for STRIPS Planning''. International Conference on Automated Planning and Scheduling (ICAPS). 2006. [ .pdf ] A. Atrash & J. Pineau "Efficient Planning and Tracking in POMDPs with Large Observation Spaces". AAAI-06 Workshop on Empirical and Statistical Approaches for Spoken Dialogue Systems. 2006. [ .pdf ] R. Vincent, J. Pineau, P. de Guzman, & M. Avoli "Recurrent Boosting Method for Time-Dependent Classification of Epileptiform Signals". North Easth Student Colloquium on Artificial Intelligence (NESCAI). 2006 [ .pdf ] 2005 J. Pineau & G. Gordon "POMDP Planning for Robust Robot Control''. International Symposium on Robotics Research (ISRR) San Francisco, CA. 2005. [ .pdf ] R. Jaulmes, J. Pineau & D. Precup "Active Learning in Partially Observable Markov Decision Processes". European Conference on Machine Learning (ECML). Porto, Portugal. 2005. [ .pdf ] R. Jaulmes, J. Pineau & D. Precup "Active Learning in Partially Observable Markov Decision Processes". NIPS Workshop on Value of Information in Inference, Learning and Decision-Making. Whistler, Canada. 2005 [ .pdf ] R. Jaulmes, J. Pineau & D. Precup "Probabilistic Robot Planning Under Model Uncertainty: An Active Learning Approach". NIPS Workshop on Machine Learning Based Robotics in Unstructured Environments. Whistler, Canada. 2005 [ .pdf ] R. Jaulmes, J. Pineau & D. Precup "Learning in Non-Stationary Partially Observable Markov Decision Processes". ECML Workshop on Reinforcement Learning in Non-Stationary Environments. Porto, Portugal. 2005. [ .pdf ] 2004 J. Pineau, G. Gordon & S. Thrun "Applying Metric-Trees to Belief-Point POMDPs''. Neural Information Processing Systems (NIPS-16). Vancouver, Canada. 2004. [ .ps ] [ .pdf ] 2003 J. Pineau, M. Montemerlo, M. Pollack, N. Roy, & S. Thrun "Towards robotic assistants in nursing homes: Challenges and results''. Special issue on Socially Interactive Robots, Robotics and Autonomous Systems 42 (3-4). pp.271-281. 2003. [ .pdf ] J. Pineau, G. Gordon & S. Thrun "Point-based value iteration: An anytime algorithm for POMDPs''. International Joint Conference on Artificial Intelligence (IJCAI). Acapulco, Mexico. pp. 1025-1032. Aug. 2003. [ .ps ] [ .pdf ] J. Pineau, G. Gordon & S. Thrun. "Policy-contingent abstraction for robust robot control''. Conference on Uncertainty in Articifical Intelligence (UAI). Acapulco, Mexico. pp. 477-484. Aug. 2003. [ .ps ] [ .pdf ] 2002 M. Montemerlo, J. Pineau, N. Roy, S. Thrun & V. Verma "Experiences with a Mobile Robotic Guide for the Elderly''. National Conference on Artificial Intelligence (AAAI). Edmonton, AB. pp. 587-592. Aug. 2002. [ .ps ] [ .pdf ] J. Pineau, M. Montemerlo, M. Pollack, N. Roy & S. Thrun. "Probabilistic control of human robot interaction: Experiments with a robotic assistant for Nursing Homes''. The second IARP/IEEE/RAS Joint Workshop on Technical Challenges for Robots in Human Environments (DRHE). Toulouse, France. Oct. 2002. [ .ps ] [ .pdf ] J. Pineau, & S. Thrun. "High-level robot behaviour control with POMDPs''. AAAI Workshop on Cognitive Robotics. Edmonton, Canada. Aug. 2002. [ .ps ] [ .pdf ] [ Presentation slides (.ppt) ] M. Pollack, S. Engberg, J.T. Matthews, S. Thrun, L. Brown, D. Colbry, C. Orosz, B. Peintner, S. Ramakrishnan, J. Dunbar-Jacob, C. McCarthy, M. Montemerlo, J. Pineau, & N. Roy. "Pearl: A Mobile Robotic Assistant for the Elderly''. Workshop on Automation as Caregiver: the Role of Intelligent Technology in Elder Care (AAAI). Edmonton, AB. Aug. 2002. 2001 J. Pineau, N. Roy & S. Thrun. "A Hierarchical Approach to POMDP Planning and Execution''. ICML Workshop on Hierarchy and Memory in Reinforcement Learning. Williams College, MA. June 2001. June 2001. [ .ps ] [ .pdf ] N. Roy, G. Baltus, D. Fox, F. Gemperle, J. Goetz, T. Hirsch, D. Margaritis, M. Montemerlo, J. Pineau, J. Schulte & S. Thrun. "Towards Personal Service Robots for the Elderly''. Workshop on Interactive Robots and Entertainment (WIRE). Pittsburgh, PA. 2000. [ .ps ] [ .pdf ] [ .html ] 2000 N. Roy, J. Pineau & S. Thrun. "Spoken Dialog Management Using Probabilistic Reasoning''. Association for Computational Linguistics (ACL). Hong Kong, Oct. 2000. [ .ps ] [ .pdf ] D. Goddeau & J. Pineau "Fast Reinforcement Learning of Dialog Strategies''. IEEE Conference on Acoustics, Speech and Signal Processing (ICASSP). Istanbul, Turkey. June 2000. [ .ps ] [ .pdf ] [ Presentation slides (.html) ] Book chapters N. Roy & J. Pineau "Robotics and Independence for the Elderly''. In  Growing Old in a Technological Society . G. Lesnoff-Caravaglia (Ed.) C. Thomas of Springfield. Illinois, USA. pp.209-242. 2007. Edited volumes N. Vlassis, G. Gordon, & J. Pineau, editors. "Reasoning with Uncertainty in Robotics". Proceedings from the IJCAI-05 Workshop on Reasoning with Uncertainty in Robotics (RUR-05). International Joint Conference on Artificial Intelligence. Edinburgh, Scotland. 2005 [ .pdf ] Technical Reports S. Ross, B. Chaib-draa, & J. Pineau. "Bayes-Adaptive POMDPs".  SOCS-TR-2007. School of Computer Science. McGill University. 2007. (NOTE: This is a long version of the identically-titled NIPS paper above. It includes proofs for the lemmas and theorems presented in the paper.) [ .pdf ] D. Burfoot, J. Pineau & D. Dudek "RRT-Plan: a Randomized Algorithm for STRIPS Planning''. CIM-TR-2006. McGill University, Center for Intelligent Machines.2006. (NOTE: This is a long version of the identically-titled ICAPS paper above.) [ .pdf ] J. Pineau, G. Gordon & S. Thrun. "Point-based approximations for fast POMDP solving". SOCS-TR-2005.4. McGill University. School of Computer Science. 2005. [ .pdf ] J. Pineau & S. Thrun. "An integrated approach to hierarchy and abstraction for POMDPs". CMU-RI-TR-02-21. Carnegie Mellon University. Robotics Institute. 2002. [ .ps ] [ .pdf ] Thesis J. Pineau. "Tractable Planning Under Uncertainty: Exploiting Structure''. PhD Thesis. August 2004. [ .ps ] [ .pdf ] [ Presentation slides (.pdf) ] J. Pineau. "Hierarchical Methods for Planning under Uncertainty''. Thesis proposal. June 2001. [ .ps ] [ .pdf ] Last modified: Thu May 18 10:04:28 EDT 2005docContentEnd
11docContentStartCOMP-424: Artificial Intelligence (Winter 2015) INSTRUCTOR: Joelle Pineau TAs: T.b.d. Term: Winter 2015. When: Monday / Wednesday 11:35-12:55pm Where: Leacock 26 Course syllabus  (including info on TAs, office hours, contact information.) Course schedule  (including lecture slides, homeworks, solutions.) Announcements IMPORTANT: NEW PRE-REQ!  At least one university level course in probability and/or statistics, e.g. MATH-203, MATH-323, ECSE-305.  Students who have not satisfied this requirement will NOT be admitted into the course for Winter 2015. Description We will cover selected topics in Artificial Intelligence.  We will study modern techniques for computers to make good (in some cases optimal) decisions that are applicable throughout an enormous range of industrial, civil, medical, financial, robotic and information systems.  We will not attempt to cover the entire range of AI sub-areas in detail, but will survey several key themes. Topics covered Introduction to AI.  Brief history.  Different agent architectures. Search: uninformed and heuristic search, A*, local search and optimization. Constraint satisfaction problems. Game playing and adversarial search. Knowledge representation. Logical reasoning. Propositional logic. Planning algorithms. Reasoning under uncertainty.  Bayes rule.  Belief networks. Decision making. Utility theory. Reinforcement learning. Game theory. Applications. IMPORTANT:  The schedule is subject to change. Up-to-date information about the schedule and assigned readings will be posted on the class web page.docContentEnd
12docContentStartdocContentEnd
13docContentStartArtificial Intelligence I (COMP-424) Syllabus - Winter 2014 General Information Location: Duff Theater 1 Times: Tuesday and Thursday, 2:35-3:55pm. Instructor: Prof. Joelle Pineau , School of Computer Science Office: McConnell Engineering 106N Office hours: Tuesdays 1:00-2:00pm in my office.    jpineau@cs.mcgill.ca Teaching assistants: Phil Bachman , MC 111   Office hours: Thurs. 4-5pm.    phil.bachman@gmail.com  (Please use COMP-424 in subject line, otherwise email might be filtered out.) Pierre-Luc Bacon , MC 111   Office hours: Fri. 12-1pm.    pierre-luc.bacon@mail.mcgill.ca Clement Gehring , MC 111   Office hours: Wed. 4:30-5:30pm    clement.gehring@mail.mcgill.ca William Hamilton , MC 112   Office hours: Mon. 10:30-11:30am    william.hamilton2@mail.mcgill.ca Class web page:   http://www.cs.mcgill.ca/~jpineau/comp424 Course Description We will cover selected topics in Artificial Intelligence.  We will study modern techniques for computers to make good (in some cases optimal) decisions that are applicable throughout an enormous range of industrial, civil, medical, financial, robotic and information systems.  We will not attempt to cover the entire range of AI sub-areas in detail, but will survey several key themes. Course content Introduction to AI.  Brief history.  Different agent architectures. Search: uninformed and heuristic search, A*, local search and optimization. Constraint satisfaction problems. Game playing and adversarial search. Knowledge representation. Logical reasoning. Propositional logic. Planning algorithms. Reasoning under uncertainty.  Bayes rule.  Belief networks. Decision making. Utility theory. Reinforcement learning. Game theory. Applications. Reference Materials Required textbook:  S. Russell and P. Norvig.   Artificial Intelligence: A Modern Approach ,  Third Edition , Prentice Hall, 2009. Available at the McGill bookstore. Lecture notes:  available from the course web page. Prerequisites Courses: (COMP 206 or ECSE 321) and COMP 251.  In some cases, students may take COMP-251 concurrently with COMP-424 (subject to instructor's permisson). Basic knowledge of a programming language is required. Basic knowledge of probabilities/statistics, calculus and linear algebra is strongly recommended. Class Requirements The class grade will be based on the following components: Individual quizzes in class (best 5 out of 8) - 5% Individual assignments (best 4 out of 5) - 20% Individual project (one) - 20% In-class midterm examination (one) - 15% Final examination (one) - 40%. The weekly quizzes will be short tests designed to assess basic understanding of the course material as we progress through the topics. The assignments will require primarily written work and some programming to gain hands-on experience with the concepts covered in the lectures. The project will be composed of a programming part and a written report.  In the programming part, you will implement a game-playing program that will play against your colleagues' programs over the network. You will be provided with a complete program for a player that chooses moves legally but randomly.  Your mission will be to enhance the player, using AI techniques of your choice.  The project code will be written in Java. The ability to program in Java under the UNIX operating system is assumed but the use of this language is not mandatory.  You may use any programming language, as long as you can demonstrate that your implementation is correct. In the report, you will describe your approach, and justify your choice of algorithms. Both the midterm and the final examination are written examinations.  The midterm will be held during class hours. No make-up midterm will be given. The final will be held during the regular exam period. Grading Policy Assignments and projects must be submitted on myCourses by 11:59pm on the day when they are due. Submission procedure for quizzes will be explained in class.  Late quizzes and assignments will NOT be accepted (NO EXCEPTIONS - Please do not email asking for this.).  However only the marks from the 5 best quizzes and the 4 best assignments will be counted towards the final grade.  Late submissions for the final project (code and report) will be subject to a 10% penalty, up to 5 days only ; after this late submissions will not be accepted. All assignments are INDIVIDUAL! McGill University values academic integrity.  Therefore all students must understand the meaning and consequences of cheating, plagiarism and other academic offences under the Code of Student Conduct and Disciplinary Procedures (see www.mcgill.ca/students/srr/honest/  ) for more information). Any work submitted in this course (including code, report, homeworks) may be checked using automated software to detect possible cases of cheating or plagiarism. In accord with McGill University's Charter of Students' Rights, students in this course have the right to submit in English or in French any written work that is to be graded. In the event of extraordinary circumstances beyond the University's control, the content and/or evaluation scheme in this course is subject to change.docContentEnd
14docContentStartBVH Blender Movie Instructions This page describes instructions on how to render a movie of a BVH sequence with ambient occlusion and motion blur using Blender.  You should plan ahead as this step can be time consuming depending on the length of your motion sequence.  That is, you will likely need to let your computer render for a few hours! Use the following steps as a general guide for setting up and rendering your movie, but feel free to experiment and do your own thing! Download and install  Blender .  Note that you will also need to install  Python , and you should be careful to install the exact version that Blender asks (if it isn't correct it will complain, and you'll likely not be able to use any scripts).  If you missed the 15 minute tutorial in class on using Blender, you may want to read the getting started tutorial in the  tutorial archive , or search for video tutorials on youtube. You'll also need a script to help build geometry for the armature you will load from the bvh file.  Download the python script at  this page .  Put the script in your .blender/scripts folder.  The location of this folder will vary depending on how you install Blender.  On windows, this will either be under the "Program Files" folder or in a user folder such as "C:\Documents and Settings\kry\Application Data\Blender Foundation\Blender\.blender\scripts" on XP or "C:\Documents\kry\AppData\Blender Foundation\Blender\.blender\scripts" on Vista.  Check that the script is loaded by running Blender, and then selecting scripts from the button at the top left the window (the button has a tool tip to tell you that the button lets you select the window type). Click the scripts button that appears when you change the window type to scripts, and verify that "Armature Modeler" appears under the "Animation" entry.  If it doesn't show up, or if other items are empty (or if the import options are missing in the next step), then your scripts are likely not installed correctly.  Check for errors and repeat!  Put the top window back to "User Preferences" type when you are done so you have access to the menu bar. Now, load out.bvh using the menu "File -> Import -> MotionCapture (.bvh)...".  When you click on the "Import BVH" button, "As Armature" will be selected. Click OK. After loading, the armature will be selected by default. You'll want to rotate it 90 in x so that it is walking on the x-y plane instead of the x-z plane.  Press 'n', then click the value next to RotX and set it to 90. Press 'numberpad-0' to see the camera view.  Use the middle mouse button to rotate out of the camera view.  Use the scroll wheel to zoom in and out.  To see the animation that you loaded you'll want to bring up the timeline: right click exactly on the line between the perspective panel and select "split area", then left click in the bottom panel to divide the area.  Click the left top most button in the area you created, and select timeline from the menu.  Use the left mouse button to drag in the timeline to see the animation. When you started Blender, the default scene included a cube called "Cube".  Use the cube to create a template bone geometry. Select it by right clicking on it.  Press n to show the transform properties if they are not already showing.  Set the scale in y to be 3, then translate the scaled cube so that its long direction is going down the y axis.  Press 'tab' to go into edit mode, and then set Median Y to 1.0 in the transform properties window, then press tab again to return to object mode. Select the armature by right clicking on it, then select "Pose Mode" from the mode combo box (the one that was changing between object and edit when you press tab).  Press 'a' to select all the armature bones.  Now select in your scripts window "Scripts->Animation->Armature Modeler".  If you do not see the whole interface then make the window a bit larger.  Change the bone type from "Octaedron" to "custom" and provide the name "Cube" where it asks for OB.  Feel free to follow the instructions on Malefico's page to create different geometry, or tune the shapes in other ways. Create a plane for your character to walk on by selecting from the menu Add->Mesh->Plane.  Scale and position your plane by adjusting the transform properties (press 'n' to bring them up). Location 0,0,0 and scale 50,50,50 should work OK.  You may want to translate your original Cube below the plane so it is hidden from view. Change the colour of your character by selecting the Cube and pressing F5 to bring up the shading buttons, then select the small red sphere to select the material buttons.  Under Material, click on the grey rectangle next to "Col" to select a different colour. Turn on ambient occlusion rendering by pressing the world "World buttons" when you have the shading buttons selected. Pressing F5 multiple times will take you there.  It is the last button on the right.  Select the "Amb Occ" tab and press the "Ambient Occlusion" button.  The default settings are fine. Change the position of the camera so you can properly see your character throughout the animation.  Select the camera by right clicking it, press 'numberpad-0' for the camera view, 'n' to change change its position and orientation. Change the position of the light so you can properly see your character.  Right click the light drag it around, or set its transform properties. Press F12 to do a test render, and adjust everything as you see fit. Press F10 to select the "Scene" button and make sure the left most button with tooltip "Render buttons" is selected. Under "Format" choose "AVI Codec" instead of "jpeg", select xvid, and configure the codec for high quality.  Just under file format combo box is a FPS setting.  Since the natural point system records at 100 Hz, you should change the value to 100.  In the "Anim" tab to the left, change the step setting at the bottom to be 10 so that you're not rendering every frame, and set the End frame to be whatever you want as the end frame (check by scrubbing the cursor in the timeline window).  Finally, in the "Render" tab press the "MBLUR" button and set the Bf parameter to some suitable parameter, such as 5 (i.e., so it renders the blur over a longer period of time).  Press F12 once more for a test render to see that everything is satisfactory for the current frame. Finally, when you are ready, press the "ANIM" button on the "Anim" tab to render the whole animation to disk.  This will likely take a few hours, so you might want to test with a short sequence first and make any adjustments based on the result.docContentEnd
15docContentStartCOMP 557 - Fall 2010 - Assignment 3 Catmull-Clark Subdivision Surfaces Due 12:00 Noon Wednesday 10 November Getting Started In this assignment you will build half edge data structures from polygon soups, and subdivide meshes using the Catmull-Clark subdivision scheme.  The polygon soup loader has been written for you and is very minimal.  It will load the vertex and face data from an 'obj' file (though these files can also contain lots of other information too).  We have also provided you with a number of sample meshes that will be useful for testing your program. Provided Code Download the sample code from WebCT.  It is a working program that will load one of the sample polygon soups and will draw it.  You will need to add the jogl, vecmath, and mintools jars to your project. The sample code zip file has the following contents. A3App The main application loads a polygon soup, will make calls to try to build a half edge data structure and will try to subdivide it (these method calls will fail because you need to implement them). The display call will draw the coarse polygon mesh by default, and also draws a half edge of the coarsest half edge data structure. You can use the keyboard interface to walk the half edge data structure.  Press space to go to the twin and N for the next half edge.  Left and Right arrows will take you to first and second child (if they exist), while up arrow will take you to the parent (if it exists).  Home and end keys can be used to change the subdivision level currently displayed, while page up and page down will allow you to go forwards and backwards in the model list (the model is loaded and subdivided each time). PolygonSoup Contains a vertexList and a faceList, and code to load these from an obj file.  There is also some simple drawing code used by the A3App  class to draw the loaded soup. HalfEdge The half edge class is simple, and provided for you.  It has 6 pointers ( next, head, twin, child1, child2, parent ), and a method for drawing a half edge to help you verify that your program is working.  For your convenience, it also contains a  prev method to get the previous half edge. Vertex The vertex class is simply a container to hold the position of the vertex, the normal (if it has been computed), and a pointer to its subdivision child (if it exists). Face The face class is a simple container for the face normal (for flat shading), a pointer to the half edge, and a pointer to its subdivision child (a vertex) if it exists.  The constructor will compute the normal and set all the  leftFace  pointers of the half edge loop appropriately. HEDS  (you need to finish this class) HEDS is the Half Edge Data Structure, and simply contains a list of faces (each face has a half edge loop).  You will need to implement the constructor which builds the structure given a polygon soup CatmullClark  (you need to finish this class) This class has one method called subdivide which takes a half edge data structure and returns the half edge data structure for the subdivided mesh.  You will need to implement this method, and will likely want to create several private static helper methods to complete the objectives described below.docContentEnd
16docContentStartCOMP 557 - Fall 2009 - Assignment 4 Ray Tracing Due noon Wednesday 1 December Getting Started In this assignment, you will write a raytracer.  Note that there is no written part to this assignment. The sample code on webCT will get you started with an XML scene file parser and code to write PNG image file. You are free to make any modifications and extensions that you please, to both the XML format, parser code, and the ray tracing code; however, your code should still work with the simple examples provided, and likewise, any changes you make must be well documented in your readme file. XML scene description The XML file is organized as sequence of named materials, lights, cameras, nodes, and renders.  The main scene is defined in the node with the name "root".  In general you will only need to have one node defined, and it must have the name "root", but nodes can also be referred to within the scene graph hierarchy as an instance (i.e., to help you reuse parts of the scene hierarchy multiple times). The scene nodes each have an associated transformation.  The node definition can contain a list of transformations (translation, rotx, roty, rotz, and scale (and others if you choose to add them)). These transformations are applied in order to build the node transformation (note in  SceneNode.java  how the transforms are applied in the order in which they are parsed from the file). The node can also list a number of different kinds of geometry (sphere, cube, mesh, instance).  Finally, the node can also contain a list of child nodes, allowing a hierarchy of transformations and geometry to be built. Look at the two examples provided to get a better idea of how the scene description files are organized.  Please share your test scenes on WebCT.  Note again that you may also need to implement additional tags and attributes as you proceed through the objectives. Provided Code A4App opens an xml document and calls the Scene constructor to load the scene definition from the xml file.  It then calls the scene render method to produce an image file.  This render method is a good place to start making changes to the code, but you will need to make lots of changes to many classes, and make new classes on your own.  You've been provided with basic classes for defining a materials, lights, and nodes, but they do nothing but hold loaded data.  A Ray class and an intersection result have been defined for your convenience, but you may wish or need to change them.  They are defined to allow the Intersectable interface to be defined.  The sphere, cube, plane, mesh, or any other geometry (or node) that can be intersected will implement this interface. Optional Competition There will be optional competition for images created with your raytracer. You do not submit an image if you do not want to participate. To participate, you should submit an image, and a short description describing the technical achievements and/or artist statement for your submission.  Submit the image and statement with your assignment. A small jury will judge submissions based on aesthetics, creativity, and technical merit. Steps and Objectives Generate Rays The sample takes you up to the point where you need to compute the rays to intersect with the scene.  Use the camera definition to build the rays you need to cast into the scene.  You should have a default background for when rays do not intersect objects, and this should not be a solid colour.  Choose some pleasing background colour based on your ray direction or pixel coordinate. Sphere Intersection (2 marks) The simplest scene includes a single sphere at the origin.  Write the code to perform the sphere intersection and set the colour to be either black or white depending on the result (i.e., don't worry about lighting in this first step).  Implement an additional position attribute for the sphere tag so that you can create a scene with several spheres at different positions without using the transformation tags (see step 7).  For instance, <sphere radius="0.5" position="0 0 0" material="red"/>. Lighting and Shading (2 marks) Modify your code so that you're always keeping track of the closest intersection, and the material, and the normal.  Use this information to compute the colour of each pixel by summing the contribution of each of the lights in the xml file.  You should implement ambient, diffuse Lambertian, and Blinn-Phong specular illumination models as discussed in class. Shadows Modify your lighting code to compute a shadow ray, and test that the light is not occluded before applying computing and adding the light contribution in the previous step.  Make sure your shadows work with multiple lights. Cube Add code to create an intersectable Cube object.  The cube should be axis aligned, centered at the origin, and with edges of length specified in the XML file, i.e., <cube size="1" material="red">. You may alternatively consider providing in XML the lower left and upper right corner of an axis aligned rectangular solid. Triangle Meshes The provided code includes the polygon soup loader from the previous assignment.  You can use this loader, or extend it, or write something new to load the obj file specified in the mesh XML nodes. Note that you do not have vertex normals by default, so flat shaded triangles are fine (though Phong shading would be nice). Hierarchy and Instances Use the transformations defined in the scene nodes to transform the rays before intersecting the geometry and child nodes.  Be sure to also transform the normals of the intersection result that you return to the caller.  Implement the instance tag to reuse named subtrees of the hierarchy.  Do something reasonable with the material definition of an instance (i.e., replace the material of the intersection, or modulate the colours). Create a Novel Scene Create a unique scene of your own.  Be creative.  Try to have some amount of complexity to make it interesting (i.e., different shapes and different materials).  Your scene should demonstrate all features of your ray tracer.  Note that there will be a separate submission for the ray tracing competition later in the term. Bonus (10%) Implement some extra feature (or features) in your ray tracer, and make sure that it is something of some minimum difficulty if you want to receive full bonus marks.  Here is a list of thing you might consider, but note that the items have been adjusted from the original posting of this assignment to account for the new requirements of the combined fourth and fifth assignments Adaptive per pixel jittered super sampling Fresnel Reflection Refraction and Fresnel term Motion blur Depth of field blur Spot lights Area lights (i.e.,soft shadows) Procedural volume textures Environment maps Textured mapped meshes (adaptive sampling or even mipmaps would be useful here) Bump maps transparency and compositing Acceleration techniques (hierarchical bounding volumes, parallelization). Quadrics Other implicit surfaces (e.g., metaballs) Subdivision surfaces Bezier surface patches Constructive Solid Geometry Something else totally awesome Final Submission Format (read carefully) You should create and submit a document (either a web page, pdf, or odt file), and submit this along with your assignment submission. This page should contains images that clearly demonstrate each requirement of the assignment, along with a demonstration of each of the extra features you implemented.  If you submit a web page, you should submit the files, and not just the link!  If you submit a document, the rendered images should be provided as png files with appropriate names. While you could probably create one image to show all of your features at once, it is suggested that you take some time to create a variety of nice test scenes and render several images.  You will probably want to use simple test scenes at each stage of the assignment for your own debugging purposes, so keep these scenes and the results for your submission web page.  Ideally, images should be plain and simple to demonstrate individual features.  Other images could be more complex to demonstrate a creative use of your software to generate interesting images. Each image in your submitted document  must  include a caption that gives the name of the xml scene file you used to generate the image, the computation time to generate the image, a list of features demonstrated in the image, and any additional comments.  You may also want to list your hardware and operating system in the document to help give meaning to the timings for each image.  Note that the images should be rendered at a reasonable size, for instance, 640x480 is sufficient for showing many of the features, but you may optionally want to compute higher resolution images for your final scene, but do not go higher than 1920x1200. Note that the TA will also be running your code, but will not have the time to render all your tests, so a large part of the evaluation of your assignment will be by inspection of images in the submitted documents.  Submitting an image that was not generated by your code is considered cheating.  Your raytracer may take a long time to generate any given image, thus the TAs will only selectively run specific examples, and it is largely on your honor that the images you show are yours (do not violate this trust).docContentEnd
17docContentStartCOMP 557 - Fall 2010 - Assignment 1 Transform Hierarchy for Character Posing Due 12:00 noon Monday 27 September Getting Started Download the   provided code from WebCT and dump it into a new java project. Follow the instructions in assignment zero for setting up your environment. Note that the provided code contains a jar called  mintools . We will be using more of these helper classes in subsequent assignments, but for now, we are only using the TrackBallCamera  class.  The provided code attaches an instance of this class to the glCanvas so that mouse events can be used to alter the 3D view.  Using the left mouse button you can rotate the object, using the middle button you can pan the object in the viewing plane, and using the right mouse button you can move the camera further or closer. Start early!  This assignment is not supposed to be hard, or time consuming, yet it is possible to get caught up on various details. Objectives The purpose of this assignment is to use a hierarchy of transformations to draw and animate a character.  You can use a variety of objects to build your character.  Using glut to draw spheres, cubes, cones, cylinders, and the occasional teapot will be easiest.  If you also want to draw triangles and quadrilaterals, you will need to specify their surface normal for lighting to work. The file A1App.java contains the necessary source code to create an OpenGL renderer in a windowed frame.  A reasonable camera position and projection matrix is set up for you (see the use of the TrackBallCamera  instance in the display method).  The code also contains  TODO  comments in the places where you will need to add code to complete the assignment objectives that are given below. Each objective is worth one mark, unless otherwise noted. Create Scene Graph Nodes Finish writing the scene graph node class called BodyNode .  The node should have a display method to draw the contents of the node and all its children (which are also  BodyNode s).  In each node, you may want to store: position with respect to its parent; rotation axis for the joint connecting this node to its parent; current rotation angle; a list of children (possibly the empty list); colour, i.e., material properties of the geometry of this node; position, scale, orientation, and geometry information for this node. Note that as described in the list above, the rotation axis for the joint, and the position of the node with respect to its parent, describe a rigid transformation.  The transformation describes the local coordinate frame in which the geometry of this node and its children are drawn.  In the last bullet item, you can consider the position, scale, and orientation as additional modeling transforms to help you to place your desired canonical glut primitives (sphere, torus, cube, etc.). This is similar to how we saw the scene graph organized in class, except that we are mixing many transforms, material properties, and geometry in each node.  The idea here is to simplify things slightly, but feel free to modify this as you see fit (be careful that your modifications work nicely with the rest of the objectives of the assignment).  For instance, you may find it conceptually cleaner to keep the geometry in a separate type of node (i.e., create another class, such as a GeometryNode , to store the bottom two bullet items in the above list). Create and Animate a Chain (two marks) Write code such that when the 'C' key is pressed, a chain is created.  The chain should be a reasonable length (e.g., 5 to 10 links), where each link is a torus.  Choose your glutSolidTorus parameters so that you get something that resembles a chain link, and such that your chain is an appropriate size to be seen on the screen (i.e., without need of using the mouse to moving the camera from the default position).  Each link should be rotated 90 degrees from its parent, and placed such that it appears to be hanging from its parent (see the screen shot at right). Each link should rotate as if it is sliding at the point of contact of its parent.  You have two options, and can do either (or both, though doing both is obviously hardest). The easier option is to use the axis of rotation that goes through the center of the torus; this will produce a rotation which is only visible via the motion of its children (i.e., the torus will be rotating in place).  The other option is to apply a rotation with an rotation axis on, and tangent to, the  medial axis  of the torus (i.e., at the point at center of the tube above the point of contact, and tangent to the circle at the center of the tube); this rotation will be visible both at the children and the torus itself.  Note that the third axis (the overall direction of the chain) is not a good choice for rotations in the chain because twists along the chain direction quickly result in interpenetration. Use the space bar to toggle the animation mode.  The provided code has an animation mode that sets all the angles to a sinusoid based on the current time to test your chain. It should appear to be swinging. Create a Character (two marks) Create an articulated character when the user presses the  'D' key.  You can choose to make anything you like (e.g., animal, human, robot), but it should have at least two legs, two arms, and a head.  In all you should have about 20 degrees of freedom in your character. You will likely find it useful to first make a sketch of your character to figure out how each of its body parts are connected to one another and where.  Note that you will also need to choose a reasonable root node for the character, such as the torso.  Write code to create the various body parts, and link them together by adding each child to the appropriate parent.  Be sure to also add all your nodes to the nodeList !  Note that you will want to avoid making a DAG so that all limbs of your character can be animated separately. Some joints should have a single degree of freedom (as shown in the picture above left), such as knees and elbows, while you should also have other joints which have multiple degrees of freedom (e.g., hips, shoulders, neck).  You can create your multi-DOF joints any way you like, but it should work with the posing and animation controls in subsequent steps.  One easy way to achieve a spherical joint would be to create three nodes all at the same location with different rotation axes.  Two of the three nodes need not have any geometry associated with them, i.e., you would have two "invisible" nodes at the anchor position of the ball in socket joint show in the picture above right. Posing Controls and Setting Key Frames The provided code contains a primitive means of changing the pose of your character.  The provided code uses the left and right arrow keys to walk through the  nodeList , and then use up down arrows to adjust the angle by small increments (perhaps a few degrees). You may find it useful to try to find a way to modify the code so that the currently selected node is drawn in a different style or colour. Add code to save the current pose when you press 'K'.  Save the pose into the existing list of "key poses".  Code already exists to erase, load and save your key poses using keys 'E', 'L', and 'S'.  Any code you add should work with the provided code, or you should fix it so that it works with your implementation. Note that using OpenGL picking to select which body part you want to pose would be a great way to simplify the task of character posing.  This is beyond the scope of this assignment, but can be implemented for a 5% bonus! Key Frame Animation Create a simple key-frame animation.  Plan ahead!  The key pose editing functions are very limited (i.e., there is no undo, redo, insert, replace, delete, etc.).  Try to make a reasonable walk cycle using at least four key poses.  Save the animation and submit the resulting  keyposes.javabin  file with your code.  Consider adding additional keyboard controls to increase or decrease the speed of the keyframe animation (currently the time between keyframes is half a second). Readme File (two marks) Create a  readme.txt  or  readme.pdf  file to submit with your assignment.  The readme should include any comments you have with respect to the assignment, and describes anything you deem to be noteworthy.  Try to be brief!  Your readme should also contain written answers to the following questions: Is setting the joint angles individually always a good interface for setting key poses?  What do you think would be a useful alternative?  Try to think of at least one alternative, but list several if you can. For the following pairs of transformation types, do they commute  always ,  sometimes , or  never ? Always means always, while never means only if one or both are the identity transformation.  Sometimes means that the transforms do not commute in general, however, there are situations where two transforms will commute.  If your answer is sometimes, then describe, as concisely and as generally as possible the situation where commutability will occur. Rotation and Scale in 2D Rotation and Scale in 3D Rotation and Rotation in 2D Rotation and Rotation in 3D Translation and Rotation in 3D Translation and Scale in 3D Finished? Great!  Be sure your name and student number is in the window title, in your readme, and in the top comments section of each of your source files. Submit your source code and written answers in the readme file as a  zip  archive via  WebCT .   DOUBLE CHECK your submitted files by downloading them from WebCT.  You cannot receive any marks for assignments with missing or corrupt files!! Note that you are encouraged to discuss assignments with your classmates, but not to the point of sharing code and answers. All code and written answers must be your own.docContentEnd
18docContentStartCOMP 557 - Fall 2010 - Assignment 2 Perspective Projection Frustums, Depth of Field, and Anaglyphs Due 12:00 Noon Wednesday 13 October Getting Started In this assignment you will use projection frustums to draw a scene with blur due to depth of field, and to draw anaglyphs that allow for 3D viewing with inexpensive colour filter glasses. Provided Code Download the sample code from WebCT.  It is a working program that will display a small test scene (you can change the scene if you like).  You will need to add the jogl, vecmath, and mintools jars to your project.  The sample code zip file contains only one class. The sample code has several drawing modes which you change by entering numbers 1 through 7.  They are as follows: The world view (default) where you can use the trackball to see the scene, the location of your frustums (as shown top right of this assignment). The view from the eye that lies on the z axis. The blurred depth of field view from the eye that lies on the z axis. The view from the left eye. The view from the right eye. An anaglyph showing both left and right eyes in the same image. The combination of a depth of field blur for each eye show as an anaglyph. The first mode is the only mode that exists in the sample code.  You need to implement the others in the steps and objectives listed below.  To help with testing your assignment at the different steps, you will be using  Parameters  for various values, such as the eye position, and the near and far planes (and many values). You should notice that the provided code already uses the DoubleParameter  class from the mintools jar.  It creates a window with controls for each of the parameters.  When you call the getValue method of a given parameter, you get the current value which is set in the interface.  You will also find IntParameter useful for setting the number of samples in your rendering of blur, BooleanParameter will be useful for enabling or disabling drawing of viewing frustums.  See the comments in the provided code.docContentEnd
19docContentStartCOMP 557 - Fall 2009 - Assignment 0 Getting Started with OpenGL in Java This is not a real assignment, but instead is intended as means to help you get set up for doing the assignments and the beginning of term OpenGL tutorials. The lab machines already have the necessary software installed, but if you are using your own machine then you may need to install some software. Java and Eclipse Software If you are not already using Sun/Oracle Java, or have a very old installation, then download and install the latest  Java SE JDK  (careful not to select the JRE).  Note that you may already have "other" Java versions installed on your machine (for instance, Microsoft or GNU Java), but avoid using these as they will very likely lead to problems. I also strongly recommend using  Eclipse as a development environment. If you need to install it, then I suggest downloading the Eclipse IDE for Java Developers . If you have multiple versions of java installed, you'll also want to make sure that you are using the appropriate JDK (see Window->Preferences, Java, Installed JREs) and have the compiler compliance level is set to 1.6 (see Window->Preferences, Java, Compiler). If you are familiar with Eclipse, you can probably skip the rest of this section. Using Eclipse Eclipse uses a workspace to organize your projects. When you start eclipse for the first time, it will make you a workspace in some default location (probably your home directory), but you can switch workspaces with the file menu, and open any folder you want for your workspace. One nice way to organize this would be to create a workspaceComp557 folder in your home directory, then tell eclipse to open that workspace. Once your workspace is open, add a new java project, give it a name, such as A0. The defaults for the project when you click next are probably fine, e.g., default JRE, separate folders for source and class files. Once it is created, you will see a src folder for the source files and bin for the class files (note that you may eventually create additional folders for data). Lastly a few tips on using eclipse when you're browsing the code. If you let your mouse hover over an identifier, variable or method, a window will pop up telling you what it is, and providing you with the javadoc. If you hold ctrl and click on an identifier, it will take you to its definition (e.g., the implementation of a method). This is a great way to explore code rapidly! Note the yellow forward and back buttons on the tool bar are useful for going back to where you were after control clicking an identifier. Provided Code Download the  provided code and dump it into a new java project. Note that the code lives in the  comp557.a0 package. Please do not change the package name for any of your assignments.  This example code contains a minimal example framework with which you can try out the OpenGL API, and may be of use during the tutorials. You'll want to put the provided code (see below) in src folder of your new project, and there are lots of ways to do this. Most importantly, you need the directory structure to match the package structure! An easy way is to copy the directory provided in the zip file and paste it into the src directory. Since everything lives in the package  comp557 you need this folder (i.e., you can't just copy and paste the  a0  folder into src). If you copy files into your project on the file system side, you'll need to tell Eclipse to refresh its view of the project (right click on the project and select refresh). This summarizes the steps for "dumping the source code into a project". You'll have lots of errors at this point, but they all go away when you attach the jars as specified in the assignment. Libraries The provided code uses  JOGL  for OpenGL bindings. JOGL  has been around for many years and has changed over the years to keep up to date with the evolving OpenGL specification.  The latest version involves "profiles" to allow for applications to be developed for different versions of OpenGL and different hardware (e.g., OpenGL ES 2.0, as you would use for an Android or iOS device).  We will use the previous version to avoid profiles, and also because builds of the libraries are available for a large variety of platforms at  jogl.dev.java.net . Go to the release build page  JSR-231 1.1.1a  and download the appropriate files for your platform. For instance, if on windows, download jogl-1.1.1a-windows-i586.zip jogl-1.1.1a-src.zip (to have access to javadoc in Eclipse) jogl-1.1.1a-docs.zip (if you prefer reading javadoc in your browser) To make your life more pleasant in Eclipse, you want to attach the source code to the jar for the javadoc. First add the jar to your build path, then open up Reference Libraries in your project, right click on the jar to set properties, go to source code attachment, and tell it where to find the zip file. Note that the .dll (or .so) that comes with the jar must be in your path. You can do this by opening the reference libraries in your project, right clicking to select properties, choose Native Library and enter the location of the .dll or .so file.  You can also do this by adding the folder containing the shared library to your path. To complete most assignments you will likely need to use the  vecmath  jar for working with matrices, points, and vectors. The  vecmath  package is available as part of JAVA3D, but instead of installing the full Java3D, you can download just the  vecmath.jar locally. The source code (i.e., the javadoc) is in the jar, so if it isn't automatically attached, you'll want to repeat the process above and attach the jar as source. You might also want to browse the  vecmath javadoc online . You may find the following links useful for documentation on OpenGL:  The OpenGL Programming Guide (The Red Book) online version  ( or at Amazon ), Jumping into JOGL ,  JOGL: A Beginner's Guide and Tutorial . Another popular resource is  nehe.gamedev.net (see the NeHeGL JOGL link on the bottom right). WebCT and Submitting Assignments You do not need to submit anything for assignment zero. However, if you are new to WebCT, you may wish to test the submission process, and as such there is a test assignment called A0 on WebCT.  Note that you should always check that the system has correctly received your uploaded files by downloading your submission and verifying its contents! You can always "take back your work" before the deadline and resubmit.  Once the deadline has passed, you'll not be able to do this.  Late  assignment submissions are permitted, but can only be made if you have not previously submitted an assignment.  If ever you have problems submitting your work, contact the instructor or one of the TAs.docContentEnd
20docContentStartCOMP 557 - Fall 2009 - Assignment 3 Subdivision Surfaces Due 23:59 pm Monday 2 November Getting Started In this assignment you will build half edge data structures from polygon soups, and subdivide meshes using the Loop subdivision scheme.  The polygon soup loader has been written for you and is very minimal.  It will load the vertex and face data from an 'obj' file (though these files can also contain lots of other information too).  We have also provided you with a number of sample meshes that will be useful for testing your program. Provided Code The  sample code  is a working program that will load one of the sample polygon soups and draws it.  You will need to add the jogl, vecmath, and mintools jars to your project. The sample code zip file has the following contents. A3App The main application loads a polygon soup, will make calls to build a half edge data structure and will try to subdivide it. Display call Will display the coarse polygon mesh by default, and also displays a half edge of the coarsest half edge data structure. You can use the keyboard interface to walk the half edge data structure.  Press space to go to the twin and N for the next half edge.  Left and Right arrows will take you to first and second child (if they exist), while up arrow will take you to the parent (if it exists).  Home and end keys can be used to change the subdivision level currently displayed, while page up and page down will allow you to go forwards and backwards in the model list (the model is loaded and subdivided each time). PolygonSoup Contains a vertexList and a faceList, and code to load these from an obj file.  There is also some simple drawing code used by the A3App class to draw the loaded soup. HalfEdge The half edge class is simple, and provided for you.  It has 6 pointers (next, head, twin, child1, child2, parent), and a method for drawing a half edge to help you verify that your program is working. Vertex The vertex class is simply a container to hold the position of the vertex, the normal (if it has been computed), and a pointer to its subdivision child (if it exists). HEDS  (you need to finish this class) HEDS is the Half Edge Data Structure, and simply contains a list of faces (where each face is implicitly specified by a half edge). You will need to implement the constructor which builds the structure given a polygon soup Loop  (you need to finish this class) This class has one method called subdivide which takes a half edge data structure and returns the half edge data structure for the subdivided mesh.  You will need to implement this method, and will likely want to create several private static helper methods to complete the objectives described below.docContentEnd
21docContentStartCOMP 557 - Fall 2009 - Assignment 4 (now combined with A5) Ray Tracing Milestone Due 23:59 pm Monday 16 November Complete Assignment Due 23:59 pm Monday 30 November New Details (November 13) This assignment has been combined with assignment 5 and it will be worth double a normal assignment, that is, 16% of the final grade.  Rather than giving an extension you must still make a submission of a milestone for the original deadline, with the complete assignment to be submitted by the end of Monday November 30. The Milestone requirement is that you must have completed the first 3 steps of the   original   assignment.  There will be a penalty of 20% for milestones which are incomplete or not submitted. Submit the following three things: a snapshot of your code  along with a  scene  xml file and resulting image  which demonstrates the requirement. The  new  requirements for the complete assignment is that you must implement the following extensions: Jittered Super Sampling This need not be adaptive, but you should consider each of jittering and super sampling separately by adding additional tags to your scene file to enable or disable them independently. For super sampling, you will want to sample the image at regular locations within each pixel, as if you were building an image at twice the resolution (or some other resolution).  But you should also observe how some high frequency aliasing problems can still exist. Observe how adding a small random perturbation to the direction of each ray fixes the aliasing problem.  The amount of random perturbation should be configured in your xml scene file. Note that you naturally have high frequency details in your scenes, such as edges.  Likewise if you implement textures (optional) then the aliasing problems should be even more evident. You should also try putting high frequency details in your background colour computation as an easy test, for instance, choosing a colour modulated by cos(k*(x^2+y^2)) would give low frequency when looking down the negative z axis, but will have higher frequency as you cast rays away from this axis (adjust k so you can observe the aliasing effect).  Again, you might want to make this an option so that you are not stuck with the same background in all your test images! Simple Acceleration for Meshes Compute an axis aligned bounding box for each mesh in your scene. Test first ray intersection with the box before testing all triangles in the mesh.  Make sure that you can turn on or off your acceleration method.  Measure the improvement for your sample scene and report on the improvement in your readme and on your submitted web page (see below). Area Lights and Soft Shadows Define a new tag for an area light where you specify its position and shape as a quadrilateral in world coordinates.  Cast several shadow rays to random positions on the area to compute a weighted lighting computation.  Note that the number of rays you cast should be configurable in the lamp definition, but you could optionally optimize the number of rays you cast depending on the distance between the light and the surface being lit. Note that the bonus items listed below have been adjusted slightly, and you can still implement extra features for extra credit. Final Submission Format You should create and submit a web page (that is the files, not just a link!) along with your assignment submission which contains images that demonstrate each requirement of the assignment, along with demonstrating the extra features you implemented. While you could probably create one image to show all of your features at once, it is suggested that you take some time to create a variety of nice test scenes and render several images. Some images should be plain and simple to demonstrate individual features. Other images should be more complex and demonstrate a creative use of your software to generate interesting images. Each image on your submitted web page should include a caption that gives the name of the xml scene file you used to generate the image, the computation time to generate the image, a list of features demonstrated in the image, and any additional comments. You may also want to list your hardware and operating system to help give meaning to the timings for each image.  Note that the images should be a reasonable size, for instance, 640x480 is sufficient for showing many of the features, but you may optionally want to compute higher resolution images for your final scene, but do not go higher than 1920x1200. Note that we may also run your code, but largely evaluation of your assignment will be done by inspecting the web page and your submitted code.  Submitting an image that was not generated by your code is considered cheating. Because raytracers may take a long time to generate a given image the TAs may only selectively run specific examples, and it is largely on your honor that the images you show are yours (do not violate this trust). Optional Competition There will be optional competition for images created with your raytracer. You do not submit an image if you do not want to participate. To participate, you should submit a representative image, and a short description describing the technical achievements and or artist statement for your submission.  Submit the image and statement to the competition assignment box by the end of Monday 30 November. A small jury will judge submissions based on aesthetics, creativity, and technical merit.  Winners will be announced in class on Tuesday 1 December. Getting Started In this assignment, you will write a raytracer.  Note that there is no written part to this assignment. The  sample code  will get you started with an XML scene file parser and code to write PPM image file.  The XML scene format is very very loosely based off of the Yafaray format, but is simplified and modified for the purpose of this assignment.  You are free to make additional modifications and extensions as you please to both the XML format and the code, but your code should still work with the simple examples provided, and likewise, any changes you make must be well documented in your readme file. XML scene description The XML file is organized as sequence of named materials, lights, cameras, nodes, and renders.  The main scene is defined in the node with the name "root".  In general you will only need to have one node defined, and it must have the name "root", but nodes can also be referred to within the scene graph hierarchy as an instance (i.e., to help you reuse parts of the scene hierarchy multiple times). The scene nodes each have an associated transformation.  The node definition can contains a list of transformations (translation, rotx, roty, rotz, and scale (and others if you choose to add them)). These transformations are applied in order to build the node transformation.  The node can also list a number of different kinds of geometry (sphere, cube, mesh, instance).  Finally, the node can also contain a list of child nodes, allowing a hierarchy of transformations and geometry to be built. Look at the two examples provided to get a better idea of how the scene description files are organized.  Please share your test scenes on WebCT.  Note that you may also implement additional tags and attributes as you proceed through the objectives, so this may complicate sharing. Provided Code A4App opens an xml document and calls the Scene constructor to load the scene definition from the xml file.  It then calls the scene render method to produce an image file.  This render method is a good place to start making changes to the code, but you will need to make lots of changes to many classes, and make new classes on your own.  You've been provided with basic classes for defining a materials, lights, and nodes, but they do nothing but hold loaded data.  A Ray class and an intersection result have been defined for your convenience, but you may wish to change them.  They are defined to allow the Intersectable interface to be defined.  The sphere, cube, plane, mesh, or any other geometry (or node) that can be intersected will implement this interface. Steps and Objectives Generate Rays The sample takes you up to the point where you need to compute the rays to intersect with the scene.  Use the camera definition to build the rays you need to cast into the scene.  You should have a default background for when rays do not intersect objects, and this should not be a solid colour.  Choose some pleasing background colour based on your ray direction or pixel coordinate. Sphere Intersection The simplest scene includes a single sphere at the origin.  Write the code to perform the sphere intersection and set the colour to be either black or white depending on the result (i.e., don't worry about lighting in this first step).  Implement an additional position attribute for the sphere tag so that you can create a scene with several spheres at different positions without using the transformation tags (see step 7).  For instance, <sphere radius="0.5" position="0 0 0" material="red"/>. Lighting Modify your code so that you're always keeping track of the closest intersection, and the material, and the normal.  Use this information to compute the colour of each pixel by summing the contribution of each of the lights in the xml file. Shadows Modify your lighting code to compute a shadow ray, and test that the light is not occluded before applying computing and adding the light contribution in the previous step. Cube Add code to create an intersectable Cube object.  The cube should be axis aligned, centered at the origin, and with edges of length specified in the XML file, i.e., <cube size="1" material="red">. Triangle Meshes The provided code include the polygon soup loader from the previous assignment.  You can use this loader, or extend it, or write something new to load the obj file specified in the mesh XML nodes. Note that you do not have vertex normals by default, so flat shaded triangles are fine (though Phong shading would be nice). Hierarchy and Instances Use the transformations defined in the scene nodes to transform the rays before intersecting the geometry and child nodes.  Be sure to also transform the normals of the intersection result that you return to the caller.  Implement the instance tag to reuse named subtrees of the hierarchy.  Do something reasonable with the material definition of an instance (i.e., replace the material of the intersection, or modulate the colours). Create a Novel Scene Create a unique scene of your own.  Be creative.  Try to have some amount of complexity to make it interesting (i.e., different shapes and different materials).  Your scene should demonstrate all features of your ray tracer.  Note that there will be a separate submission for the ray tracing competition later in the term. Bonus Implement some extra feature (or features) in your ray tracer, and make sure that it is something of some minimum difficulty if you want to receive full bonus marks.  Here is a list of thing you might consider, but note that the items have been adjusted from the original posting of this assignment to account for the new requirements of the combined fourth and fifth assignments Adaptive per pixel jittered super sampling Fresnel Reflection Refraction and Fresnel term Motion blur Depth of field, or real lenses Spot lights Procedural volume textures Environment maps Textured mapped meshes (adaptive sampling or even mipmaps would be useful here) Bump maps transparency and compositing Programmable shading Acceleration techniques (hierarchical bounding volumes, parallelization). Quadrics Other implicit surfaces (e.g., metaballs) Subdivision surfaces Bezier surfaces Constructive Solid Geometry Something awesome Be sure to document your extra feature or features in your readme! Finished? Great!  Be sure your name and student number is in the window title, and in the comments of the code.  Submit your source code as a zip file via  webCT . Include a readme.txt file with your comments.  DOUBLE CHECK your submitted files by downloading them from WebCT.  You can not recieve any marks for assignments with missing or corrupt files! Note that you are encouraged to discuss assignments with your classmates, but not to the point of sharing code and answers. All code must be your own.docContentEnd
22docContentStartCOMP 557 - Fall 2009 - Assignment 1 Getting Started with OpenGL Due 23:39 pm Monday 21 September Getting Started Since this is the first assignment, you'll need to spend a little bit of time to get set up.  If you are not already using Java then download and install the latest  Java SE JDK  (careful not to select the JRE).  I also recommend using  Eclipse  as a development environment.  If you do use Eclipse as a development environment, make sure that the compiler compliance level is set to 1.6 (Project->Properties->Java Compiler). Download the  provided code  and dump it into a new java project.  Note that the code lives in the comp557a1  package, so when you create your project you'll want to create the comp557a1  package in your src folder before copying the file. Please do not change the package name, and likewise, add all your code to this one file (this assignment is small, so it should not be too messy living all in one file). The code uses  JOGL  for OpenGL bindings JOGL  is available at  https://jogl.dev.java.net/ . Click on current release build (JSR-231 1.1.1a) and download the appropriate files for your platform.  If on windows, download jogl-1.1.1a-windows-i586.zip jogl-1.1.1a-src.zip (to have access to javadoc in Eclipse) jogl-1.1.1a-docs.zip (if you prefer reading javadoc in your browser) To make your life more pleasant in Eclipse, you want to attach the source code to the jar for the javadoc.  First add the jar to your build path, then open up Reference Libraries in your project, right click on the jar to set properties, go to source code attachment, and tell it where to find the zip file.  Note that the .dll (or .so) that comes with the jar must be in your path.  You can do this by opening the reference libraries in your project, right clicking to select properties, choose Native Library and enter the location of the .dll or .so file. To complete this assignment you will likely want to use the vecmath  jar for working with matrices, points, and vectors. The  vecmath  package is available as part of JAVA3D, but instead of installing the full Java3D, you can download just the  vecmath.jar locally.  The source code (i.e., the javadoc) is in the jar, so if it isn't automatically attached, you'll want to repeat the process above and attach the jar as source. You might also want to browse the  vecmath javadoc online . You may find the following links useful for documentation on OpenGL:  The OpenGL Programming Guide (The Red Book) online version  ( or at Amazon ), Jumping into JOGL ,  JOGL: A Beginner's Guide and Tutorial .  Another popular resource is  nehe.gamedev.net  (see the NeHeGL JOGL link on the bottom right). Objectives The purpose of this assignment is to explore object space and world space rotations.  The completed assignment will let you apply small incremental x, y, and z rotations to a wire frame cube. The provided source code should help you get started quickly. The file A1App.java contains the necessary source code to create an OpenGL renderer in a windowed frame.  The a reasonable camera position and projection matrix is set up for you (see the display method).  The code also contains TODO comments in the places where you will need to add code to complete the assignment objectives that are given below. Write code to draw the world axis using three unit length lines starting at origin along the X Y and Z axis directions.  The color of the X axis should be red, the Y axis should be green and the Z axis should be blue. Write code to draw a cube with edge length 2 using the function glut.glutWireCube(1). Create a transformation matrix (i.e., vecmath Matrix4d), to map points in your cube object coordinates to world coordinates. Be sure to initially set your matrix to the identity, then use it when you draw your cube by changing the modelview matrix before drawing.  Note that you'll need to repackage the contents of the vecmath Matrix4d into a double[] or DoubleBuffer before passing it to OpenGL, so be careful of the order in which you specify matrix entries. Draw a second axis in the cube's coordinates.  Note that they will intitailly be aligned. The private variables "axisRotate", and "leftMultiplicationMode" are provided to let you control how to rotate the cube. These variables need to be updated given the following keyboard input: Arrow Up: apply a small positive rotation about the current axis. Arrow Down: apply a negative rotation about the current axis. X: Set the default rotation axis to the 'X' axis Y: Set the default rotation axis to the 'Y' axis Z: Set the default rotation axis to the 'Z' axis Space: toggle the left/right matrix multiplication mode. R: Reset the accumulated transformation to the identity. Choose a small reasonable value for the angle update, for instance something between 1 and 5 degrees.  The rotation should be accumulated.  Note that M.mul(M,Rx) is generally safe with vecmath as it checks to see if you're passing the object itself as one of the arguments.  Be sure to use the repaint method to request a redraw of the canvas after each keypress. Optional step: implement code to select between translation, scale, and rotation modes using they keyboard.  Use 1 to select rotation, 2 to select scale, and 3 to select translation.  Be sure to choose reasonable values for each type of transformation.  Change the glutBitmapString call to also provide status of the current transformation mode.  Explore how different combinations change the shape of the cube and the object coordinate frame. Written questions: Your written answers should be submitted as ASCII, pdf, or high quality jpg file (i.e., a scan or a photo of legible written work).  Be sure to include your name and student number with your written questions. Which 3D transformations commute with themselves and with each other, that is, given two transformations A and B, when is AB = BA?  Consider the following transformations: identity, translation, nonzero uniform scale, nonzero non-uniform scale, rotation, shear. Build a table or grid to show your answer, filling in only the lower triangle and diagonal. Show that a 90 degree 2D rotation can be created by composing a sequence of shears. Finished? Great!  Be sure your name and student number is in the window title, and in the comments of the code.  Submit your source code and written answers as a zip file via  webCT .  Include a readme.txt file with your comments.  DOUBLE CHECK your submitted files by downloading them from WebCT.  You can not recieve any marks for assignments with missing or corrupt files! Note that you are encouraged to discuss assignments with your classmates, but not to the point of sharing code and answers. All code and written answers must be your own.docContentEnd
23docContentStartCOMP 557 - Fall 2009 - Assignment 2 Bezier Surfaces Due 23:59 pm Friday 9 October Getting Started The purpose of this assignment is to evaluate Bezier surfaces and to draw smooth objects using OpenGL. The Bezier surfaces in this assignment are bicubic polynomials of order 3 in each parameter, thus each patch is defined by a 4 by 4 grid of control points.  Unlike a triangle mesh, a Bezier surface patch is smooth, differentiable, and its shape is entirely specified by its 16 control points.  However, to draw such a smooth surface in OpenGL we must approximate the smooth surface with small primitives (e.g., triangles or quads).  You will do this by evaluating the surface at regular intervals along the s and t directions, and drawing triangles or quads. Note that OpenGL can draw polynomial surfaces through the use of evaluators. In the assignment, we ask you not to use OpenGL evaluators, but rather to implement your own code to evaluate the surface and its derivatives given values of the parameters s and t. Provided Code The  sample code  runs, but does nothing but draw a world axis and calls a collection of methods in the BezierPatchWork class that you need to complete.  The sample code zip file has the following contents. A2App and BezierPatchwork java files, which need to be placed in a package called comp557a2, and you will need to add the jogl and vecmath jars to your project as per the previous assignment. mintools.jar, which also needs to added to your classpath as it provides a small framework used by the sample code. Three data files.  The file testPatch.txt contains one single flat Bezier patch.  The file testPatches.txt contains two Bezier patches.  The third contains Bezier patches defining the Utah teapot.  Change the constructor of A2App to run your application with different data files. The code (BezierPatchWork.java) contains TODO comments in the places where you will need to add code to complete the assignment objectives specified below.  The A2App code sets up the interface and adds a number of swing controls to a control window.  You will use these controls to turn on or off or adjust the display different things as specified in the objectives. mintools Framework Jar While it is easy enough to start writing code from scratch when building a new application, many small parts of code are always the same.  The mintools.jar provides classes that help set up an interactive application.  It takes care of clearing the screen, setting up lights, and provides a simple interface.  In particular, you can use the mouse to rotate and zoom the object: Left click and drag to rotate, middle click and drag to translate, right click and drag to zoom. Bezier Patch Data The teapot is composed of 32 Bezier patches, each with a 4 by 4 grid of control points for a total of 16 control points each. You will notice that the BezierPatchWork class already contains code for loading all this data into an array of Matrix4d objects.  Each matrix contains the 16 control points of a given patch for a given axis (x, y, or z).  For instance, Gx, the 4 by 4 matrix of x coordinates of control points of the first patch will be found in coordinatePatch[0][0], while the y coordinates are in coordinatePatch[0][1], and z in coordinatePatch[0][2].  This code is provided as a convenience to help you get started faster.  But if you feel strongly about storing your control points in some other manner then feel free to change it! Steps and Objectives Control Points The drawControlPoints(gl,patch) method of BezierPatchWork is currently unfinished.  Add code to draw the control points using GL_POINTS. Make the points large and red by setting the colour with glColor and the point size with glPointSize.  The "Display Control Points" checkbox in the controls window will let you enable drawing.  Make sure it is checked when you are testing your code (it is on by default). Surface The  draw(gl,patch)  method of BezierPatchWork is also unfinished.  Implement this method by drawing the specified patch as a mesh of quadrilaterals or triangles.  You should make numEvaluations.getValue()  evaluations at regular intervals along each parameter direction.  You can think of each interval as defining a small rectangular region of the surface, which you can draw as a quad or a pair of triangles. Note that you will probably want to write a number of additional methods to help you compute Bernstein basis weights.  Also note that the "Display Bezier Mesh" checkbox must be checked when you are testing your code (it is checked by default). Tangents Write code to compute the surface tangents (i.e., the derivatives in the s and t directions).  Write code in the drawSurfaceVectors method to draw the s and t derivitives as red and green lines at the surface point (s,t) provided in the parameters.  Note that the default state of the controls is not to call this method.  Use the s and t sliders in the controls window to check that your tangent vectors make sense. Normals Write code to compute surface normals using your code that computes tangent vectors.  Compute a normal for each surface point you evaluate in objective 2, and modify the patch drawing code so that the normal is sent to OpenGL.  Note that the normal must be set with glNormal before calling glVertex!  Use the lighting checkbox in the control window to turn on lighting to check your result. Repair Bad Normals Note that some surface points have bad normals, notably the top and bottom of the teapot.  Why is this happening?  Write some code to check for when this is happening, and use a nearby point of the surface to approximate the desired value of the bad normal.  Note that your "fix" need not work in all cases, but should work in the case of the teapot data. Surface Coordinate Axis Add more code to the drawSurfaceVectors method to compute a coordinate frame on the surface of the patch.  The local coodrinate system should have its x axis in the direction of the s tangent, the z axis in the direction of the normal, and the appropriate y axis to form a right handed coordinate system.  Use glMultMatrix to change to this coordinate system, and draw a wire cube with glutWireCube(0.1).  Be sure to use glPush and glPop so that you can restore the state of the modelview matrix when you have finished drawing the cube. Written Questions Shadow Projection A trick for drawing shadows is to project geometry onto a surface using the light position as the center of projection. Once the geometry is flattened in the shape of a shadow on the surface it can be drawn in a dark colour. Let the plane with normal N and going through point C be the surface, and let L be the position of the light.  Let P be a point to be projected onto the plane. The implicit equation of the plane (use N dot (X - C) = 0 as the equation of your plane).  Substitute the parametric equation of the line from the light to the given point P into the equation of the plane, and solve the parameter value which gives the point on the surface.  Give a simple expression for this parameter value. What is the position of the projected point (i.e., subsitute the solved parameter value into the line equation)? Your answer for the projected point involves a division, but instead write the answer in homogenous coordinates so that the conversion from homogeneous to non-homogenous coordinates will perform this division.  Keep your answer in terms of vectors and dot products! Bezier Hermite Basis Conversion The kth derivative at the end of a Bezier curve C(t) depends on the positions of the k+1 control points at that end.  Show this to be true for the 1st derivitive of a Bezier curve, and therefore demonstrate that C'(0) is parallel to P1 - P0 (and likewise, that C'(1) is parallel to the vector formed by the last two control points).  Use your answer to write the change of basis matrices that go from cubic Bezier to Hermite, and from Hermite to cubic Bezier. Finished? Great!  Be sure your name and student number is in the window title, and in the comments of the code.  Submit your source code as a zip file via  webCT . Include a readme.txt file with your comments.  Note that your written questions need to be submitted to a different assignment box!  DOUBLE CHECK BOTH of your submitted files by downloading them from WebCT.  You can not recieve any marks for assignments with missing or corrupt files! Note that you are encouraged to discuss assignments with your classmates, but not to the point of sharing code and answers. All code and written answers must be your own.docContentEnd
24docContentStartGetting Started with OpenGL in Java This page provide information useful for getting your workspace ready to work on computer graphics and computer animation assignments.  The lab machines already have the necessary software installed, but if you are using your own machine then you may need to install some software. Java and Eclipse Software If you are not already using Sun/Oracle Java, or have an older installation, then download and install the latest Java SE JDK  (careful not to select the JRE). Note that you may already have "other" Java versions installed on your machine (for instance, Microsoft or GNU Java), but avoid using these as they will very likely lead to problems. I also strongly recommend using  Eclipse as a development environment. If you need to install it, then I suggest downloading the Eclipse IDE for Java Developers  because it is slightly smaller. If you have multiple versions of java installed, you will want to make sure that you are using the appropriate JDK (see Window->Preferences, Java, Installed JREs) and have the compiler compliance level is set to at least 1.6 (see Window->Preferences, Java, Compiler). Using Eclipse Eclipse uses a workspace to organize your projects. When you start eclipse for the first time, it will make you a workspace in some default location (probably your home directory), but you can switch workspaces with the file menu, and open any folder you want for your workspace. One nice way to organize this would be to create a workspaceComp557 folder in your home directory, then tell eclipse to open that workspace. Once your workspace is open, add a new java project, give it a name, such as A0, A1, etc. The defaults for the project when you click next are probably fine, e.g., default JRE, separate folders for source and class files. Once it is created, you will see a src folder for the source files and bin for the class files.  Note that you may eventually create additional folders for data. Lastly a few tips on using eclipse to help you browse provided code. If you let your mouse hover over an identifier, variable or method, a window will pop up telling you what it is, and providing you with the javadoc. If you hold ctrl and click on an identifier, it will take you to its definition (e.g., the implementation of a method). This is a great way to explore code rapidly! Note the yellow forward and back buttons on the tool bar are useful for going back to where you were after control clicking an identifier. Provided Code Download the  provided code and dump it into a new java project. Note that the code lives in the  comp557.a0 package. Please do not change the package name for any of your assignments. This example code contains a minimal example framework with which you can try out the OpenGL API, and may be of use during the tutorials. You'll want to put the provided code (see below) in src folder of your new project, and there are lots of ways to do this. Most importantly, you need the directory structure to match the package structure! An easy way is to copy the directory provided in the zip file and paste it into the src directory. Since everything lives in the package  comp557 you need this folder (i.e., you can't just copy and paste the  a0  folder into src). If you copy files into your project on the file system side, you'll need to tell Eclipse to refresh its view of the project (right click on the project and select refresh). This summarizes the steps for "dumping the source code into a project". You'll have lots of errors at this point, but they all go away when you attach the jars as specified in the assignment. Libraries The provided code uses  JOGL  for OpenGL bindings. JOGL  has been around for many years and has changed over the years to keep up to date with the evolving OpenGL specification.  The latest version involves "profiles" to allow for applications to be developed for different versions of OpenGL and different hardware (e.g., OpenGL ES 2.0, as you would use for an Android or iOS device). Grab the latest release version from jogamp.org .  In version 2.0 of JOGL, installation has become slightly simpler with respect to the native libraries. See local installation information , and download the 7zip file. Unzip the archive somewhere convenient. You will want to include jogl-all.jar and gluegen-rt.jar in your build path, and likewise attach the provided source code for your own convenience (e.g., jogl-src.zip).  Because you will need to do this for each assignment, you will want to set this up as a user library. You may find the following links useful for documentation on OpenGL: The OpenGL Programming Guide (The Red Book) online version  ( or at Amazon ) JOGAMP JOGL Tutorial page JOGL User Library You will be using several jars in each assignment, and to save time in setting up dependancies it will be useful to create a user defined library that groups together the necessary jars.  Create a user library called JOGL2 and add to it jogl.all.jar and jlugen-rt.jar. You will want to set the source code attachment and native library location.  As we will also be regularly using vecmath.jar and mintools.jar you can add these too once they are provided. Right click on your project, select settings, and choose Java Build Path, and click on the Libraries tab.  When you click Add Library, select User Library and click next, choose User Libraries, and click New. Give it the name JOGL2.  Now add the jars to your library, set the source path, and if necessary native library paths. Once finished, you can select the user library you created for inclusion. JOGL2.0 Idiosyncrasies As mentioned previously, different profiles are available, e.g., GL2, GL3.  You will notice in the provided code that we are pretty much exclusively using GL2. OpenGL functions that have parameters that take pointers or arrays as argiments in C are mapped to Java an a way that facilitates code porting, but may look mysterious at first.  For instance, a glVertex call that accepts an array of doubles, in JOGL, has the method signature glVertex3dv(double[] v, int v_offset).  We typically provide 0 for the offset.  Alternatively we can use native IO buffers. DebugGL is your friend!  It will call glGetError for you and throw exceptions.  Notice how the provided code sets the GL2 to be a DebugGL2.docContentEnd
25docContentStartCOMP 764B - Computer Graphics and Animation Winter 2008 (Advanced Topics Systems 1) Last updated: 19 February 2008 Overview  -  Prerequisites  -  Objectives  -  Format  -  Evaluation  -  Project  -  Materials General Information Course Web Page www.cs.mcgill.ca/~kry/comp764b.html Lectures Mondays and Wednesdays  from 4:00 to 5:30  in ENGMC 320 Instructor Paul Kry Telephone 514 398 2577 Office MC113N Office Hours By appointment (any time!) NOTE: This is an initial course outline and it will change during the term.  Please refer to the latest version at the link above. Additional course materials (internal access only) Schedule Mon 7 Jan Introduction, course description, overview of topics. Wed 9 Jan Motion capture, technology, motion reuse and modification. Reading: Interaction Capture and Synthesis, P. G. Kry, D. K. Pai, SIGGRAPH 2006 Mon 14 Jan Review, ordinary differential equations and numerical integration Reading: Physically Based Modeling  ODE Basics, glance through particle systems or skip directly to implicit methods More Information: David Baraff and Andrew Witkin,  Large steps in cloth simulation , SIGGRAPH 1998 Computer Methods for Ordinary Differential Equations and Differential-Algebraic Equations, Uri M. Ascher and Linda R. Petzold, Chapter 3 Wed 16 Jan Review, constraints, constraint stabilization (Baumgarte, post stabilization), mathematical introduction to rigid body motion, (no time for solving linear systems, sparse systems) Reading: Physically Based Modeling  Constrained Dynamics, start looking at rigid body simulation More Information: A Mathematical Introduction to Robotic Manipulation, R. Murray, Z. Li, and S. Sastry, Chapter 2 Mon 21 Jan More rigid body motion, screws, brief look at solving linear systems. (no time was left for unilateral constraints, reduced physical models, e.g., Good Vibrations, DyRT). Suggested Reading: M. B. Cline and D. K. Pai,  Post-Stabilization for Rigid Body Simulation with Contact and Constraints , in proceedings of the IEEE Intl. Conf. on Robotics and Autom., 2003. [Describes both Baumgarte stabilization, and post-step stabilization] A. Pentland , J. Williams,  Good vibrations: model dynamics for graphics and animation , ACM SIGGRAPH Computer Graphics, v.23 n.3, p.207-214, July 1989 More Information: Physically-based modeling: past, present, and future , siggraph panel 1989 M.-J. Kim, M.-S. Kim, and S. Y. Shin,  A General Construction Scheme for Unit Quaternion Curves with Simple High Order Derivatives , SIGGRAPH 1995 Doug L. James and Dinesh K. Pai, DyRT:  Dynamic Response Textures for Real Time Deformation Simulation with Graphics Hardware ,  ACM Transactions on Graphics (ACM SIGGRAPH 2002) ,  21(3) , pp. 582-585, 2002. Wed 23 Jan Final summary of rigid body motion, dynamics. More Information: A Mathematical Introduction to Robotic Manipulation, R. Murray, Z. Li, and S. Sastry, Chapter 4 Note: (moved) Send paper suggestions and preference of order and dates to me in email by Jan 23 Mon 28 Jan Revisit missed topics from Monday 21, plus time permitting: collision detection and response, broad phase, narrow phase, OBB, AABB, spheres, collision response, we may also touch on optimization, data fitting, and approximation. Suggested Reading: Doug L. James and Dinesh K. Pai, BD-Tree:  Output-Sensitive Collision Detection for Reduced Deformable Models ,  ACM Transactions on Graphics ( ACM SIGGRAPH 2004) , 23(3), pp. 393-398, August 2004. Teschner et al.,  Collision Detection for Deformable Objects , Eurographics STAR 2004 [survey] More Information: Boyd and Vandenberghe,  Convex Optimization , [i.e., for Lagrangian and KKT conditions] Evangelos Kokkevis,  Practical Physics for Articulated Characters , GDC 2004 Game Physics  (book), David Eberly Wed 30 Jan Motion capture reuse and control.  BD-Tree discussion. Reading: Multiobjective Control with Frictional Contacts , Yeuhi Abe, Marco da Silva, Jovan Popović, Symposium on Computer Animation (SCA), 2007 Dynamic Response for Motion Capture Animation , Zordan, V. B., Majkowska, A., Chiu, B., Fast, M SIGGRAPH 2005 Mon 4 Feb Clarke, Inverse Rendering Reading: A Signal-Processing Framework for Inverse Rendering , Ravi Ramamoorthi, Pat Hanrahan, SIGGRAPH 2001 Wed 6 Feb Discussion of Dynamic Response for Motion Capture Animation (read for Jan 30), and Reading: Metoyer et al.,  Psychologically inspired anticipation and dynamic response for impacts to the head and upper body , IEEE TCVG 2008 Mon 11 Feb Reading: Near-optimal Character Animation with Continuous Control , Treuille, A. Lee, Y. Popović, Z. SIGGRAPH 2007 Learning Physics-based Motion Style with Inverse Optimization , K. Liu, A. Hertzmann, Z. Popović, SIGGRAPH 2005 Note: Tentative due date for final project proposal (survey paper as part of proposal if only one presentation) Wed 13 Feb Marta, Facial Animation Perception Mon 18 Feb More facial animation, physically based and data driven methods. Reference: Facial modeling and animation , SIGGRAPH 2004 course notes Wed 20 Feb Finish with facial animation: performance capture and resynthesis. Hands: modeling and animating techniques, grasping, control, planning, quality. Mon 25 Feb No class (Study break) Wed 27 Feb No class (Study break) Mon 3 Mar Real-time lighting and precomputed light transfer. Reference: Real-Time Ambient Occlusion for Dynamic Character Skins , A. G. Kirk, O. Arikan, I3D 2007 Wed 5 Mar Sammy, Instant Ray Tracing: The Bounding Interval Hierarchy Mon 10 Mar Tom, Capturing and animating skin deformation in human motion Wed 12 Mar Fahim, Wave Particles Mon 17 Mar Skinning: PSD, EigenSkin, MWE, Character Skins from Examples. Reading: EigenSkin: real time large deformation character skinning in hardware , Kry, James, Pai, SCA'02 Wed 19 Mar cancelled Mon 24 Mar No class (Easter Monday) Wed 26 Mar More Skinning: dual quaternions, skinning mesh animations. Reading: Skinning with Dual Quaternions , L. Kavan, S. Collins, J. Zara, C. O'Sullivan, I3D 2007 Mon 31 Mar Fahim, SPH fluid simulation Reading: Particle-Based Fluid Simulation for Interactive Applications , Matthias Müller, David Charypar and Markus Gross, SCA 2003 Wed 2 Apr Advanced motion capture analysis Reading: Exact Principal Geodesic Analysis for Data on SO(3) , Said, Courty, LeBihan, Sangwine, USIPCO 2007 Mon 7 Apr Reading: Animal Gaits From Video , Favreau, Reveret, Depraz, Cani, SCA 04 Wed 9 Apr Marta, motion exaggeration Reading: Martial arts in artificial reality , Hamalainen et al., SIGCHI 05 Tue 15 Apr Final project demos, meet at 5pm in MC110A Overview Recent advances in computer graphics and animation are permitting new levels of realism and interactivity with benefits to a variety of applications such as video games, movies, and training simulations. The goal of this course is to expose students to a sample of these new and advanced techniques and to help each student develop an understanding of the state of the art in computer animation research. The format of the course will be seminar style with in class student presentations and discussions of important and recent publications. Example topics may include motion capture processing, animating humans and animals, character skinning, acoustics, rigid body dynamics, deformable objects, collision detection and response, physically based methods, and more. The course will also involve a final project. Prerequisites This course is intended for graduate students in Computer Science or Electrical and Computer Engineering. It is also open to other students with permission of the instructor. Students taking this course will ideally have taken an introductory computer graphics course, and and have good knowledge of linear algebra, calculus, for working through papers. Strong programming skills will also be helpful in completing the course project. Objectives The objective of this course is to have students develop an understanding of the state of the art in computer graphics and animation. This will be achieved by reading, analyzing, and discussing the new ideas and advanced techniques presented in recent publications. At the end of the term, students will have a good idea of the current important challenges in computer animation research. Students may also be able to reuse general methods and techniques covered during the term in their own research. Finally, a general objective is for students to gain experience in reading and presenting research articles, which should be of benefit when they carry out their thesis research. Course Format and Evaluation The class will be taught in a seminar-style format. The first weeks be lectures presented by the instructor to review background material, but most classes will consist of student presentations and a group discussion.  You should find your own papers to read and present, but a summary of papers in different areas will be provided in class to help those who are looking for a place to start.   You will be expected to present one time during the term, and you will need to provide a list of a few papers that interest you for the second week of class. The selected papers will be grouped into different themes, and if there are overlaps you may be asked to choose an alternative paper. Presentations will be approximately 15 to 20 minutes in length. You are also expected to read the papers for each class, and must be ready to discuss ideas in the paper. Discussion will clarify questions such as the real contributions and impact of the paper,  the relationship does it has to other papers and current practices, the limitations of the method and how it could be improved, etc. In addition to the one presentation that is expected, you write a short survey on a area of interest to you.  Alternatively, you can present a second time as an alternative. There are three components to the grading scheme. 40% paper presentation / paper survey or 2nd presentation 20% class participation 40% final project Academic Integrity McGill University values academic integrity. Therefore, all students must understand the meaning and consequences of cheating, plagiarism and other academic offences under the Code of Student Conduct and Disciplinary Procedures.  See  www.mcgill.ca/integrity for more information, as well as  www.mcgill.ca/integrity/studentguide , the Student Guide to Avoid Plagiarism. Final project Each student will complete a final project of their choosing, either alone or in a group.  A project should be an implementation of the key parts of one one of the papers discussed in class. If possible, students should also try to incorporate something new or novel in their projects. This could be a small extension of a method, an analysis, an evaluation, or some additional feature. A brief one page proposal proposal will be submitted for approval. A final report along with source code, videos, images and any other relevant material will be due at the end of the term. The report should be brief but thorough and should highlight what you learned, what was easier than expected, what was harder, and what you wish you knew before starting. More details will be provided in class and on this web page later in the term. Course Materials All the articles and papers needed for readings and presentations in this course should be available online. Use Tim Rowley's site, Google scholar, Citeseer, the ACM digital library, or look for the paper directly on the web page of one of the authors. If you are using an Internet connection at home, you may need to use a  McGill library VPN  connection to access some resources. Tim Rowley's web page Physically Based Modeling Transactions on Graphics (TOG) and SIGGRAPH (issue 3) Symposium on Computer Animation McGill Catalogue ACM Digital Library IEEE Xplore Google Scholar Citeseer Note that videos of some SIGGRAPH presentations in recent years can be found online in the ACM Digital Library. Many are good examples to emulate, though class presentations may want to focus on different aspects. Some advice for giving good presentations will be provided in class, while lots of additional  advice for giving a good presentation  can be found on the web.docContentEnd
26docContentStartCOMP 599 - Winter 2010 - Assignment 3 Motion Capture Reuse Due 23:55 pm Thursday March 11 Getting Started In this assignment, you will create an animation of a human figure by concatenating small clips of motion capture sequences. This technique for reusing motion capture is often called motion graphs because one can imagine the nodes as containing small sequences of motion and the directed graph edges specify where transitions can occur between clips.  Typically some computation is necessary to decide which transitions to take when creating a new motion to satisfy a goal or to follow some path; however, in this assignment it will be sufficient to show some random transitions that produce interesting motion. Download the  motion capture data .  You need the bhv and javabin files, but you do not need the c3d files.  They are provided just for reference as it is a standard format, and the javabin files are created from these using a matlab script.  Note that you might just want to download one sequence initially for testing (e.g., the OptiTrack-IITSEC2007 demo sequence from NaturalPoint is a good starting point).  Sequences captured in the lab will be added to this directory for everyone to use.  Put the data files in to a "data" folder, and please  do not submit bvh, c3d, or javabin data files when you submit your assignment . Download the provided code from WebCT and dump it into a new java project.  The code contains two parts, just like the previous assignments: the tools package, and the code specific to assignment 3.  Note that there may have been small changes to the tools package (i.e., the BoxRoom class which is used to draw a floor and walls now lives in the comp599.tools.viewer package).  Here follows a short description of the provided files. A3App contains the main method, creates the 3D viewer, and defines the keyboard controls attached to the 3D canvas. This is the only file you need to modify, but you can also create other classes as you see fit (but  leave a note in the readme.txt if you modify any of the other three classes listed below ). C3DData loads the marker data from a javabin file.  Note that c3d files need to be converted to a java binary, and this has already been done for you with the data we captured in class (see the javadoc if you want to convert your own files). BVHData loads the skeleton and joint angle data from a bvh file.  The simple parser also creates a hierarchy of SkeletonNode objects.  The setSkeletonPose method sets the joint angles and root translation for the loaded skeleton. The motionData is private, but you should not need to do this for the objectives below. SkeletonNode defines a joint which can rotate about a set of axes.  The object has a parent SkeletonNode (null if it is the root), and a list of children).  The rotation axes of the skeleton node are located at a fixed offset from the parent frame, and the order of rotation is specified in a channel list (as loaded by the BVHData).  While all skeleton nodes joints can also have a translation component, this is only used for the root of the character (usually the hips).  The init method of this class estimates the size of different segments of the body to display simple 3D geometry between the joint and its parent.  There are a number of controls for displaying the skeleton in different ways.  Finally, note the getTransform method which gives you a transformation from the joint frame to the parent frame (you will want to use this to find the position and orientation of the root of your skeleton).  You may want to expand the "Skeleton pose controls" in the provided interface and try adjusting different angles to get some intuition for how these work. A few things to watch out for: The bvh and c3d data files may not contain the same number of frames (it might be off by one, and the current bvh loader currently tries to read an extra frame).  You may want to set the maximum frame number to be the lower of the two frame counts. Watch out for Matrix4d.get( Matrix3d R ) as this does a SVD normalization and can permute your axes when you're not looking. The better option for getting the upper 3x3 component of a 4x4 matrix is getRotationScale().  Your upper 3x3 component should already be unitary, but if it were not, again, you should use Matrix3d.normalizeCP() instead of Matrix3d.normalize() as the former does a cross product normalization instead of an SVD normalization. Again, you do not need to change anything in the tools package to complete this assignment.  The source for the tools is provided only for your convenience, and you should  focus your attention on the a3 package .  It is suggested that you read through all the provided code, and note in particular the areas that are marked TODO. Steps and Objectives (8/10) Basic motion playback The provided code will try to load a data file.  Modify the constructor of A3App so that it uses the data file you selected (note that you will revisit the other TODOs in the constructor in later objectives). The display method will automatically advance the current frame by an amount specified by the playSpeed, but it does not set the pose of the skeleton.  You need to make a simple modification so that the skeleton pose is updated when the frame number changes (i.e., the setSkeletonPose method of the BVHData). This class also contains methods to allow you to save a trajectory of modified skeleton poses back out to disk in bvh format. See the addCurrentPoseToTrajectory() and save(). Note that the current code will not play the motion back at the correct speed, but it is good enough for this assignment.  The alternative would be to keep track of the time elapsed and set the frame according to the capture rate, which was 100 Hz (the range of the playSpeed parameter would need modification too so that it could be less than 1 to slow motion down). Check that the c3d data and the bvh data both play and are located in the same place (i.e., like virtual markers on a virtual skeleton).  To do this you need to click the drawc3d  checkbox of the controls. Computation and display of the local floor frame Write a method to compute a local frame for the current skeleton pose.  Add code to your display call that uses this method and displays the frame.  The local frame should be located on the floor (y=0) with the y axis vertical, and the z axis pointing in the direction of the z axis of the hips (i.e., z axis of skeleton root projected onto the floor). See the getTransform method of SkeletonNode for getting the position and orientation of a skeleton node. There are two reasons why we need this local floor based reference frame.  First is to know where the character is and to allow us to properly translate and orient a motion clip based on what came before.  The second reason is to help us with making comparisons between the posture of the skeleton at different points in time (see the later objectives).  That is, putting the marker data (c3d) in coordinates of this frame allows two frames of marker positions to be compared while disregarding position in the x-z plane and rotation about the y axis. You will likely find it useful to use a FlatMatrix4d (comp599.tools.viewer) to store your frame (i.e., use the getBackingMatrix to get the contained Matrix4d object); notice the asArray method which you can use to get an array that is compatible with glMultMatrixd.  Note that jogl always has an extra parameter for any opengl call which takes an array to allow for indexing within the array, so in this case you would pass a zero as the second parameter to glMultMatrixd.  Reuse the existing FancyAxis (that is used in the display call to draw the world reference frame) to draw your local frame, but you will want to call setSize to make it an appropriate size (e.g., 25 cm high). Basic transitions The constructor creates a frame pair and stores it in a list.  Modify the display call so that the frame number is modified to take this transition.  While both forward and backward jumps make sense, you'll want to first test by always taking the backward transition (i.e., make an endless loop from a small portion of motion data). Note that the frame number is not necessarily advancing one frame at a time (i.e., when playing at higher speeds) so you'll want to make sure you still make this transition even if you're not exactly at the frame. Accumulated transformation Now that you have some basic code to loop a smaller clip of motion capture data, you'll need to accumulate the translation and rotation of the character (for instance, to assemble two steps into a continuous walk). Again, you will probably want to use a FlatMatrix4d to create an accumulated transformation frame.  Initialize it to the identity, and update this accumulated frame each time you make a transition.  The update you need to apply is the one that puts the next clip's beginning floor frame at the current clip's ending floor frame (i.e., you have transforms that map A to W and B to W and you need A to B). Add code to your display call so that you multiply this accumulated frame on the matrix stack before displaying the skeleton and c3d data.  Once this works, you might want to hand pick two similar frames in the data you've loaded to generate a nice walk cycle. Finally, add code to reset this accumulated frame to the identity when the 'R' key is pressed.  You need to have a convenient means of bringing your animated character back into the room if it goes wandering too far! Compute and display local c3d positions and velocities At startup you will want to precompute local frame marker data (i.e., go back to the A3App constructor and add a method call to whatever code you write for the computation part of this step).  Use your local floor frame code and the c3d data to build phase space vectors representing the position and velocity of markers in the local frame.  To compute the velocities average the velocity of the marker position over a small window (say 5 frames), so that the velocity estimates are  smooth  (not all trajectories were filtered in the Arena software before export, and there may be high frequency motions of markers due to poor position estimation from 2D camera data). You will want to test that you've computed these vectors correctly, so add some code to the display method to multiply the local frame (use glPush and glPop too) onto the matrix stack and draw these positions and small (scaled) line segments to represent the velocities.  Add a BooleanParameter to enable and disable drawing the debugging information in the A3App.  Add your BooleanParameter to the control panel in the A3App getControls method.  You may also want to add a DoubleParameter to the controls to help you scale the visualization of the velocity vectors appropriately. Remember that we are computing the position and velocity of the markers in this local frame to help with comparisons of movement at different parts of the motion clip.  We could also have used joint angles, but would need a more complicated weighted metric, and we would need to deal with the root of the skeleton differently. Find good transitions automatically Write code to automatically find good transitions.  Again you'll want to add a method call from your constructor to initialize the pairs when you first start, but you might also want to add a button to the control panel or add a call on a key press to recompute the pairs again on the fly.  This is because there are several parameters and heuristics involved in finding good pairs, and you will want to adjust these parameters without restarting and reloading the data every time. First note that comparing all frames with all other frames is expensive!  You may want to decimate the data by some factor (for instance, compute similarity only between frames which have frame number divisible by 5).  Also, I suggest you store the similarity scores in an array so that you can display the data to help with debugging.  More on this momentarily, but first let us consider the distance metric. To compare two frames you'll want to have a parameter to set the influence of the velocity component.  That is you don't want to have either positions or velocities dominate the comparison.  Thus, a good way to compute a similarity score between frames a and b would be ||x_a - x_b|| + w ||v_a - v_b||, where x is the positions of all markers in the local floor frame in a single vector, v is the (smoothed) velocities of all markers in the local floor frame, and w weights the two.  If you create a double parameter for w, then you can add it to the controls and tune the parameter while you are running the program, and press a button to request a recomputation of pairs with the new similarity metric.  How do you choose a good value w?  This depends on the units in which quantities are measured.docContentEnd
27docContentStartCOMP 599 - BVH Blender Movie Instructions This page describes instructions on how to render a movie of a BVH sequence with ambient occlusion and motion blur using Blender.  You should plan ahead as this step can be time consuming depending on the length of your motion sequence.  That is, you will likely need to let your computer render for a few hours! Use the following steps as a general guide for setting up and rendering your movie, but feel free to experiment and do your own thing! Download and install  Blender .  Note that you will also need to install  Python , and you should be careful to install the exact version that Blender asks (if it isn't correct it will complain, and you'll likely not be able to use any scripts).  If you missed the 15 minute tutorial in class on using Blender, you may want to read the getting started tutorial in the  tutorial archive , or search for video tutorials on youtube. You'll also need a script to help build geometry for the armature you will load from the bvh file.  Download the python script at  this page .  Put the script in your .blender/scripts folder.  The location of this folder will vary depending on how you install Blender.  On windows, this will either be under the "Program Files" folder or in a user folder such as "C:\Documents and Settings\kry\Application Data\Blender Foundation\Blender\.blender\scripts" on XP or "C:\Documents\kry\AppData\Blender Foundation\Blender\.blender\scripts" on Vista.  Check that the script is loaded by running Blender, and then selecting scripts from the button at the top left the window (the button has a tool tip to tell you that the button lets you select the window type). Click the scripts button that appears when you change the window type to scripts, and verify that "Armature Modeler" appears under the "Animation" entry.  If it doesn't show up, or if other items are empty (or if the import options are missing in the next step), then your scripts are likely not installed correctly.  Check for errors and repeat!  Put the top window back to "User Preferences" type when you are done so you have access to the menu bar. Now, load out.bvh using the menu "File -> Import -> MotionCapture (.bvh)...".  When you click on the "Import BVH" button, "As Armature" will be selected. Click OK. After loading, the armature will be selected by default. You'll want to rotate it 90 in x so that it is walking on the x-y plane instead of the x-z plane.  Press 'n', then click the value next to RotX and set it to 90. Press 'numberpad-0' to see the camera view.  Use the middle mouse button to rotate out of the camera view.  Use the scroll wheel to zoom in and out.  To see the animation that you loaded you'll want to bring up the timeline: right click exactly on the line between the perspective panel and select "split area", then left click in the bottom panel to divide the area.  Click the left top most button in the area you created, and select timeline from the menu.  Use the left mouse button to drag in the timeline to see the animation. When you started Blender, the default scene included a cube called "Cube".  Use the cube to create a template bone geometry. Select it by right clicking on it.  Press n to show the transform properties if they are not already showing.  Set the scale in y to be 3, then translate the scaled cube so that its long direction is going down the y axis.  Press 'tab' to go into edit mode, and then set Median Y to 1.0 in the transform properties window, then press tab again to return to object mode. Select the armature by right clicking on it, then select "Pose Mode" from the mode combo box (the one that was changing between object and edit when you press tab).  Press 'a' to select all the armature bones.  Now select in your scripts window "Scripts->Animation->Armature Modeler".  If you do not see the whole interface then make the window a bit larger.  Change the bone type from "Octaedron" to "custom" and provide the name "Cube" where it asks for OB.  Feel free to follow the instructions on Malefico's page to create different geometry, or tune the shapes in other ways. Create a plane for your character to walk on by selecting from the menu Add->Mesh->Plane.  Scale and position your plane by adjusting the transform properties (press 'n' to bring them up). Location 0,0,0 and scale 50,50,50 should work OK.  You may want to translate your original Cube below the plane so it is hidden from view. Change the colour of your character by selecting the Cube and pressing F5 to bring up the shading buttons, then select the small red sphere to select the material buttons.  Under Material, click on the grey rectangle next to "Col" to select a different colour. Turn on ambient occlusion rendering by pressing the world "World buttons" when you have the shading buttons selected. Pressing F5 multiple times will take you there.  It is the last button on the right.  Select the "Amb Occ" tab and press the "Ambient Occlusion" button.  The default settings are fine. Change the position of the camera so you can properly see your character throughout the animation.  Select the camera by right clicking it, press 'numberpad-0' for the camera view, 'n' to change change its position and orientation. Change the position of the light so you can properly see your character.  Right click the light drag it around, or set its transform properties. Press F12 to do a test render, and adjust everything as you see fit. Press F10 to select the "Scene" button and make sure the left most button with tooltip "Render buttons" is selected. Under "Format" choose "AVI Codec" instead of "jpeg", select xvid, and configure the codec for high quality.  Just under file format combo box is a FPS setting.  Since the natural point system records at 100 Hz, you should change the value to 100.  In the "Anim" tab to the left, change the step setting at the bottom to be 10 so that you're not rendering every frame, and set the End frame to be whatever you want as the end frame (check by scrubbing the cursor in the timeline window).  Finally, in the "Render" tab press the "MBLUR" button and set the Bf parameter to some suitable parameter, such as 5 (i.e., so it renders the blur over a longer period of time).  Press F12 once more for a test render to see that everything is satisfactory for the current frame. Finally, when you are ready, press the "ANIM" button on the "Anim" tab to render the whole animation to disk.  This will likely take a few hours, so you might want to test with a short sequence first and make any adjustments based on the result.docContentEnd
28docContentStartCOMP 599 - Winter 2010 - Assignment 4 Fluid Simulation Due 23:39 pm Thursday March 25 Getting Started In this assignment you will implement a simple yet stable Eularian fluid simulation, similar to the approach described in  [Stam et al. 2003] .  You should read this link before starting the assignment, and use it as a reference in completing the requirements below. Sample Code Download the provided code from WebCT (do not distribute).  The code has two main packages, similar to the previous assignment.  Note that the  tools  package has minor updates, so you will want to make sure you use this one.  The  a4  package contains code to provide a mouse interface and drawing interface to your fluid simulation code. A4App.java contains the mouse interface and drawing code. Left click creates a source, while right click will delete it.  Sources can be dragged using the left button, while dragging while holding the right button will apply forces to your fluid simulation.  The mouse wheel, while hovering over a source, can be used to adjust the heating/cooling rate of a source.  Clicking with the middle button will create a horizontal filament.  There are keyboard controls similar to previous assignments (space to toggle the simulation, R to reset, S to step, enter to record, C to create filaments); see the code for full details, and feel free to adjust the interface to suit your needs. Filament.java contains simple code for creating, advecting, and refining thin filaments.  This is provided purely as an additional visual aid in determining if your fluid is behaving correctly. Source.java contains code representing a heating or cooling source. A list of sources is maintained by the fluid, and is editable using the mouse with the code in A4App.java. Fluid.java contains the fluid simulation framework.  This should be the only place where you need to add code. You  do not need to change anything except Fluid.java . However, you are free to edit everything as you please, and you are certainly encouraged to explore and understand the rest of the provided code as it is small in size.  Be sure to leave a comment in your readme.txt on any additional test cases you add, or other modifications outside of the Fluid.java code. The setup for jars and libraries is the same from the previous assignments.  Consult the A1 page for more information.  Likewise, you may also want to visit the previous assignment specification for instructions on making videos. Steps and Objectives (7/7) * 100% You will find that there is already a fair bit of provided code in the Fluid class.  There are forces applied to the velocity field when mouse dragging while right button is held.  With the velocity field visualization turned on you can implement and test many parts of the assignment.  Implementing in this case will often mean taking code directly from the GDC03 code examples.  Note that in your final step method, there are three main components: apply forces, update velocities, update scalar fields (temperature, density, etc.).  Most steps should be trivial to implement and you should be able to test each using the functionality of the provided code.docContentEnd
29docContentStartCOMP 599 - Winter 2010 - Assignment 1 Mass-Spring Particle System Due 23:39 pm Tuesday January 26 Getting Started Since this is the first assignment, you'll need to spend a little bit of time to get set up.  If you are not already using Java then download and install the latest Java SE JDK  (careful not to select the JRE).  I also recommend using Eclipse  as a development environment. Note also that the specification of this assignment is long in that this first assignment.  Future assignments will be much shorter and you will be expected to complete them with more autonomy. New to Eclipse? If you are familiar with Eclipse (i.e., you took COMP 557 last term), then you can probably skip this section.  For those of you who are new, here is a few extra tips on using Eclipse and getting set up. Eclipse uses a workspace to organize your projects.  When you start eclipse for the first time, it will make you a workspace in some default location (probably your home directory), but you can switch workspaces with the file menu, and open any folder you want for your workspace.  One nice way to organize this would be to create a workspaceComp599 folder in your home directory, then tell eclipse to open that workspace. Once your workspace is open, add a new java project, give it a name like A1.  The defaults for the project when you click next are probably fine, e.g., default JRE, separate folders for source and class files.  Once it is created, you'll see a src folder for the source files and bin for the class files (note that you'll eventually need to create a directory called "stills" for when you're recording images to make a movie). You'll want to put the provided code (see below) in src folder of your new project, and there are lots of ways to do this, but you need the directory structure to match the package structure!! An easy way is to copy the comp599 directory in the zip file and paste it into the src directory.  Since everything lives in the package comp599 you need this folder (i.e., you can't just copy and paste the a1 folder into src). If you copy files into your project on the file system side, you'll need to tell Eclipse to refresh its view of the project (right click on the project and select refresh). So that summarizes the steps for "dumping the source code into a project". You'll have lots of errors at this point, but they all go away when you attach the jars as specified in the assignment. Lastly a few tips on using eclipse when you're browsing the code. If you let your mouse hover over an identifier, variable or method, a window will pop up telling you what it is, and providing you with the javadoc. If you hold ctrl and click on an identifier, it will take you to its definition (e.g., the implementation of a method). This is a great way to explore code rapidly! Note the yellow forward and back buttons on the tool bar are useful for going back to where you were after control clicking an identifier. Sample Code Download the  provided code  and dump it into a new java project.  The code has two parts.  The first part is the comp599.a1 package which contains the template code for this assignment.  The second part is the comp599.tools package, which is a set of tools for quickly getting started with 2D and 3D graphics. There are three parts to the tools package: parameters contains boolean and double parameter classes for quickly setting values with swing interface controls. swing contains layout helpers and panels for quickly throwing together a Java swing interface. viewer contains some simple classes for 2D and 3D viewing, including a 3D trackball and camera controls. (note that for simplicity, this assignment is set up to be all 2D graphics). You do not need to change anything in the tools package to complete this assignment.  The source for the tools is provided only for your convenience, and you should focus your attention on the a1 package .  Do not change any of the package names as this will interfere with marking. Jars and Native Libraries The code uses two libraries: JOGL for OpenGL bindings, and vecmath for classes useful for math with 2D (and 3D) vectors. The vecmath package is available as part of Java3D.  Instead of installing the full Java3D, download this copy of  vecmath.jar .  Compared to the latest version, I believe this version is only missing a few setter and getters in the matrix classes (nothing that you will miss, and marking problems will be avoided).  Also, the source code (i.e., the javadoc) is in the jar, so if it isn't automatically attached, you'll want to follow the following process.  First add the jar to your build path, then open up Reference Libraries in your project, right click on the jar to set properties, go to source code attachment, and tell it where to find the zip file.  You might also want to browse the vecmath javadoc online  to become more familiar with the available classes and methods. The JOGL bindings project has moved and is now available at Project Kenai .  From the main page you can find the necessary downloads from the  archived builds link , but note that you do not want the JOGL2.0 beta builds as there are some small but significant changes to methods. Here is a direct link to the latest release build, JSR-231 1.1.1a . Be sure to download the appropriate files for your platform.  If on windows, download jogl-1.1.1a-windows-i586.zip jogl-1.1.1a-src.zip (to have access to javadoc in Eclipse) jogl-1.1.1a-docs.zip (if you prefer reading javadoc in your browser) To make your life more pleasant in Eclipse, you want to attach the source code to the jar for the javadoc, as described above. Note that the .dll (or .so) that comes with the jar must be in your path.  You can do this by opening the reference libraries in your project, right clicking to select properties, choose Native Library and enter the location of the .dll or .so file. Note that the most noticable change to OpenGL function signatures under java is how functions with pointer arguments are mapped to two parameters under java (one for the array, one for the offset).  See the note on  Mapping of Pointer Arguments  and  Index Parameter for Arrays  in the JSR 231 Specification Overview . There will not be extensive OpenGL programing in this assignment, but if you need either a quick introduction to or to brush up on OpenGL, check out these links: The OpenGL Programming Guide (The Red Book) online version ( or at Amazon ), Jumping into JOGL ,  JOGL: A Beginner's Guide and Tutorial .  Another popular resource is  nehe.gamedev.net  (see the NeHeGL JOGL link on the bottom left). Creating Videos Below you are asked to assemble a sequence of recorded frames that demonstrate the required features of your program.  Everyone should use the  xvid MPEG-4 / H.264 codec.  Video creation is straightforward under windows using  virtualdub . If you are using Linux or OSX, a good alternative is to use mencoder on the command line (you can do this on windows too).  See the MPlayer  page for downloads and more information, and you can probably make your video with a command line that looks something like the following: mencoder -ovc xvid -xvidencopts bitrate=1800000:me_quality=6 -fps 24 -o out.avi mf://img Alternatively, under windows, once you have both the codec and virtualdub installed, you can create an avi file from a sequence of png still frames using the following steps (you'll probably want to complete at least part of the assignment and then come back to these steps later). In virtualdub, select "Open video file..." from the File menu and choose the first image in the sequence (i.e., img00000.png). This will automatically load the entire sequence The loaded images probably do not have a width and height which are multiple of 16, so you'll need to add a filter.  Under the Video menu, select "Filters...", click Add, select Resize and click OK. In the window that opens, there should be an option for Codec-friendly sizing in the bottom right.  Select "Multiples of 16" and click OK.  Now back at the Filters, click OK to close it. Now you need to set the codec.  Choose "Compression..." under the video menu and choose the codec you installed (e.g., Xvid MPEG-4 Codec). The default configuration of the codec should be fine, but I would prefer that you use maximum quality settings (i.e., adjust the quantization).  It is unlikely that any of the files you are creating will be too large, but use your best judgment! Now you can save the image sequence to an avi file.  Select "Save as avi..."  under the file menu and specify the file name, then wait for virtualdub to finish encoding the file (it might need a minute depending on the length of your video and the speed of your computer). Note that there are also many other good ways to encode videos.  Do whatever is easiest for you, but make sure that the result is high quality and uses the xvid codec. Steps and Objectives (8/10) The provided source code should help you get started quickly.  It has an interface for creating points and dragging them around.  The controls window lets to create a few different procedurally created test systems and lets you adjust parameters stuff as stiffness, damping, and step size.  The main method lives in the A1App class, so this is the one you'll want to start when running your program. Note also the keyboard commands attached to the drawing canvas that let you start and stop the simulation, reset, and clear.  There are also controls to help you save sequences of png files.  The important parts of the program, however, are missing. Note also that you will not be able to test much until you complete the first three steps. Spring Forces Finish implementing the code that computes spring deformation and viscous spring damping forces.  See the Spring.java file and the comment the starts with "TODO". Refer to your class notes or the PBM notes on the Pixar site.  You can optionally add viscous damping too, but it should be left at zero in your demonstration videos. Numerical Integration Create getState and setState methods to get and set phase space state of the system in a flat array.  Use these methods to write a forward Euler numerical integration method using the  Integrator  and  Function  interfaces provided.  See the "TODO" comments in ParticleSystem.java in the updateParticles and derivs methods.  Also see the "TODO" comment in the ForwardEuler class in the numerical package. To elaborate on this a bit, the step method in integrator needs flat array containing the phase space state of the system. But the state of the system is contained in member variables of all the instances of the particles.  As such, you'll want to write a method such as getState(double[] y) in your particle system class to pack up all the positions and velocities of the particles. The setState method should obviously do the opposite, so you can take the double[] yout array result from calling step.  Of course, you'll also need to allocate yourself arrays of the appropriate size so you can use these methods, and so you can call step. Note that the number of particles will increase if you click to create them, so you'll probably want to do something smart, like grow the size of your arrays as needed.  So, what you want to do is, first check if you have arrays y and yout that are of an appropriate size for the current number of particles.  Then pack the state of the particles using your getState method. Then call the step method of the integrator.  Then unpack the result into your particles with your setState method. Pinned Particles Some of the example systems have particles with a pinned property set to true.  Add a method to filter the state (and forces) so that these simple constraints work nicely with your numerical integration methods (both forward Euler, and those in step 5). To elaborate on this slightly, if a particle is pinned (a bilateral constraint), then each coordinate of the particle needs to remain constant. It should also have zero velocity and it should not undergo any acceleration. Your derivs function needs to make sure that the velocity and acceleration are valid, otherwise strange things might happen! Suppose you let forces produce accelerations, and you integrate these to get velocities. You'll accumulate velocities for the particle, which will try to make it move at each step, but you'll set the position back to where it is supposed to be. But that  wrong  velocity that the particle has will affect damping forces on the particles to which it is attached by springs! Thus, it is best to make sure that the whole state makes sense with respect to the constraints. Particle Wall Contact Modify the method you made in the previous step to also keep particles inside the window by projecting them to the closest boundary.  For a particle in contact with a wall, a velocity away from the wall is OK, but a velocity toward the wall should not be allowed (the same for forces). Additional Numerical Integration Types Create classes that implement the Integrator interface for the midpoint method, the 2/3 point method, and the fourth-order Runge-Kutta method.  That is, add classes to the numerical package and use them in your particle system.  You should also implement the  symplectic Euler  method, but note that this will break the abstraction of the Integrator interface slightly in that you will need to know how the positions and velocities are packed in the state array. Keyboard Controls Add keyboard controls so that you can switch between integrators by pressing 1 through 4 (have a look at the "TODO" comment at the bottom of the A1App class which adds the KeyAdapter to the canvas). When adjustSubsteps is true, you should automatically adjust the number of sub-steps so that each step involves the same amount of work (i.e., number of calls to compute derivatives). That is, 4 for FE, 2 for midpoint, 2 for 2/3 point, 1 for RK4. You might try to find scenarios for spring and damping parameters where different methods will perform better given the same computational cost. Stability Movie Record a sequence of examples that demonstrate how these different numerical methods perform.  Specifically, with the damping set to zero find a step size which demonstrates which method performs best.  Also demonstrate what happens and which is best when the damping is not zero (you might want to do the written question and think about regions of stability when doing this question.  Keep the time steps fixed.  Encode the video as described above.  Please keep your video short (half a minute should be plenty) and use the comment area to describe what you are showing. Interesting Movie Finally record a sequence of something interesting or amusing.  This could be something within the existing functionality of the specification and provided code, or some additional feature you add to your code (e.g., particles with other properties such as colours, different bouncyness properties).  Be creative, but don't spend too long on anything as the assignment is quite long as it is. Encode the video as described above.  Keep your video short and to the point (i.e., at most a few MB). Written Questions (2/10) Consider a one dimensional system consisting of a single particle with mass 1 kg attached to a rigid wall with a spring (100 N/m). If the particle starts with zero velocity at a position 0.01 m from rest (x=0), what is the exact trajectory?  What is the frequency of the oscillation in Hertz? Given what you know (from class) about the stability of the different integrators used in the programming part of this assignment, what would be a good choice of step size for each integrator?  Use your implementation to check that it matches what you expect from the theory. In the case of forward Euler and given a step size of 0.05 s, what is the minimum amount of damping required to prevent the system from blowing up? Again, in the case of forward Euler and given a step size of 0.05 s, What is the maximum amount of damping that can be used without the system blowing up?  Use your implementation to check that it matches what you expect from the theory. Prepare a pdf file with your answer to these written questions (scanned hand written document, or generated with latex, openoffice, or otherwise) and submit it along with your assignment via webCT. Finished? Great!  Submit your source code and two xvid encoded videos as a zip file via webCT.  Include a readme.txt file with any specific comments.  Also be sure to include a pdf with your written answer (i.e., scans of handwritten work, or typeset).  Your readme should provide a list of people with which you discussed the assignment, or state that you did discuss the assignment with anyone.docContentEnd
30docContentStartCOMP 599 - Winter 2010 - Assignment 2 Robust Collision Processing Due 23:39 pm Tuesday February 16 Getting Started In this assignment you will implemnet robust collision processing, similar to the cloth system in [Bridson et al. 2002]. For simplicity, your implementation will be in 2D, and will in many respects extend the code you worked on in assignment 1 (see the notes on provided code below).  In addition to creating a video of something interesting, you are invited to take part in the "alphabet soup challenge" to see how many letters you can simulate before edge-edge interpenetrations occur. Sample Code Download the provided code from WebCT (do not distribute).  The code has two main packages, similar to the previous assignment.  Note that the  tools  package has minor updates, so you will want to make sure you use this one.  The  a2  package contains code which is very similar to the first assignment except for a few notable differences ParticleSystem.java now implements a symplectic Euler step in update particles, and does not make use of the Integrator interface from the previous assignment. TestSystems.java implements a variety of test systems that will help you debug and stress-test your code.  Feel free to add your own test systems too, though note you can also do this on the fly using mouse clicks. LeafSpring.java implements a joint spring between three particles, which is useful for creating long 2D strings which hold their shape (for instnace, letters). AlphabetSoupFactory.java is used by TestSystem to generate mass spring systems from fonts. SanityCheck.java is used by the application to test for edge-edge collisions, that is, a discrete collision detection test.  If collisions are found, the background turns red and the simulation is stopped (i.e., game over). You  do not need to change anything except RobustCCD.java  and optionally TestSystems.java if you want to hard code additional test cases or special scenarios.  Be sure to leave a comment in your readme.txt on any additional test cases you add, or other modifications outside of the RobustCCD.java code. The setup for jars and libraries is the same from the previous assignment.  Consult the A1 page for more information.  Likewise, you may also want to visit the previous assignment specification for instructions on making videos. Steps and Objectives (5/5) * 95% This assignment contains two main parts.  First is the continuous collision detection for points and line segments.  Second is the response to collisions.  You will need to modify the symplectice Euler step in the updateParticles() method, which advances the system by the given time step h.  As discussed in class and documented in the method, this method does the following: Symplectic Euler velocity update using forces from springs, gravity, etc. Velocity-level collision response (iterative solve) Symplectic Euler position update (guaranteed intersection free) Both main parts of the assignment are concerned with step two listed above (i.e., the velocity-level collision resolution). Continuous Collision Detection Perform robust interval-based collision detection of all particle-edge pairs during the time interval (0,h] for the given step size h.  The edges defined by Spring objects connecting particles.  As discussed in class, you will do this by doing the following Given the particles are moving on linear trajectories specified by their position at the current time and their velocity, find all times of co-linearity on (0,h] by solving the appropriate quadratic equation. determine the contact location on the line segment, for instance, as a parameter alpha in [0,1]. Note that some roots will give you a situation where the particle is not on the line segment.  You should go through the roots in the interval (0,h] in ascending order, and then process only the earliest collision you find. Note also that your root finding needs to be robust!  You may need to add epsilon checks for the alpha parameter you compute, and it may also be beneficial to check roots that happen just after h (i.e., h plus some small time based epsilon). A quick way of testing this part is to pin the three particles involved in a collision each time you find a collision in the interval (0,h].  You should make a very short movie to demonstrate this objective and to show your progress. Collision Impulses When you find a collision on (0,t], you must apply an appropriate impulse to the particles involved to resolve the collision.  As discussed in class, this involves the following. Computing a suitable unit normal for the collision (at the time of collision), Computing a suitable impulse using a small near-inelastic restitution coefficient (e.g., the default value which is set for you in the interface). Updating the velocities of the particles given the impulse, and using the assumption that pinned particles have infinite mass (i.e., in computing the impulse and distributing the impulse to the 3 particles). You may find it useful to temporarily setting the restitution value to 1 (or other values using the slider) to help debug your velocity impulses. Iterative Solve Many particles and edges may be colliding in a given time interval.  You will want to sequentially check all particle-edge pairs, and immediately after each check you should apply the collision impulses you compute in the previous step.  You should continue through all the pairs in this manner, but note that there may still be collisions on the interval (0,t] after processing all pairs as some particles may be involved in multiple collisions.  As such you'll need to iterate over all pairs until you have resolved all collisions on (0,t].  As discussed in class, this may be slow to converge.  It is a good idea to give up after a some maximum number of iterations, and return false to report the problem and halt the simulation. Penalty Forces Penalty forces can help keep objects separate and reduce the number of difficult velocity-level impulses that need to be applied.  The penalty forces will let you model edges as if they had a thickness of 2H.  A default thickness of 2 pixels is set for you in the user interface controls.  So, as discussed in class, if a particle is within a distance of H of a line segment, then apply a simple spring force impulse with stiffness identical to the stretch springs. see also [Bridson et al. 2002] for more details. For your simulation to run smoothly, you'll likely need to address particle-particle penalty forces, i.e., forces when alpha falls just outside of [0,1]. Interesting Video Record a sequence of something interesting or amusing. Note that you can create particles by clicking with the mouse, and you can also pin and unpin particles by clicking them. So experiment, have fun, and make a movie of something creative and interesting. Optional: Alphabet Soup Challenge How many letters can you simulate before the soup goes bad? Post your successes to WebCT, and the final results will be also added to this page for posterity.  Note that simulation parameters must be reasonable (no extra bouncy collisions). Optional: Extensions You might optionally like to think about the following issues. Frictional contact is generally a hard problem, but there exist many good models for friction during impact. For impacts, you may want to read about what Bridson suggests as a straightforward way to apply impulses opposing tangential motion. The iterative solver can fail to converge, even after adding penalty forces.  You can improve robustness and find solutions in these difficult cases by using  rigid impact zones  as described in [Bridson 2002].  This effectively acts like a velocity filter and provides a "fail safe" to avoid interpenetration when the iterative solver fails.  There are drawbacks, however, as rigid zones can be large and will eliminate interesting deformable dynamics. As particle numbers increase, the all particle-edge pair collision test becomes quite expensive.  Space time bounds can be used to cull many root finding tests, but you could also consider a "broad-phase" collision detection scheme, such as a uniform grid subdivision of space. You may like to think about the complexities of moving this simulation to 3D.  For instance, the modifications would include: both particle triangle tests and edge-edge tests, robust solution of cubic polynomials, robustly testing point in triangle.  A nice aspect of [Bridson et al. 2002] is also the subdivision surface refinement of the 3D cloth, which gives very smooth results for coarse cloth simulations. Some tips for robust simulation.  Watch out for all special cases as they will happen once you are running large simulations.  If you are dividing, you can probably be sure that the denominator will be zero in some cases (and you should deal with these cases differently). Use double precision floating point.  Use epsilon checks to make your code robust to floating point error.  Finally, strive for correctness instead of speed. References Robert Bridson , Ronald P. Fedkiw, John Anderson,  Robust Treatment of Collisions, Contact, and Friction for Cloth Animation , ACM Transactions on Graphics, 21(3), July 2002, pp. 594-603. Witkin, A., and Baraff, D., Eds. 2001.  Physically Based Modeling: Principles and Practice. Course Notes.  ACM SIGGRAPH '01. Doug James , CS5643: Physically Based Animation for Computer Graphics, Assignment #2 , Cornell University. Written Questions (1/1) * 5% The written question is available as a PDF download. Prepare a pdf file with your answer to this written question (scanned hand written document, or generated with latex, openoffice, or otherwise) and submit it along with your assignment via webCT. Finished? Great!  Submit your source code and two xvid encoded videos as a zip file via webCT.  Include a readme.txt file with any specific comments.  Also be sure to include a pdf with your written answer (i.e., scans of handwritten work, or typeset).  Your readme should provide a list of people with which you discussed the assignment, or state that you did discuss the assignment with anyone.docContentEnd
31docContentStartCOMP 557 - Fall 2009 - Assignment 0 Getting Started with OpenGL in Java This is not a real assignment, but instead is intended as means to help you get set up for doing the assignments and the beginning of term OpenGL tutorials. The lab machines already have the necessary software installed, but if you are using your own machine then you may need to install some software. Java and Eclipse Software If you are not already using Sun/Oracle Java, or have a very old installation, then download and install the latest  Java SE JDK  (careful not to select the JRE).  Note that you may already have "other" Java versions installed on your machine (for instance, Microsoft or GNU Java), but avoid using these as they will very likely lead to problems. I also strongly recommend using  Eclipse as a development environment. If you need to install it, then I suggest downloading the Eclipse IDE for Java Developers . If you have multiple versions of java installed, you'll also want to make sure that you are using the appropriate JDK (see Window->Preferences, Java, Installed JREs) and have the compiler compliance level is set to 1.6 (see Window->Preferences, Java, Compiler). If you are familiar with Eclipse, you can probably skip the rest of this section. Using Eclipse Eclipse uses a workspace to organize your projects. When you start eclipse for the first time, it will make you a workspace in some default location (probably your home directory), but you can switch workspaces with the file menu, and open any folder you want for your workspace. One nice way to organize this would be to create a workspaceComp557 folder in your home directory, then tell eclipse to open that workspace. Once your workspace is open, add a new java project, give it a name, such as A0. The defaults for the project when you click next are probably fine, e.g., default JRE, separate folders for source and class files. Once it is created, you will see a src folder for the source files and bin for the class files (note that you may eventually create additional folders for data). Lastly a few tips on using eclipse when you're browsing the code. If you let your mouse hover over an identifier, variable or method, a window will pop up telling you what it is, and providing you with the javadoc. If you hold ctrl and click on an identifier, it will take you to its definition (e.g., the implementation of a method). This is a great way to explore code rapidly! Note the yellow forward and back buttons on the tool bar are useful for going back to where you were after control clicking an identifier. Provided Code Download the  provided code and dump it into a new java project. Note that the code lives in the  comp557.a0 package. Please do not change the package name for any of your assignments.  This example code contains a minimal example framework with which you can try out the OpenGL API, and may be of use during the tutorials. You'll want to put the provided code (see below) in src folder of your new project, and there are lots of ways to do this. Most importantly, you need the directory structure to match the package structure! An easy way is to copy the directory provided in the zip file and paste it into the src directory. Since everything lives in the package  comp557 you need this folder (i.e., you can't just copy and paste the  a0  folder into src). If you copy files into your project on the file system side, you'll need to tell Eclipse to refresh its view of the project (right click on the project and select refresh). This summarizes the steps for "dumping the source code into a project". You'll have lots of errors at this point, but they all go away when you attach the jars as specified in the assignment. Libraries The provided code uses  JOGL  for OpenGL bindings. JOGL  has been around for many years and has changed over the years to keep up to date with the evolving OpenGL specification.  The latest version involves "profiles" to allow for applications to be developed for different versions of OpenGL and different hardware (e.g., OpenGL ES 2.0, as you would use for an Android or iOS device).  We will use the previous version to avoid profiles, and also because builds of the libraries are available for a large variety of platforms at  jogl.dev.java.net . Go to the release build page  JSR-231 1.1.1a  and download the appropriate files for your platform. For instance, if on windows, download jogl-1.1.1a-windows-i586.zip jogl-1.1.1a-src.zip (to have access to javadoc in Eclipse) jogl-1.1.1a-docs.zip (if you prefer reading javadoc in your browser) To make your life more pleasant in Eclipse, you want to attach the source code to the jar for the javadoc. First add the jar to your build path, then open up Reference Libraries in your project, right click on the jar to set properties, go to source code attachment, and tell it where to find the zip file. Note that the .dll (or .so) that comes with the jar must be in your path. You can do this by opening the reference libraries in your project, right clicking to select properties, choose Native Library and enter the location of the .dll or .so file.  You can also do this by adding the folder containing the shared library to your path. To complete most assignments you will likely need to use the  vecmath  jar for working with matrices, points, and vectors. The  vecmath  package is available as part of JAVA3D, but instead of installing the full Java3D, you can download just the  vecmath.jar locally. The source code (i.e., the javadoc) is in the jar, so if it isn't automatically attached, you'll want to repeat the process above and attach the jar as source. You might also want to browse the  vecmath javadoc online . You may find the following links useful for documentation on OpenGL:  The OpenGL Programming Guide (The Red Book) online version  ( or at Amazon ), Another popular resource is  nehe.gamedev.net (see the NeHeGL JOGL link on the bottom right). WebCT and Submitting Assignments You do not need to submit anything for assignment zero. However, if you are new to WebCT, you may wish to test the submission process, and as such there is a test assignment called A0 on WebCT.  Note that you should always check that the system has correctly received your uploaded files by downloading your submission and verifying its contents! You can always "take back your work" before the deadline and resubmit.  Once the deadline has passed, you'll not be able to do this.  Late  assignment submissions are permitted, but can only be made if you have not previously submitted an assignment.  If ever you have problems submitting your work, contact the instructor or one of the TAs.docContentEnd
32docContentStartAnticipatory Balance Control Amir H. Rabbani McGill University Michiel van de Panne University of British Columbia Paul G. Kry McGill University Abstract A hallmark of many skilled motions is the anticipatory nature of the balance-related adjustments that happen  in preparation for  the expected evolution of forces during the motion.  This can shape simulated and animated motions in subtle-but-important ways, help lend physical credence to the motion, and help signal the character's intent.  In this paper, we investigate how center of mass reference trajectories (CMRTs) can be learned in order to achieve anticipatory balance control with a state-of-the-art reactive balancing system.  This enables the design of physics-based motion simulations that involve fast pose transitions as well as force-based interactions with the environment, such as punches, pushes, and catching heavy objects.  We demonstrate the results on planar human models, and show that CMRTs can generalize across parameterized versions of a motion.  We illustrate that they are also effective at conveying a mismatch between a character's expectations and reality, e.g., thinking that an object is heavier than it is. ACM SIGGRAPH Conference on Motion in Games 2014. Paper  [PDF, 1.5 MB] Movie download  [WMV, 100 MB]docContentEnd
33docContentStartMulti-layer skin simulation with adaptive constraints Pengbo Li Paul G. Kry School of Computer Science, McGill University Abstract We present an approach for physics based simulation of the wrinkling of multi-layer skin with heterogeneous material properties. Each layer of skin is simulated with an adaptive mesh, with the different layers coupled via constraints that only permit wrinkle deformation at wavelengths that match the physical properties of the multi-layer model. We use texture maps to define varying elasticity and thickness of the skin layers, and design our constraints as continuous functions, which we discretize at run time to match the changing adaptive mesh topology.  In our examples, we use blend shapes to drive the bottom layer, and we present a variety of examples of simulations that demonstrate small wrinkles on top of larger wrinkles, which is a typical pattern seen on human skin.  Finally, we show that our physics-based wrinkles can be used in the automatic creation of wrinkle maps, allowing the visual details of our high resolution simulations to be produced at real time speeds. Motion in Games 2014. Paper  [PDF, 1.5 MB] Movie download  [WMV, 100 MB]docContentEnd
34docContentStartEigenSkin:  Real Time Large Deformation Character Skinning in Hardware Paul G. Kry, Doug L. James, and Dinesh K. Pai PDF (2MB) MOVIE [AVI-MPG4] (20MB) Abstract: We present a technique which allows subtle nonlinear quasi-static deformations of articulated characters to be compactly approximated by data-dependent eigenbases which are optimized for real time rendering on commodity graphics hardware.  The method extends the common Skeletal-Subspace Deformation (SSD) technique to provide efficient approximations of the complex deformation behaviours exhibited in simulated, measured, and artist-drawn characters.  Instead of storing displacements for key poses (which may be numerous), we precompute principal components of the deformation influences for individual kinematic joints, and so construct error-optimal eigenbases describing each joint's deformation subspace. Pose-dependent deformations are then expressed in terms of these reduced eigenbases, allowing precomputed coefficients of the eigenbasis to be interpolated at run time.  Vertex program hardware can then efficiently render nonlinear skin deformations using a small number of eigendisplacements stored in graphics hardware.  We refer to the final resulting character skinning construct as the model's   EigenSkin .  Animation results are presented for a very large nonlinear finite element model of a human hand rendered in real time at minimal cost to the main CPU. SHADOW PUPPET MOVIE [AVI-MPG4] (35MB) Last updated July 2002docContentEnd
35docContentStartInverse Kinodynamics: Editing and Constraining Kinematic Approximations of Dynamic Motion Cyrus Rahgoshay McGill University Amir H. Rabbani McGill University Karan Singh University of Toronto Paul G. Kry McGill University Abstract We present inverse kinodynamics (IKD), an animator friendly kinematic workflow that both encapsulates short-lived dynamics and allows precise space-time constraints. Kinodynamics (KD), defines the system state at any given time as the result of a kinematic state in the recent past, physically simulated over a short temporal window to the present. KD is a well suited kinematic approximation to animated characters and other dynamic systems with dominant kinematic motion and short-lived dynamics. Given a dynamic system, we first choose an appropriate kinodynamic window size based on accelerations in the kinematic trajectory and the physical properties of the system. We then present an inverse kinodynamics (IKD) algorithm, where a kinodynamic system can precisely attain a set of animator constraints at specified times. Our approach solves the IKD problem iteratively, and is able to handle full pose or end effector constraints at both position and velocity level, as well as multiple constraints in close temporal proximity. Our approach can also be used to solve position and velocity constraints on passive systems attached to kinematically driven bodies. We show IKD to be a compelling approach to the direct kinematic control of character, with secondary dynamics via examples of skeletal dynamics and facial animation. Graphics Interface 2012. Best Paper, Graphics. Paper  [PDF, 1.5 MB] Movie download  [WMV, 100 MB] ACM SIGGRAPH Symposium on Interactive 3D graphics and Games 2012, Poster session. Best Poster Honourable Mention. Poster Abstract  [PDF, 340 KB] Poster  [PDF, 2.5 MB]docContentEnd
36docContentStartEmbedded Thin Shells for Wrinkle Simulation Olivier Remillard McGill University Paul G. Kry McGill University Abstract We present a new technique for simulating high resolution surface wrinkling deformations of composite objects consisting of a soft interior and a harder skin. We combine high resolution thin shells with coarse finite element lattices and define frequency based constraints that allow the formation of wrinkles with properties matching those predicted by the physical parameters of the composite object. Our two-way coupled model produces the expected wrinkling behavior without the computational expense of a large number of volumetric elements to model deformations under the surface. We use C1 quadratic shape functions for the interior deformations, allowing very coarse resolutions to model the overall global deformation efficiently, while avoiding visual artifacts of wrinkling at discretization boundaries. We demonstrate that our model produces wrinkle wavelengths that match both theoretical predictions and high resolution volumetric simulations. We also show example applications in simulating wrinkles on passive objects, such as furniture, and for wrinkles on faces in character animation. SIGGRAPH 2013. Paper  [PDF, 2.6 MB] Movie download  [WMV, 72 MB] @article{RemillardKry2013, author = {R\'{e}millard, Olivier and Kry, Paul G.}, title = {}, journal = {ACM Trans. Graph.}, volume = {32}, issue = {4}, month = {July}, year = {2013}, articleno = {82}, numpages = {8}, url = {http://doi.acm.org/10.1145/2461912.2462018}, doi = {http://doi.acm.org/10.1145/2461912.2462018}, publisher = {ACM}, address = {New York, NY, USA}, } GRAND 2013. Poster  [PDF, 1.2 MB]docContentEnd
37docContentStartBrigitte  Pientka Home Teaching teach.htmlhtmlul> about.htmlhtmlntent-wrap starts here --> Short About Brigitte Pientka is an Associate Professor in the  School of Computer Science  at  , and leading the  Computation and Logic  group. She received her PhDhttp://www.cs.mcgill.ca/~complogicogicclass="top">Carnegie Mellon University  in 2003, and studied previously at thttp://www.cs.cmu.edu.eduh and Technical University of Darmstadt. Sidebar Menu Home Research Interests My research interest lies in developing a theoretical and practical foundation for building and reasoning about reliable safe software systems. To achieve this goal, I combine theoretical research on the logical foundations of computer science in  programming languages  and  verification   with system building. The topics I am interested in include logics (classical and non-classical), type theory, theorem proving, logic and functional programming, and logical frameworks. For more information, you can visit Computation and Logic  group. Recent Publications Francisco Ferreira, Brigitte Pientka,  Bidirectional Elaboration of Dependentlyhttp://cs.mcgill.ca/~bpientka/papers/reconstruction-long.pdfonstruction-long.pdf   Anton Setzer, Andreas Abel, Brigitte Pientka and David Thibodeau.  Unnesting of Copatterns , TLCA'14 	http://cs.mcgill.ca/~bpientka/papers/copat-compilation.pdfrs/copat-compilation.pdf.  Fair reactive programming , 41th ACM SIGPLAN-SIGACT Shttp://cs.mcgill.ca/~bpientka/papers/ltl.pdf.ca/~bpientka/papers/ltl.pdfp://cs.mcgill.ca/~bpientka/papaers/ltl-long.pdf">Long version ). Andrehttp://cs.mcgill.ca/~bpientka/papaers/ltl-long.pdfa/~bpientka/papaers/ltl-long.pdf.pdf">First-class substitutions in contextual type theory Programming type-safe transformations using higher-order http://cs.mcgill.ca/~bpientka/papers/cc.pdfwww.cs.mcgill.ca/~bpientka/papers/cc.pdfcodedocContentEnd
38docContentStartBrigitte  Pientka Research Beluga This project explores how to combine functional programming with dependently-typed, higher-order data specified in the logical framework LF. For more information see the project Sidebar Menu Home Publications Journals Brigitte Pientka.  , Brigitte Pientka, ACM Transactions on Computational Logic, vol 11, issue 1 (October 2009). Brigitte Pientka, Journal of Automated Reasoning (JAR), vol 34,  issue 2,  pages 179 - 207, 2005. , Brigitte Pientka, Christoph Kreitz,Fundamenta Informaticae, vol 39, issue 1-2, pages 189 - 209, 2001. Conferences Andreas Abel, Brigitte Pientka, David Thibodeau, Anton Setzer. , 39th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'12). Andreas Abel and Brigitte Pientka. Beluga: proghttp://www.cs.mcgill.ca/~bpientka/papers/flops.pdf contexts ,Brigitte Pientka, Invited talk at  10th Internatiohttp://www.kb.ecei.tohoku.ac.jp/flops2010/wiki/ng (FLOPS'10) , April 2010, Sendai, Japan. Programminhttp://www.cs.mcgill.ca/~bpientka/papers/prog-proofs.pdfypes , Brigitte Pientka, Verification, Induction, and Termination analysis, LNAI, Springer, Aug 2010 Reasoning with http://www.cs.mcgill.ca/~bpientka/papers/worlds-rev.pdf ,Amy Felty and Brigitte Pientka, ITP'10 (Electronic Appendix ( pdf ,  mechanized proofshttp://complogic.cs.mcgill.ca/beluga/benchmarks/index.php Beluga: A Framehttp://www.cs.mcgill.ca/~bpientka/papers/system-description.pdfem description) ,Brigitte Pientka and Joshua Dunfield, IJCAR'10, July 2010 Programming with proofs ahttp://www.cs.mcgill.ca/~bpientka/papers/ppdp-pientka.pdfnfield, 10th International ACM SIGPLAN Symposium on Principles and Practice of Declarative Programming (PPDP'08), pages 163 - 173, ACM Press, 2008. A type-theoretic foundation http://www.cs.mcgill.ca/~bpientka/papers/hoasfun-short.pdft-class substitutions , Brigitte Pientka, 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'08), pages 371 - 382, ACM Press, 2008. Proof Pearl:The power of higher-order enhttp://www.cs.mcgill.ca/~bpientka/papers/pearl.pdfe Pientka, 20th International Conference on Theorem Proving in Higher-order Logics(TPHOLs'07), Kaiserslautern, Germany, pages 246 - 261, LNCS 4732, Springer, 2007,  code . Bidirectional Decision Procedurhttp://www.cs.mcgill.ca/~bpientka/papers/heilala-pientka-cade07.pdfli Heilala and Brigitte Pientka, 21st International Conference of Automated Deduction (CADE'07), Bremen, Germany, pages 116 - 131, LNCS 4603, Springer,  2007. Overcoming perfomrance barriers: efficienthttp://www.cs.mcgill.ca/~bpientka/papers/iclp06-tutorial.pdfte Pientka, 22nd International Conference on Logic Programming (ICLP'06), Seattle, USA, pages 3 - 10, LNCS 4079, Springer, 2006 (invited tutorial,  slides ). Small proof witnesses for LF , Susmit Sarkar, Brigittehttp://www.cs.mcgill.ca/~bpientka/papers/oracle-iclp.pdfLogic Programming (ICLP'05), Barcelona, Spain, pages 387 - 401, LNCS 3668, Springer, 2005. Tabling for higher-order logic programming , Brigitte Pientkhttp://www.cs.mcgill.ca/~bpientka/papers/eftab-long.pdf (CADE'05), Talinn, Estonia, pages 54 - 69, LNCS 3632, Springer, 2005. Higher-order substitution tree indexing, Brigitte Pientka,  19thhttp://www.cs.mcgill.ca/~bpientka/papers/index.psCLP'03),  (ICLP) , Mumbai, India, pages 377 - 391, LNCS 2916, Springer, 2003.  ( Best shttp://www.tcs.tifr.res.in/~iclp03/> Optimizing higher-order pattern unification,  Brigitte Pientka, Frank Pfhttp://www.cs.mcgill.ca/~bpientka/papers/assign.psated Deduction  (CADE'03) , Miami, Florida, USA, pages 473 - 487, LNAI 2741, Springer, 2003. http://www.cade-http://cs.mcgill.ca/~bpientka/papers/uniftab.ps">A proof-theoretic foundation for tabled higher-order logic programming, (slides)  Brigitte Pientka. 18th International Conference on Logic Proghttp://www.cs.mcghttp://floc02.diku.dk/ICLP/p-slides.pdfdocContentEnd
39docContentStartBrigitte  Pientka Teaching teach.htmlhtmlbout.html" id="current">AboutdocContentEnd
40docContentStartBrigitte  Pientka Teaching About <about.htmlhtmleaderphoto"> Sidebar Menu Home Teaching http://cs.mcgill.ca/~bpientka/teach.html#TeachingTeachingtml#Courses">CoursesdocContentEnd
41docContentStartSophia Summer 2012 Winter 2010 September 2009 May 2009 Fall 2008 September 2007 September 2006 March 2006 September 2005 February 2005 Summer 2004 Spring 2004 Winter 2003/2004 Fall 2003 Summer 2003 Spring 2003docContentEnd
42docContentStartDistributed Information Systems Lab The distributed information systems lab works at several projects related to communication and information management such large-scale data management in the cloud, transactional platform as a service, adaptability in multi-tier architectures, and distributed massively multi-player games. Current Projects CumuloNimbo  is a European project funded by the European Commission under the 7th Programme Framework (FP7). One of its goals is to develop a highly scalable transactional platform as a server (PaaS). It will provide ultra-scalability for update-intensive workloads providing full transactional properties across the entire data without compromising performance. The Distributed Information Systems Lab participates in this project as an international partner. Adaptability in multi-tier Information Systems:  Web-based applications based on complex multi-tier architecture have become one of the most emerging new technologies over the last years. Fault-tolernace, load balancing and adaptability are important issues. Our current focus evolves around efficient distributed caching strategies. Massively Multiplayer Games  In massively multiplayer online games (MMOG),  thousands of players around the globe connect via their home computers to a common game platform. We are currently investigating topics such as peer-to-peer games, mobile games, cheating, pub/sub based update dissemination, and cloud-based game services. Past Projects Publications at DBLPdocContentEnd
43docContentStartMachine Learning meets Databases Data mining software packages usually provide a whole set of data mining and machine learning algorithms, and hence, are attractive because they allow the analysis of data with many kinds of algorithms in an easy to use fashion. However, these packages are often based on main-memory structures, limiting the amount of data they can handle. We have been exploring how to use database technology to scale to large data sets. We took Weka, a popular open-source machine learning software package, and added a relational storage manager as a backend tier. The extensions are transparent to the learning algorithms implemented in Weka, since they are hidden behind Weka’s standard main-memory data structure interface. Thus, machine learning researchers can continue to implement new algorithms into Weka without the need to know how to access the database. Furthermore, some general mining tasks are transferred into the database system to speed up execution. A special buffer mechanism further reduces the interactions with the database backend. Our WekaDB can handle much larger data sets than the original Weka with reasonable performance.docContentEnd
44docContentStartPast Projects Database Replication:  Data replication is very attractive to increase system throughput, provide fault-tolerance, and have fast local access. We have been looking at database replication as a middleware layer and as part of the database kernelt. At the middleware layer, we have developed Middle-R which runs on top of standard database systems. Research focus within Middle-R is on various topics such as wide-area replication, partial replication, relationship between replication middleware and underlying database system, and data consistency. Within the database kernel, we have developed Postgres-R, an extension to PostgreSQL that provides fast, cluster-based data replication based on the rich semantics of group communication. Recent work has looked on recovery and reconfiguration mechanisms for Postgres-R McXML: A native XML data management system: The XML data format is currently widely used for data exchange between distributed components and as the common data model to publish data on the web (e.g., in bioinformatics information systems). We have developed the native XML data management system McXML. Its focus is on efficient update management. Exp-DB: A Laboratory Information System Framework: The analysis of proteins and their functionality in the cell involves many complex steps including various types of experiments. Many of these steps are supported by specific software products resulting in enormous amounts of data (several Gigabytes per day). Adequate storage, tracing, and linking of this data is essential. Other important issues are workflow management, and access control. Machine Learning meets Databases . Many software packages for data mining and machine algorithms assume all data can reside in main memory limiting the amount of data they can handle. We are investigating how to plug relational database systems as storage manager to such learning software. .docContentEnd
45docContentStartDatabase Replication Data replication is very attractive in order to increase system throughput and provide fault-tolerance. However, it is a challenge to keep data copies consistent. Furthermore, in order to fully take advantage of the processing power of all replicas, adaptive load-balancing schemes are needed. Conceptually, our work can be split into two branches: Middleware-based replication Middle-R is our middleware based replication tool. Clients connect to Middle-R via a JDBC driver and Middle-R forwards the requests to one of several database replicas. Each database replica is an instance of a non-replicated standard database system. We currently work with PostgreSQL. Middle-R can have one middleware instance, or one middleware instance for each database instance. Middle-R provides efficient, fast and consistent database replication for both cluster configurations (all replicas are within a LAN) and in WAN environments. Our approach provides fault-tolerance. Current  projects related to Middle-R: Isolation levels:  Our solutions allows for different levels of isolation of concurrent transactions. More recently, we have focused on snapshot isolation, as this is the level that is also provided by the underlying PostgreSQL system. Wide-Area Systems: Most research has focused on local area networks since communication is, in principle, fast in these networks. However, the requirement is also high to provide transparent, efficient, and consistent data replication in wide area networks. The usual communication technology used in clusters (e.g., group communication systems) does not work well in WAN settings. Our solution is nearly as performant as current commercial solutions for wide-area replication but at the same time provides a higher degree of flexibility and consistency. Partial Replication:  While full replication places copies of data items at all replicas, partial replication only assigns copies of an individual data item to some replicas. When there is a high update workload full replication has too much overhead to keep all copies consistent and the individual replicas have little resources left to execute read operations. In contrast, with partial replication, a replica only has to execute the updates for data items for which it has local copies, and thus, has more potential to execute read operations. We have analyzed the performance gains that can be achieved with partial replication. We also addressed many challenges associated with partial replication, such as a more complex concurrency control, the challenge of finding a replica with the data copies needed for a request, and finally with the necessity  of distributed query execution. Relationship between middleware and database system:  When implementing a replication solution outside the database system, the replication tool does not have access to important components within the database system, such as concurrency control. Thus, functionality has to be reimplemented in the middleware. Understanding database interfaces, and the possibility to expose some of the internals to the outside world might allow for better performance and simpler solutions at the middleware layer. Postgres-R Postgres-R is an extension of the open-source relational database system  PostgreSQL . Postgres-R provides efficient, fast and consistent database replication for cluster configuration. To address the performance and consistency challenges we exploit the rich semantics of   group communication systems. In particular, the approach exploits the   total order delivery   semantics of the multicast primitives to guarantee the isolation of transactions (all sites serialize conflicting transactions according to the total order in which the group communication system delivers messages), and the   reliable delivery   of messages despite failures to provide fault-tolerance (the same messages are delivered to all available sites making it is easy for the surviving system to decide on the commit/abort of pending transactions). Our approach provides atomicity and the same isolation level in regard to concurrency control than the underlying PostgreSQL system (snapshot isolation). Furthermore, its performance is excellent. For update transactions, it adds an overhead of a few milliseconds in order to propagate changes to all replicas. By adding new replicas to the system, the read load can be distributed leading to excellent scalability. Postgres-R uses the Spread group communication system. The product uses software developed by Spread Concepts LLC for use in the Spread toolkit. For more information about Spread see http://www.spread.or.g The current status and project related to Postgres-R are as follows. Postgres-R for Snapshot Isolation:  Our first prototype of Postgres-R in 2000 was  based PostgreSQL 6.4. PostgreSQL 6.4 uses 2-phase-locking as concurrency control protocol. In contrast, the current versions use  a multiversion concurrency control mechanism similar to the one on Oracle 8i providing the isolation level snapshot isolation. Our newest version Postgres-R(SI) works correctly with this concurrency control method providing exactly the same isolation level as a centralized version of PostgreSQL. Recovery: An essential aspect of cluster databases is the need to allow failed nodes to recover and rejoin the system without interruption of the ongoing transaction processing on the available nodes (denoted as online recovery). In particular, before a joining site can execute transactions, an up-to-date peer site has to provide the current state of the data to the joining site. We have developed online-recovery solutions and integrated them into our Postgres-R prototype. One solution transfers the entire database state to the joining replica, the other only sends the changes that were performed during the downtime of the rejoined site. With the means of heuristics, the system automatically chooses the recovery strategy that is expected to take less time depending on the database size and the changes the joining site needs to install. Client transparency:  So far,  a client has to know the address of a replica and must directly connect to this replica. When the replica fails, it receives the typical error message, and has to connect to another replica. We are planning to generate an automatic failover component. For instance, the JDBC driver could be extended with the following features. While the client sees a generic database name, the JDBC driver can retrieve a configuration file that provides the addresses of the individual replicas behind the database. Then it can connect to any (allowing possibly for some load-balancing features). When the client the driver is connected to crashes, the driver can automatically connect to another replica without the client being aware of it. Collaboration Part of the work of both projects has been performed in the context of the  Adapt project (Middleware Technologies for Adaptive and Composable Distributed Components). Adapt was a RTD project funded by the Information Sociaty Technologies Programme of the European Commision under FP5, and the Programme de soutien à la recherche (PSR) of the Ministère du Développement économique, de l'innovation et de l'exportation (MDEIE) du Québec, Canada.docContentEnd
46docContentStartLaboratory Information Management Multi-tier architectures have become the prevalent building block to develop laboratory information management systems (LIMS). The increasing prevalence of automated experimental techniques has allowed life-science researchers to dramatically increase the amount of data processed over the course of a typical scientific experiment. Such large volumes of data must be reliably stored, and processed for monitoring and data mining purposes. Therefore, many research groups maintain LIMS that keep track of the experiments conducted, record which ingredients and instruments are used, and any observations and results achieved. Our research group has been working with two bioinformatics groups at the NRC (Macromolecular Structure Group at Biotechnology Research Center) and McGill (Biomedical Engineering, Center for Bioinformatics) in order to better understand the open problems asscociated with LIMS. From there, we have built Exp-DB, a framework for the development of LIMS. We put particular focus on access control and workflow support. As the groups collaborate with each other, they want to give their partners access to their LIMS, however, with very specific restrictions. We have developed a fine-grained access control mechanism based on role-based access control that allows the plug-in of arbitrary rules that can then be implemented in the form of programs. We use aspect-oriented programming which allows us to inject access control wherever it is needed in the application code without changing the code itself. Another open problem for life-science researchers is to appropriately control their scientific experiments and automatically link the data to be fed to and retrieved from their wet labs with the LIMS in place. Existing workflow management systems, however, are often very difficult to integrate with the existing LIMS infrastructure of the labs. Thus, we have developed a workflow management system that is loosely coupled with the LIMS via aspect-oriented programming. It observes whenever data is entered or changed and triggers the start of new experiments whenever needed. It can communicate with robots and external agents via a distributed infrastructure.docContentEnd
47docContentStartAdaptability in Multi-tier Information Systems Multi-tier architectures are now the standard for advanced information systems where clients make calls to the web-server (presentation tier), the business logic (shopping card, purchasing, browsing, etc.) is implemented and embedded in the application server tier, and the database tier stores all critical data. In the commercial world, J2EE, .NET, and CORBA are specifications for the middle-tiers of such multi-tier architectures. Application servers provide far reaching functionality and services that help in the development of information systems. Important services are various communication mechanisms (remote procedure calls, messaging systems, persistent queues, etc.), transaction management, security, access control, persistence, and many more. The fact that application servers introduce an additional layer of complexity, and that both web and application servers use a wide range of new technology leaves us with many challenging problems. Our research looks at several issues in regard to such multi-tier architectures: Detecting and analyzing consistency anomalies: Transactional multi-tier architectures as well as cloud data stores offer several levels of isolation providing a trade-off between performance and consistency. While it is fairly well known how to identify qualitatively the anomalies that are possible under a certain isolation level, it is much more difficult to detect and quantify such anomalies during run-time of a given application. We have developed a new approach to detect and quantify consistency anomalies for arbitrary multi-tier application running under any isolation levels ensuring at least read-committed. In fact, the application can run even under a mixture of isolation levels. Our detection approach can be on-line or off-line and for each detected anomaly, we identify exactly the transactions and data items involved. Furthermore, we classify the detected anomalies into patterns showing the business methods involved as well as analyzing the types of cycles that occur. Our approach can help designers to either choose an isolation level where the anomalies do not occur or to change the transaction design to avoid the anomalies. Furthermore, we provide an option in which the occurrence of anomalies can be automatically reduced during runtime. To test the effectiveness and efficiency of our approach, we have conducted a set of experiments using a wide range of benchmarks. Caching: Middle-tier architectures widely exploit caching to avoid expensive access to the database backend. When replicating the middle-tier for better scalability, balancing the load across all servers and exploiting the full capacity of the cache becomes a challenge. While solutions exists that are able to not only retrieve data from the local cache but also from the remote caches of other servers, such accesses are considerably more time-consuming. In our research, we develop load-balancing and object-assignment policies that allow requests to be equally distributed across servers and objects assigned to caches that favour local cache hits. Our approach is application agnostic and dynamic: we continuously observe the request load and the objects that are accessed and generate new policies on the fly whenever the workload and access patterns change; no access to the source code of the application is needed to determine the access patterns.  We evaluate our approach using the RuBIS benchmark as well as a suite of micro-benchmarks showing how our approach significantly enhances system performance even with fluctuating workload patterns. Fault-Tolerance:   7/24 availability is crucial for many of these information systems. Hence, such systems must be able to handle the crash of individual components, e.g., the crash of the web-server, the applicatin server, or the database system. Ideally, such crash is transparent to the client, i.e., the client always receives exactly one response for each request it sends to the system. Furthermore, the crash of a component may not leave the system in an inconsistent state. Replication is widely used to provide such fault-tolerance. The idea is that servers are replicated and if one replica crashes the work assigned to this replica can failover to another replica. In principle, each tier can be replicated. We have several projects on  database replication . Furthermore, we have developed replication strategies for application servers. Our work in this area consists of several parts: Since an application server is not the last component in the multi-tier architecture but makes calls to the database backend-tier, any solution for application server replication must take the interaction between application server and database system, and the behavior of the database system into account. We analyze what interaction patterns exist between these components. In particular, we look at transaction management, and how the actions of transactions can affect both application server and database system. We have to define what correctness means. This must be done from the perspective of the client, e.g., that he/she always receives an appropriate response to a request, and from the perspective of the application server and database system, e.g., the state they maintain should be consistent. Based on the model and the correctness criteria we have developed algorithms that provide fault-tolerance in an efficient manner. Requests are executed by a primary server, and state changes are propagated to backup servers which can take over if the primary crashes. Execution at the clients, the primary, and the backups is carefully coordinated to provide the degree of correctness that is required. We have implemented our algorithms witin a concrete application server architecture, namely the J2EE specification. Our replication tool is open-source and can be accessed via  SourceForge . Load Balancing : Replication cannot only be used for fault-tolerance. Since the work to be performed at backups is not as time consuming as the work at the primary, the backups can be primary servers for other clients. Hence, by adding new server replicas to the system we are able to handle more client requests. There are two main issues to handle. First, how to distribute clients over the server to optimally distribute the load. The second is how to maintain the system if replicas leave the system due to crashes or necessary maintenance, or join the system after recovery or as new replicas in order to increase system capacity. Such system configurations have to be performed in a transparent manner without interrupting ongoing processing in the system. Fault-tolerance across the entire system:  Even if each individual tier provides fault-tolerance mechanisms, e.g., through replication, it is not clear that the server system in its entirety provides fault-tolerance and correctness. We have analyzed how we can reason about the correctness of the entire system given fault-tolerant properties of the individual tiers. From there, we have derived interaction patterns that guarantee system-wide fault-tolerance.docContentEnd
48docContentStartMcXML: A native XML Data Management System McXML is a  native XML database system with a focus on supporting updates and transaction management: Query Execution: McXML has as main logical data model a tree based main-memory structure that provides the DOM interface. Hence, any XQuery execution engine based on DOM can be plugged into McXML. Furthermore, McXML has its own query execution engine. This engine supports as a subset of the XQuery langauge and a set of XQuery update statements that were proposed as an extension to XQuery.  The current execution engine uses standard DOM navigation with some extra index structures. McXML provides full transaction management and concurrency control . Storage Manager: McXML has a page-based storage manager. XML documents are split into subtrees which are stored in records  placed on fixed-width pages. Pages are the basic unit for transfer between disk and main memory.  Loading is done in a lazily, i.e., records are only loaded into memory and the corresponding subtree (DOM model) extracted when a query might need to access this part of the tree. When updates change the logical tree model, only the changed parts of the tree are written back to disk. That is, only the pages with records that contain chainged subtrees are written back to disk. Transaction Manager: McXML has a full-fledged transaction management in place. Several queries can be bundled to a transaction. All changes performed by a transaction are written back to disk at commit time. If a transaction aborts, its changes are automatically undone. McXML offers two snapshot based concurrency control methods, one providing optimistic concurrency control, the other a multi-version concurrency control providing snapshot isolation. Additionally, a hierarchical locking scheme is implemented.docContentEnd
49docContentStartMaya Summer 2012 March 2010 Spring 2009 February 2008 August 2007 September 2006 February 2006 September 2005 August 2005docContentEnd
50docContentStartCOMP-512: Distributed Systems (Fall 2013) Names and Numbers: Lecture : Tuesday/Thursday 11:30-13:00 Instructor : Bettina Kemme. Office McConnell 109N. e-mail: kemme@cs.mcgill.ca Office Hours Instructor : Tuesday/Thursday after class, by appointment Teaching Assistants:   Yousuf Ahmad and Omar Asad Overview: Access to computing resources anywhere/anytime has become realitiy. We upload our documents to the cloud, play games onlines and make phone calls via the Internet. Companies use cloud providers to provide them not only Infrastructure as a Service (IaaS) but complete distributed Platforms as a Service (PaaS). Distributed multi-tier architectures for web-service and business applications are omni-present. Building such complex distributed infrastructures faces many challenges: communication, asynchronous behavior of the different components in the system, architectural considerations, failures etc. Over the last 20 years many fundamental building blocks have been developed that build the backbone of current distributed infrastructure. These building blocks are the main focus of this course. The objective is to learn the state-of-the-art of practical distributed systems, to understand the typical problems and challenges encountered in distributed environments, and to discuss both sound and practical solutions for them. Topics that will likely be covered Overview Communication Paradigmms basic network protocols synchronous and asynchronous communication client / server communication basics RMI: remote method invocation group communication publish subscribe ... synchronization physical and logical clocks distributed transactions and concurrency control fault-tolerance replication agreement protocols scalability replication and caching load balancing scalable data storage (NoSQL) distributed computation (map-reduce) Performance (how to measure it and how to understand the results) Flavor of the course The objective is to understand the typical problems encountered in distributed environments and develop solutions for them.  For each topic, we will first look at the foundations, develop some basic algorithms, and then look how the issues are handled in real systems. Of course, the course will not cover all interesting topics in this area. But it should enable you to recognize the fundamental issues in distributed systems and to apply the aproaches and mechanisms discussed in class to any kind of distributed environment. You will work both theoretically and practically. The course will have written assignments in which you develop algorithms and analyze different solutions to specific problems. Furthermore, there will be a considerable programming project. Overall, this course should be interesting for you if you are keen on jobs like this one posted by Amazon Prerequisites: COMP-251 and COMP-310 (or equivalent). Knowledge of computer network principles will be very useful, but a networks course is not a pre-requisite Marking Scheme 18% written assignments 35% programming project 12% midterm 35% final exam Recommended Textbook: Distributed Systems: Concepts and Design by G. Coulouris, J. Dollimore, T. Kindberg and G. Blair. Addison-Wesley, 5th ed. A note on academic integrity McGill University values academic integrity.  Therefore all students must understand the meaning and consequences of cheating, plagiarism and other academic offences under the Code of Student Conduct and Disciplinary Procedures (see http://www.mcgill.ca/students/srr/honest/   for more information). French/English In accord with McGill University's Charter of Students' Rights, students in this course have the right to submit in English or in French any written work that is to be graded.docContentEnd
51docContentStartCOMP-421: Database Systems Names and Numbers: Lecture : Tu/Th 11:25 AM -12:55 PM, Rutherford Physics Building 112 Instructor :  Bettina Kemme Office Hours Instructor :after class and by appointment Outline With the raise of e-commerce all of us use complex information systems on a daily basis -- by accessing the Minerva university system, by banking online, by buying a book online. Database management systems (DBMS) build the backbone software systems that store all mission-critical data of these information systems. The big DBMS vendors like Oracle, IBM (DB2) or Microsoft (SQL Server) are well known players on the IT market; Linux distributions (for instance Red Hat), include an open source database management system in their distribution package; even the Microsoft Office suite contains kind of a database management system. And recently, the NoSQL movement has shown that data management has become important in many new domains and markets. As a result, knowing at least the basic concepts behind these systems and how to use them is becoming an essential skill for IT specialists. This course is intended to give students a solid background in relational DBMS. Furthermore is outlines non-relational solutions. If you are interested in becoming an effective user of a DBMS, or a DBMS professional, this is a good introduction to the topic. The course has two main parts: the first part explains   how to use   a DBMS, the second part looks at   how the DBMS works internally  . The first part will discuss the   design of databases   and how to write   queries   that extract the data you are looking for. Or in other words: how can you squeeze your "real world" data (the product information of a bookstore, the student and activity information of a students' association) into the relational data model of the database system and how can you retrieve the data later. The second part of the course is system-oriented and discusses the internals of a DBMS. Using a DBMS is one issue, using it efficiently and correctly is a different story. DBMS are designed to work for very different application areas and present a general purpose software. In order to be able to tune a DBMS to your specific requirements you must know how your database application is executed by the DBMS. This second part will cover two main areas:   Transaction management   is important to keep data consistent when updates occur.   Query execution is the process that efficiently finds the small set of data the user wants to see out of a possibly huge database. At the end of the course we will talk about non-relational (NoSQL) data models and their: semi-structured data that is better able to handle document-type data and key-value stores that are better able to store and query huge amount of data in a distributed fashion. Objectives: In this course you will learn the fundamental steps needed to develop a database application using a commercial DBMS apply this knowledge to build a database application for a specific application domain acquire the skills to quickly learn and understand new data models and DBMS interfaces understand some of the internals of a relational DBMS, and with that, get to know the structure and complexity of a large software system see how knowing about the internals of the DBMS can help you improve your usage of a DBMS as an application programmer get an understanding of performance in a DBMS conduct a relatively large scale project in a team Detailed Topic List   (each topic between 2 and 4 lectures): Introduction Entity-Relationship Model Relational Model and Data Definition Language Relational Algebra Functional Dependencies SQL I: Simple Queries SQL II: Advanced Queries SQL III: Constraints and Triggers SQL V: Application Programming Transactions Concurrency Control Essentials of File and Disk Management Recovery Indexing Query Execution Semi-structured data (XML, JSon) Key-value stores and map-reduce Review Prerequisites:  COMP-206, COMP-251 and COMP-302: Knowledge of data structures, algorithms, programming languages and basics of program development. Knowledge in operating systems is of advantage. Marking Scheme:  There are 4 written assignments, three project deliveries, one midterm, and one final. The scheme will be 16% assignments (4% for each assignment) 15% project deliveries (5% for each deliverable) 10% midterm 59% final In assignments the students have to solve concrete problems. In some cases, late turn-in might not be possible (e.g., if I want to post the solution before the midterm/final). Otherwise, a late turn-in will result in a penalty of 10% per day (e.g. if an assignment has in total 100 points, a student achieves 80 points but turns in the assignment a day too late, then he/she will receive 80-10=70 points. The assignments count 4% each. The last assignment might be done in groups of several students. This still has to be determined. The three programming deliveries build a project in which students have to develope and build database application for a real-world domain. The students will design a schema, create a database using DB2, maintain, query and update the data, and develop a application programs. The students will work in teams of three on the programming project. All team members are supposed to work together and participate equally in the project development. Course Book: Raghu Ramakrishnan and Johannes Gehrke: Database Management Systems; McGraw Hill, 3rd Edition, 2003. Alternative Literature Abraham Silberschatz, Henry F. Korth and S. Sudarshan: Database System Concepts; McGraw Hill, 5th Edition, 2006. Hector Garcia-Molina, Jeffrey D. Ullman and Jennifer Widom: Database systems : the complete book; Prentice Hall, 2002. A note on academic integrity McGill University values academic integrity.  Therefore all students must understand the meaning and consequences of cheating, plagiarism and other academic offences under the Code of Student Conduct and Disciplinary Procedures (see http://www.mcgill.ca/integrity/   for more information). French/English In accord with McGill University's Charter of Students' Rights, students in this course have the right to submit in English or in French any written work that is to be graded.docContentEnd
52docContentStartBettina Kemme, School of Computer Science, McGill University Publications Book   Refereed Publications Technical Reports Thesis Book Database Replication . B. Kemme, R. Jimnez-Peris, M.Patio-Martnez. Synthesis Lectures on Data Management. Morgan & Claypool Publishers. 2010 Refereed Publications (Journals, Conferences, Workshops, Book Chapters) 2010 Database Replication: A Tutorial. B. Kemme, R. Jimnez-Peris, M.Patio-Martnez, G. Alonso. Chapter of the book “Replication: Theory and Practice”, LNCS 5959, pp. 219-250, B. Charron-Bost, F. Pedone, A. Schiper (eds). Springer 2010. SMS based Group Communication Systems for Mobile Devices. Ch. Seeger, B. Kemme and H. Wu. International ACM Workshop on Data Engineering for Wireless and Mobile Access, 10 pages, June 2010. 2009 A System of Architectural Patterns for Scalable, Consistent and Highly Available Multi-Tier Service Oriented Infrastructure. R. Jimnez-Peris, M.Patio-Martnez, B. Kemme, F. Perez-Sorrosal, D. Serrano. Chapter of the book “Architecting Dependable Systems. Volume 6.”. LNCS 5835. pp. 1-23. R. de Lemos, J-C. Fabre, C. Gacek, F. Gadducci, M. ter Beek (eds). Springer. Replicated Database Concurrency Control (Definitional Entry). Bettina Kemme. In Encyclopedia of Database Systems, pp. 2390-2391, Springer. Data Replication (Regular Entry). Bettina Kemme. In Encyclopedia of Database Systems, pp. 2390-2391, Springer. Traditional Concurrency Control for Replicated Databases (Regular Entry). Bettina Kemme. In Encyclopedia of Database Systems, pp. 3144-3149, Springer. Replication for High Availability (Regular Entry). Bettina Kemme. In Encyclopedia of Database Systems, pp. 2397-2402, Springer. Eventual Consistency (Definitional Entry). Marc Shapiro and Bettina Kemme. In Encyclopedia of Database Systems, pp. 1071-1072, Springer. Partial Replication (Definitional Entry). Bettina Kemme. In Encyclopedia of Database Systems, pp. 2045-2046, Springer. One-Copy-Serializability (Definitional Entry). Bettina Kemme. In Encyclopedia of Database Systems, pp. 1947-1948, Springer. Snapshot Isolation and Integrity Constraints in Replicated Databases. Y. Lin, B. Kemme, R. Jimnez-Peris, M.Patio-Martnez and J. Enrique Armendariz-Iigo. ACM Transactions on Database Systems, Volume 34, No. 2, 2009. pp. 11:1-49. A Highly Robust P2P-CDN under Large-Scale and Dynamic Participation. M. El Dick, E. Pacitti and B. Kemme. In Proc. of Int. Conference on Advances in P2P Systems (AP2PS), pp. 180-185, October 2009. A Unified Framework for Load Distribution and Fault-Tolerance of Application Servers. H. Wu and B. Kemme. In Proc. of Euro-Par, pp. 178-190, August 2009. Mammoth: a massively multiplayer game research framework. J. Kienzle, C. Verbrugge, B. Kemme, A. Denault, M. Hawker. In Proc. of Int. Conference on Foundations of Digital Game (FDG), pp. 308-315, April 2009. M. El Dick, E. Pacitti and B. Kemme. Flower-CDN: A hybrid P2P overlay for Efficient Query Processing in CDN. In Proc. of Int. Conference on Extending Database Technology (EDBT), pp. 427-438, March 2009. 2008 Maintaining Replicas in Unstructured P2P Systems   Ch. Leng, W. Terpstra, B. Kemme, A. Buchmann. ACM CoNEXT, December 2008. An Autonomic Approach for Replication of Internet-based Services.   D. Serrano, M.Patio-Martnez, R. Jimnez-Peris, B. Kemme. IEEE Symp. on Reliable Distributed Systems (SRDS), Oct. 2008. Area-Based Gossip Multicast  . Ch. Seeger, B. Kemme, P. Kabus, A. Buchmann. Workshop on Network and Systems Support for Games (NetGames), October 2008. Persistence in Massively Multiplayer Online Games  . K. Zhang, B. Kemme, A. Denault. Workshop on Network and Systems Support for Games (NetGames), October 2008. pSense - Maintaining a Dynamic Localized Peer-to-Peer Structure for Position Based Multicast in Games. A. Schmieg, M. Stieler, S. Jeckel, P. Kabus, B. Kemme, A. P. Buchmann, Int. Conf. on Peer-to-Peer-Computing, IEEE Computer Society, September 2008. Showing Correctness of a Replication Algorithm in a Component based System.   H. Wu, B. Kemme.  IDEAS Conf., September 2008. Replication in Service Oriented Architectures.   M. Ameling, M. Roy, B. Kemme. Int. Conf. on Software and Data Technologies. July 2008. Online Recovery in Cluster Databases.   W. Liang, B. Kemme.  Int. Conf. on Extending Database Technology (EDBT), March 2008. 2007 Enterprise Grids: Challenges Ahead.   R. Jimnez-Peris, M.Patio-Martnez, B. Kemme. Journal of Grid Computing. Volume 5, No. 3, pp. 283-294, 2007. Exploiting Reflection to Enable Scalable and Performance Database Replication at the Middleware Level. J. Salas, R. Jimnez-Peris, M.Patio-Martnez, B. Kemme. Chapter of the book Software Engineering and Fault Tolerance. P. Pelliccione, H. Muccini, N. Gueli, A. Romanovsky (eds). 2007. ISBN 978-981-270-503-7. World Scientific. Boosting Database Replication Scalability through Partial Replication and 1-Copy-Snapshot-Isolation. D. Serrano, M.Patio-Martnez, R. Jimnez-Peris, B. Kemme. IEEE Pacific Rim Int. Symp. on Dependable Computing (PRDC), Dec. 2007. Consistent and Scalable Cache Replication for Multi-Tier J2EE Applications.   F. Perez-Sorrosal, M.Patio-Martnez, R. Jimnez-Peris, B. Kemme. ACM/IFIP/USENIX Int. Middleware Conf., Nov. 2007. Enhancing Edge Computing with Database Replication.   Y. Lin, B. Kemme, M.Patio-Martnez, R. Jimnez-Peris. IEEE Symp. on Reliable Distributed Systems (SRDS), October 2007. A Recovery Protocol for Middleware Replicated Databases Providing GSI. J. E. Armendriz-Iigo, F. D. Muoz-Esco, J. R. Jurez, J. R. Gonzlez de Mendvil, B. Kemme. IEEE Int. Conference on Availability, Reliability and Security (ARES), April 2007. 2006 Applying Database Repliation to Multi-player Online Games . Y. Lin, B. Kemme, M.Patio-Martnez, R. Jimnez-Peris. ACM Workshop on Network and Systems Support for Games (NetGames), Oct. 2006 Lightweight Reflection for Middleware-based Database Replication . J. Salas, R. Jimnez-Peris, M. Patio-Martnez, B. Kemme. IEEE Int. Symp. on Reliable Distributed Systems (SRDS), Leeds, England, Oct. 2006 Enterprise Grids: Challenges Ahead . R. Jimnez-Peris, M. Patio-Martnez, B. Kemme. Invited Paper corresponding to the keynote speech   at Int. Workshop on High-Performance Data Management in Grid Environments. co-located with VECPAR 7th Int. Conf. on High Performance Computing for Computational Science, July 2006. Exp-WF: Workflow Support for Laboratory Information Systems . B. Gabor, B. Kemme. IEEE Workshop on Workflow and Data Flow for Scientific Applications (SciFlow'06), co-located with Int. Conf. on Data Engineering, Atlanta, Georgia, April 2006. Don't be a Pessimist: Use Snapshot based Concurrency Control for XML . (Short Paper).  Z. Sardar, B. Kemme. IEEE Int. Conf. on Data Engineering (ICDE), Atlanta, Georgia, April 2006. Data mining using relational database management systems . B. Zou, X. Ma, B. Kemme, G. Newton, D. Precup. Pacific-Asia Conference on Knowledge Discovery and Data Mining (PAKDD), Singapore, April 2006. 2005 Consistent Database Replication at the Middleware Level . M. Patio-Martnez, R. Jimnez-Peris, B. Kemme, G. Alonso. ACM Transactions on Computer Systems (TOCS). Volume 23, No. 4, 2005, pp 1-49. A Replication Toolkit for J2EE Application Servers.   H. Wu, B. Kemme, A. Bartoli and S. Patarin.  Software Demonstration at the ACM/IFIP/USENIX Conf. on Middleware, Grenoble, France, December 2005. Fault-tolerance for Stateful Application Servers in the Presence of Advanced Transactions Patterns . H. Wu, B. Kemme. Proc. of the IEEE Symp. on Reliable Distributed Systems (SRDS), Orlando, Florida, October 2005. The ADAPT Framework for Adaptable and Composable Web Services . A. Bartoli, R. Jimnez-Peris, B. Kemme, C. Pautasso, S. Patarin, S. Wheater and S. Woodman. IEEE Distributed Systems Online - Web Systems Section. Invited Paper. Sept. 2005. Exactly-Once Interaction in a Multi-tier Architecture . B. Kemme, M. Patio-Martnez, R. Jimnez-Peris, J. Salas. VLDB Workshop on Design, Implementation, and Deployment of Database Replication, Trondheim, Norway, August 2005. Consistent Data Replication: Is it feasible in WANs?  Y. Lin, B. Kemme, M. Patio-Martnez, R. Jimnez-Peris. Europar Conf., Lisbon (Portugal), August 2005. Fine-Granularity Access Control in 3-tier Laboratory Information Systems . X. Li, N. A. Naee, B. Kemme. IDEAS Conf. Montreal, Canada, July 2005. Middleware based Data Replication providing Snapshot Isolation . Y. Lin, B. Kemme, M. Patio-Martnez, R. Jimnez-Peris. ACM Int. Conf. on Management of Data (SIGMOD), Baltimore, Maryland, June 2005. ADAPT: Middleware Technologies for Adaptive and Composable Distributed Components.  A. Bartoli, R. Jimnez-Peris, B. Kemme, C. Pautasso, S. Patarin, S. Weater, S. Woodman. Europ. Dependable Computing Conference (EDCC), Project Track, April 2005. Postgres-R(SI): Combining Replica Control with Concurrency Control based on Snapshot Isolation.  S. Wu, B. Kemme. IEEE Int. Conference on Data Engineering (ICDE), Tokyo, Japan, April 2005. 2004 Eager Replication for Stateful J2EE Servers . H. Wu, B. Kemme, V. Maverick. Int. Symposium on Distributed Objects and Applications (DOA), Agia Napa, Cyprus, October 2004. Adaptive Middleware for Data Replication . J. M. Milan-Franco, R. Jimnez-Peris, M. Patio-Martnez, B. Kemme. ACM/IFIP/USENIX Conference on Middleware, Toronto, Canada, October 2004. Comparison of UDDI Registry Replication Strategies . C. Sun, Y. Lin,  B. Kemme. IEEE Int. Conference on Web Services (ICWS), San Diego, California, July 2004. 2003 Exp-DB: Fast Development of Information Systems for Experiment Tracking . N. A. Naeem, S. Raymond, A. Poupon, M. Cygler, B. Kemme. Conference on Advanced Information Systems Engineering (CAiSE '03), Klagenfurt/Velden, Austria, June, 2003, CAiSE Forum, Short Paper Proceedings. Database Replication Based on Group Communication: Implementation Issues . Future Directions in Distributed Computing (FuDiCo), Research and Position Papers. Lecture Notes in Computer Science 2584 Springer 2003. Are quorums an alternative for data replication?  R. Jimnez-Peris, M. Patio-Martnez, G. Alonso, B. Kemme.  ACM Transactions on Database Systems (TODS) , Volume 28, No. 3, 2003, pp 257-294. Using Optimistic Atomic Broadcast in Transaction Processing Systems . B. Kemme, F. Pedone, G. Alonso, A. Schiper, M. Wiesmann. IEEE Transactions on Knowledge and Data Engineering, Volume 15, No. 4, 2003. pp. 1018-1032 2002 Improving the Scalability of Fault-Tolerant Database Clusters: Early Results.  R. Jimnez-Peris, M. Patio-Martnez, B. Kemme, G. Alonso. Proc. of the IEEE 22nd Int. Conf. on Distributed Computing Systems 2002, ICDCS'02. Vienna, Austria. July 2002. 2001 How to Select a Replication Protocol According to Scalability, Availability, and Communication Overhead. R. Jimnez-Peris, M. Patio-Martnez, G. Alonso, B. Kemme. Proc. of the 20th IEEE Int. Conf. on Reliable Distributed Systems, SRDS'01, New Orleans, Oct. 2001 Online Reconfiguration in Replicated Databases Based on Group Communication  B. Kemme, A. Bartoli, O. Babaouglu. Proc. of the IEEE International Conference on Dependable Systems and Networks (DSN 2001), Goteborg, Sweden, June 2001. 2000 and earlier Database Replication Techniques: a Three Parameter Classification  M. Wiesmann, F. Pedone, A. Schiper, B. Kemme, G. Alonso. Proc. of the 19th IEEE Symposium on Reliable Distributed Systems (SRDS2000), Nrnberg, Germany, October 2000. Scalable Replication in Database Cluster . M. Patio-Martnez, R. Jimnez-Peris, B. Kemme, G. Alonso. Proc. of the 14th International Symposium on Distributed Computing (DISC), Toledo, Spain, October 2000. Don't be lazy, be consistent: Postgres-R, a new way to implement Database Replication . B. Kemme, G. Alonso. Proc. of 26th International Conference on Very Large Databases (VLDB), Cairo, Egypt, September 2000. A New Approach to Developing and Implementing Eager Database Replication Protocols . B. Kemme, G. Alonso.  ACM Transactions on Database Systems (TODS) , Volume 25, No. 3, September 2000, pp 333-379. Understanding Replication in Databases and Distributed Systems.  M. Wiesmann, F. Pedone, A. Schiper, B. Kemme, G. Alonso. Proc. of the IEEE 20th International Conference on Distributed Computing Systems (ICDCS), Taipei, Taiwan, Republic of China, April 2000. Processing Transactions over Optimistic Atomic Broadcast Protocols.  B. Kemme, F. Pedone, G. Alonso, A. Schiper. Proc. of the IEEE 19th International Conference on Distributed Computing Systems (ICDCS), Austin, Texas, June 1999. Transactions, Messages and Events: Merging Group Communication and Database Systems. B. Kemme, G. Alonso. Proc. of the 3rd ERSADS European Research Seminar on Advances in Distributed Systems, Madeira Island, Portugal, April 1999. A Suite of Database Replication Protocols based on Group Communication Primitives. B. Kemme, G. Alonso. Proc. of the IEEE 18th International Conference on Distributed Computing Systems (ICDCS), Amsterdam, The Netherlands, May 1998. Technical reports and unrefereed publications Don't be a Pessimist: use Snapshot based Concurrency Control for XML.  Z. Sardar, B. Kemme. Technical Report SOCS-TR-2005.6, School of Computer Science, McGill University. October 2005. Using Optimistic Atomic Broadcast in Transaction Processing Systems.  B. Kemme, F. Pedone, G. Alonso, A. Schiper. Technical Report No. 325, ETH Zrich, Departement of Computer Science, 1999. Database Replication based on Group Communication.  B. Kemme, G. Alonso. Technical Report No. 289, ETH Zrich, Departement of Computer Science, February 1998. Datenbankreplikation unter Verwendung von Gruppenkommunikation.  B. Kemme. In: 9. Workshop "Grundlagen von Datenbanken", Knigslutter, Germany, May 1997. (In German). Aplicacin de la Lgica Temporal Proposicional para la Representacin y Ceduccin de Conocimientos Temporales B. Kemme, J. Borrego Daz. In: Actas del X. Congreso de Lenguajes Naturales y Lenguajes Formales. Sevilla, September 1994 (In Spanish). Thesis Database Replication for Clusters of Workstations.  B. Kemme. Dissertation (PhD thesis). Diss. ETH No. 13864, ETH Zrich, Departement of Computer Science, 2000. Bettina Kemme , 30-May-2001; Last Change: 30-May-2001docContentEnd
53docContentStartCoalgebras in Quantum Physics 15 - 19 March 2015, Bellairs Research Institute, Barbados Home Participants Practical Info Photos Group photo from the 2013 workshop: Designed by  Free CSS Templates , Thanks to  Custom Web DesigndocContentEnd
54docContentStartCoalgebras in Quantum Physics 15 - 19 March 2015, Bellairs Research Institute, Barbados Home Participants Practical Info Photos Coalgebras have emerged as a unifying formalism for understanding a variety of different types of dynamics.  From its inception it was understood as giving a coherent theoretical framework to the theory of transition systems and incorporating important concepts like bisimulation and modal logics to characterize process equivalences.  These ideas were applied successfully to a variety of different types of systems and most recently to quantum systems.  At this workshop we hope to gather some of the active participants in the theory of coalgebras and some of the active researchers in quantum mechanics in order to discuss recent developments and prospects. The workshop organizers are   Prakash Panangaden  and  Helle Hvid Hansen.  Attendance is by invitation only. The practice at these workshops has been to allow the speaker ample time to get to technical details.  There should be lots of opportunities for extensive discussions; we will not cram the schedule with lots of short talks.  The talks are given on primitive chalkboards.  Please do not prepare slides for a data projector or plastic transparencies. There will be a parallel workshop on Infinite State Systems organized by Joel Ouaknine. This workshop is part of the Veni project  Coalgebraic Models of Quantum Systems  funded by the  Netherlands Organisation for Scientific Research (NWO) . The project and workshop are sponsored by: Designed by  Free CSS Templates , Thanks to  Custom Web DesigndocContentEnd
55docContentStartCoalgebras in Quantum Physics 15 - 19 March 2015, Bellairs Research Institute, BarbadosdocContentEnd
56docContentStartCoalgebras in Quantum Physics 15 - 19 March 2015, Bellairs Research Institute, Barbados Home Participants Practical Info Photos Several people have been invited, their names will appear here once they confirm attendance. We have confirmations so far from: Robin Adams Costin Badescu Alexandru Baltag Kenta Cho Bob Coecke Tobias Fritz Robert Furber Helle Hvid Hansen Bart Jacobs Kohei Kishida Alessandra Palmigiano Prakash Panangaden Daniela Petrisan Mathys Rennela Alexandra Silva Sonja Smets Rob Spekkens Designed by  Free CSS Templates , Thanks to  Custom Web DesigndocContentEnd
58docContentStartI have three research areas: (a) probabilistic systems (b) logic and computation and (c) quantum information theory.  I work on approximation of continuous-state systems and associated metrics and logics. Lately I have been working on Stone duality for Markov processes and completeness theorems for Markovian logics. In logic and computation I am interested in security and modal logics for reasoning about information flow and in incorporating modalities into the programming language.  My main recent activity is using Stone-type dualities to minimize automata of various kinds.  I am also interested in Tannaka-type theorems for C* algebras. In quantum information theory I work on informatic phenomena in relativistic situations. Helle Hvid Hansen and I are organizing a workshop on Coalgebras in Quantum Physics at  Bellairs  in March 2015.  Joel Ouaknine is also organizing a parallel workshop on Infinite-state systems. The  editorial boards  on which I serve are accessible through  Links  above. Recent Publications Aproximating Markov processes by ...  (JACM) Fair reactive programming.  (POPL 2014) Algebra-coalgebra duality ...  (TOCL) Stone duality for Markov processes.  (LICS 2013) Strong completeness for Markovian logics.  (MFCS 2013) Quantum Communication in Rindler Spacetime.  (CMP) More Publications Recent Talks Duality tutorial at Oxford, May 2014: Stone ,   Gelfand, and   Pontryagin. Invited talk  at VMCAI, Jan 2014 Invited talk  at LICS, June 2013. Talk  at Benasque, Spain, June 2013. Talk  given at the Symposium to Honour Glynn Winskel. More Talks Recent Conferences and Workshops ICALP 2015 PC Member CSR 2015 PC Member ICTAC 2015 PC Member MFPS 2014 PC Member QPL 2014 PC Co-chair >  More Conferences E-mail: prakash@cs.mcgill.ca Office: McConnell ENGG North Wing 105 Office Phone: +1 514 3987074,FAX: 3983883 My postal address is   here ;  do not use my office number. Teaching :  COMP 330 Tu Th 11:30 - 1:00 Leacock 232 COMP 525: Tu Th 4:00 - 5:30 Trottier 2100 Office Hours: Tu Th 1:30 - 3:00. My Fall 2014 schedule   is here. Please check my Google cal link below.docContentEnd
59docContentStartHome  >  Curriculum VitaedocContentEnd
60docContentStartHome  >  Conferences and Workshops PC Member of the of the Tenth International Tbilisi Symposium on Language, Logic and Computation.  Gudauri, Georgia, September 2013. PC Member of the of the 5th Conference on Algebra and Coalgebra in Computer Science, CALCO 2013.  Warsaw, Poland, September 2013. PC Member of the of the 24th International Conference on Concurrency Theory, CONCUR 2013.  Buenos Aires, Argentina, August 2013. PC Member of the of the 29th International Conference on Mathematical Foundations of Programming Semantics.  New Orleans, USA, June 2013. PC Member of the of the 10th Workshop on Quantum Physics and Logic.  Barcelona, Spain, June 2013. Member of the external review committee of the 40th Annual ACM Symposium on Principles of Programming Languages (POPL). Rome, Italy, Jan 2013. PC member of the Turing Centenary Conference, Computability in Europe, CiE 2012, Cambridge, U.K., June 2012. PC member of the 8th International Workshop on Developments in Computational Models, a satellite workshop of CiE 2012, Cambridge, U.K., June 2012. PC member of the Twenty-eighth Conference on the Mathematical Foundations of Programming Semantics, Bath, U.K., June 2012. PC member of the Symposium in honour of Dexter Kozen's 60th birthday, Ithaca, USA, April 2012. PC member of the 11th International Workshop on Coalgebraic Methods in Computer Science, Talinn, Estonia, March-April 2012. PC member of the Eighth Workshop on Quantum Physics and Logic (QPL), Nijmegen, The Netherlands, Oct 2011. PC member of the Workshop on Quantum Physics meets TARK, Groningen, The Netherlands, July 2011. PC member of the The 38th International Colloquium on Automata, Languages and Programming, Zürich, Switzerland, July 2011. PC member of the 18th Workshop on Logic, Language, Information and Computation (WoLLIC 2011), Philadelphia, Pennsylvania, May 2011. PC member of the 27th Conference on the Mathematical Foundations of Programming Semantics, Pittsburgh, USA, May 2011. PC member of the 38th Annual ACM Symposium on Principles of Programming Languages (POPL) 2011.  Austin, USA, Jan 2011. PC co-chair of the FLoC Workshop on Developments in Computational Models, DCM 2010.  Edinburgh, Scotland, July 2010. PC member of the IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science, Chennai, India, December 2010. PC member of the 21st International Conference on Concurrency, CONCUR 2010. Paris, France; Sept 2010. PC member of the 19th EACSL Annual Conference on Computer Science Logic, Brno, Czech Republic, August 2010. PC co-chair of the FLoC Workshop on Developments in Computational Models, DCM 2010.  Edinburgh, Scotland, July 2010. PC member of the 26th Conference on the Mathematical Foundations of Programming Semantics, Ottawa, Canada, May 2010. Organizer of the Bellairs Workshop on Computational Modelling of Biological Systems. Barbados, Mar 16 - Mar 20 2009. Program committee member of the Twelfth International Conference on Foundations of Software Science and Computation Structures. March 22 to March 29, York, UK. Program committee member of the Twenty-fifth Conference on the Mathematical Foundations of Programming Semantics, April 3-7 2009, Oxford, UK. Program committee co-chair of the Sixth Workshop on Quantum Physics and Logic. April 8-9, 2009, Oxford, UK. Program committee member of the Twenty-Fourth Annual IEEE Symposium On Logic In Computer Science (LICS 2009), 11th-14th August 2009, Los Angeles, California, USA. Program committee member the Fifth Annual Conference on Computability in Europe, 19-24 July 2009, Heidelberg, Germany. Organizer of the Bellairs Workshop on Topological Quantum Computation and Quantum Information Theory. Barbados, Mar 17 - Mar 21 2008. Program committee member of FoSSaCS 2008: Eleventh International Conference on Foundations of Software Science and Computation Structures, March 29 - April 6, 2008, Budapest, Hungary. Program committee member of QAPL 2008 Budapest, Hungary, March 29-30. Program Committee co Chair of FICS 2008 The First International Conference on Foundations of Informatics, Computing and Software, Shanghai, China, June 2008. Program Committee co Chair of QPL-DCM 2008, joint workshop on Quantum Programming Languages and Development of Computational Models, affiliated with International Colloquium On Automata Languages And Programming, July 2008, Rejkavik, Iceland. Program Committee co Chair of SecCo 2008 Fourth International Workshop on Security Issues in Concurrency, affiliated with CONCUR 2008, Toronto Ontario, August 2008. Here is the web page of SecCo 2007. Program Committee co Chair of QEST 2008: September 2008, Saint Malo, France. Organizer of the  Bellairs Workshop on Mathematical Methods for Reasoning about Security  Mar 19 - Mar23 2007. Program Committee of the 2nd Conference on Algebra and Coalgebra in Computer Science August 20-24, 2007, Bergen, Norway. Program Committee of the 14th Workshop on Logic, Language, Information and Computation (WoLLIC'2007) Rio de Janeiro, Brazil, July 2-5, 2007 Program Committee of Structural Operational Semantics 2007 (SOS 2007), July 9, 2007, Wroclaw, Poland. Program Committee of 4th International Conference on the Quantitative Evaluation of SysTems (QEST) 2007 Edinburgh, Scotland, 16th-19th September 2007.docContentEnd
61docContentStartHome  >  Reasoning and Learning Lab A picture of some of the members of the RL Lab.docContentEnd
62docContentStartPrakash Panangaden's Pictures Group shot at the PrakashFest. Group shot of my coauthors at the PrakashFest. Group shot of my students, past and present, at the PrakashFest. Group shot of the over 60 club at the PrakashFest. With Samson at the PrakashFest. The three-headed monster guarding the door of the RL Lab. Artist's rendition of the three-headed monster. Combined group photo from the 2014 Bellairs Workshops. Group photo from the 2014 Bellairs Probability Workshop. Group photo from the 2014 Duality Bellairs Workshop. Group photo from the 2013 Bellairs Workshop. SOCS Christmas Party 14th December 2012. Group photo from the 2012 Bellairs Workshop. Invited talk at CALCO'09, Udine, Italy, Sept 2009. With Luke Ong and Georg Gottlob at the ICALP 2009 reception. Philippe Chaput giving a talk in Rhodes at ICALP'09. Giving a talk at the DCM workshop in Rhodes, July 2009. Settling a technical argument with Catuscia Palamidessi, July 2009. On the beach at Rhodes during ICALP'09, July 2009 in Rhodes. Group photo from the 2009 Bellairs workshop. Another group photo from the 2009 Bellairs workshop. Yet another group photo from the 2009 Bellairs workshop. With Alex Rabinovich at St. Malo, Sept 2008, during QEST/FORMATS. Hand waving argument during my invited PODC-CONCUR talk. At the CONCUR 2008 reception, Toronto August 2008. Giving an invited talk at CiE 2008 in Athens. Group photo from CiE 2008 in Athens. The Reasoning and Learning Laboratory. With a student at the graduation ceremony June 1999; holding Leo Yaffe award. Prakash and Laurie at the IIT reunion in Ithaca, New York, 2000. With my father and sister in Hyderabad; the back yard of my father's house. With Samson Abramsky and Peter Selinger in Lyon, France, June 2001. With Catuscia Palamidessi in Northern California, August 2005. At a Dagstuhl meeting. My collaborators on the one-way model: Ellie D'Hondt, Elham Kashefi and Vincent Danos, Christ Church College, Oxford, 2004 With Laurie and Jane on the beach at Bellairs, March 2006. With Keye Martin at Bellairs, March 2006. Lecture at the Winter School on Logic, IIT Kanpur 2008 Lecture at the Winter School on Logic, IIT Kanpur 2008 Lecture at the Winter School on Logic, IIT Kanpur 2008 Sophia Knight in a discussion with me, Caitlin and Catuscia in Paris. Prakash Panangaden on the roof of Block F Hall 5 IIT Kanpur 1973 with Ashok Menon and S. Jaishankar Prakash Panangaden about to take a shower: IIT Kanpur 1974docContentEnd
63docContentStartHome >  Editorial Boards Logical Methods in Computer Science (LMCS). Mathematical Structures in Computer Science. Journal of Logic and Algebraic Programming. Computability: The Journal of the CiE Association. Computers - an open access journal.docContentEnd
64docContentStartHome  >  Talks Slides from Presentations Spring School on Quantum Structures, May 2014. Tutorial on duality theory:   part 1 ,   part 2,    part 3. Invited talk  at VMCAI, Jan 2014, San Diego, on  Minimization via duality  (photos removed). Invited talk  at LICS 2013, New Orleans, on  Duality in Logic and Computation .  The pictures have been removed in order to make the file smaller and easier to download. Invited talk  at LICS 2013, New Orleans, on  Duality in Logic and Computation .  This version is 4.3 Meg; you may want to download the version above with the photographs removed. Talk given at the workshop on Causality in Quantum Theory, Benasque, Spain, on Reconstructing Spacetime Topology from Causal Structure, June 2013. Talk given at the Symposium to Honour Glynn Winskel for turning 30 (?) at the Computer Laboratory, Cambridge, June 2013. Talk given at Radboud University, Nijmegen on Stone Duality for Markov processes, May 2013. Talk given at University of Technology, Sydney, on Approximating LMPs by averaging, March 2013. Talk given at Macquarie University, Sydney, on Duality for Automata, March 2013. Talk given at a Dagstuhl workshop on Coalgebras, on Approximating Markov Processes by Averaging, October 2012. Talk given at McGill University to commemmorate the birth centenary of Alan Turing, August 2012. Talk given at the symposium for Dexter Kozen's 60th birthday celebration, April 2012. LI 2012 Week 4: Quantitative approaches. Tutorial on abstract Markov processes:   part 1 ,   part 2,    part 3. LICS 2011 Tutorial on semantics:   part 1 ,   part 2,    part 3. Duality talk given at Cambridge  (more expository than the one at Bath and Leicester) on 25th May 2011. Duality talk given at Leicester (13th May 2011) and Bath (19th May 2011). Talk on Games, Schedulers and Process Algebra given at ICE 2011 (June 2011) and at BCTCS 2011 (April 2011).  The   pdf version is over 20 Megs  but the   powerpoint version is much smaller. Invited talk at QAPL 2011, Saarbrucken, 1st April 2011.   These slides are not the ones I used at the talk but are very similar.  They were prepared by Pablo Castro for his talks and are more detailed than mine were. Invited talk at FOSSACS 2011, Saarbrucken, 28th March 2011. Oxford Oasis seminar on Quantum Communication in Rindler Spacetime, 15th Oct 2010. Imperial College Logic seminar on Duality for Probabilistic Automata, 20th Oct 2010. Part 1 of a Tutorial on Markov Chains and Markov Processes  at the SFM-10 Summer School in Bertinoro, Italy, 21st June 2010.   Part 2.    Part 3. Modular tensor categories and topological quantum computing , a tutorial at the QICS school, Oxford, May 2010.    Powerpoint version. Overview of Verification Tutorial Series  at Mathematical Foundations Of Programming Semantics XXVI, Ottawa, Canada, May 2010. Black Holes and Information   Talk at the Workshop on Informatic Phenomena, New Orleans, Oct 2009. Approximating Markov Processes, Again!  , invited talk at the Conference on Algebra and Coalgebra in Computer Science, Udine, Italy, Sept 2009. Topological Quantum Computing invited talk at the workshop on Development of Computational Models (DCM), Rhodes, Greece, July 2009. Discrete Quantum Causal Evolution    at the Workshop on Categories, Quanta and Concepts at the Perimeter Institute, Waterloo, June 2009. Proof nets as formal Feynman diagrams  at the Workshop on Quantum Logic Inspired by Quantum Computation, Bloomington, May 2009. Tutorial on Feynman Diagrams  at the Twenty-fifth Symposium on Mathematical Foundations of Programming Semantics Oxford, April 2009. Talk from Workshop on Informatic Phenomena, New Orleans, October 2008. Joint CONCUR - PODC plenary talk, Toronto, 21 August 2008. Invited talk at the Workshop on Approximate Behavioural Equivalences, Toronto, 18 August 2008. Invited talk at Computability in Europe, Athens, 19 June 2008. Tutorial on Information Theory and Security, Canada-France Conference on Security, June 2nd 2008. Tutorial on Information Theory and Security, Canada-France Conference on Security. Powerpoint version. Talk at Mathematical Foundations Of Programming Semantics 2008. Talk at Cornell Theory Seminar, April 22nd, 2008. Colloquium Talk at CUNY, Computer Science Department, April 17th, 2008. Invited talk at the Clifford Lectures, Tulane University, March 13th 2008.docContentEnd
65docContentStartHome  >  Students Current Graduate Students and Undergraduate Project Students PhD Students Ausar Farooqi; joint with Niky Kamran (Mathematics) Gheorghe Comanici; joint with Doina Precup Andie Sigler; joint with Doina Precup Adam Bognaut; joint with Robert Brandenberger (Physics) Maziar Gomkorochi MSc Students Artem Kaznatcheev; joint with Doina Precup Costin Badescu Undergraduate Students Hang Lu Su Shanshan RuandocContentEnd
66docContentStartdocContentEnd
67docContentStartHome  >  Teaching Teaching COMP 330 Theory of Computation COMP 525 Formal VerificationdocContentEnd
68docContentStartHome  >  Publications selected publications Errata   for my chapter   Probabilistic Bisimulation , Chapter 7 in the book,   Advanced Topics in Bisimulation and Coinduction ed. by Sangiorgi and Rutten. Informal notes on category theory. A short proof that parallel convergence tester cannot implement parallel or. A short paper showing that amb has no fixed point semantics. A short paper showing that amb cannot be monotone in the Smyth or Plotkin sense.   Mainly due to Paul B. Levy and Soren Lassen.docContentEnd
69docContentStartHome  >  Publications   > Selected Publications Working Papers Learning in a changing world via algebraic modal logic  by Prakash Panangaden and Mehrnoosh Sadrzadeh. Old Papers from before 1999 Concurrent common knowledge; appeared in Distributed Computing in 1992. Accepted or Published Papers by Year 2014docContentEnd
70docContentStartWinter 2013 ⬢ COMP-361 - Software Engineering Project Fall 2013 ⬢ COMP-533 - Object-Oriented Software Development ⬢ COMP-361 - Software Engineering Project Winter 2013 ⬢ COMP-202 - Introduction to Computing I Fall 2012 ⬢ COMP-533 - Object-Oriented Software Development Winter 2012 ⬢ COMP-667 - Software Fault Tolerance Fall 2011 ⬢ COMP-202 - Introduction to Computing I Winter 2011 ⬢ COMP-361 - Systems Engineering Project Fall 2010 ⬢ COMP-533 - Object-Oriented Software Development ⬢ COMP-361 - Software Engineering Project Winter 2010 ⬢ COMP-361 - Systems Development Project Fall 2009 ⬢ COMP-667 - Software Fault Tolerance Winter 2008 ⬢ COMP-202 - Introduction to Computing I ⬢ COMP-361 - Systems Development Project Fall 2007 ⬢ COMP-667 - Software Fault Tolerance ⬢ COMP-321 - Programming Challenges Winter 2007 ⬢ COMP-361 - Systems Development Project Fall 2006 ⬢ COMP-667 - Software Fault Tolerance ⬢ COMP-553 - Object-Oriented Software Development Winter 2006 ⬢ COMP-361 - Systems Development Project Fall 2005 ⬢ COMP-667 - Software Fault Tolerance ⬢ COMP-553 - Object-Oriented Software Development Winter 2005 ⬢ COMP-361 - Systems Development Project Fall 2004 ⬢ COMP-667 - Software Fault Tolerance ⬢ COMP-553 - Object-Oriented Software Development Winter 2004 ⬢ COMP-361 - Systems Development Project Fall 2003 ⬢ COMP-667 - Software Fault Tolerance ⬢ COMP-553 - Object-Oriented Software Development Winter 2003 ⬢ COMP-746 - Advanced Topics SystemsdocContentEnd
71docContentStartMy research is concentrated on dependable software development and aspect-orientation. In particular, I focus on integrating the concerns of dependability and fault tolerance into the entire software development life cycle. One of my side projects is to apply our research ideas in the context of massively multiplayer games. Dependability-focused Requirements Engineering At the requirements level, discovering and documenting all possible abnormal situations and irregular user behavior that can interrupt normal system interaction is of tremendous importance in the context of dependable system development. We defined a Dependability-focused Requirements Engineering Process (DREP) based on use cases that leads a developer to discover and then specify the required level of system reliability and safety at an early stage. Our Sexceptional use cases can be probabilistically analyzed to get feedback on the achievable safety and reliability of the system, if it were to be built with a given set of (potentially failing) components. To read more about DREP, click  here . Open Multithreaded Transactions Open Multithreaded Transactions (OMTT) are an advanced transaction model that provides features for controlling and structuring not only access to objects, as usual in transaction systems, but also threads taking part in transactions. Due to the isolation property and disciplined exception handling, OMTTs constitute ideal units of fault tolerance for structuring the execution of loosely coupled cooperative and competitive concurrent systems. To read more about OMTTs, click  here . AspectOPTIMA - Aspect-orientated Implementation of Fault Tolerance Aspect-oriented programming is a new programming paradigm that allows a programmer to modularize cross-cutting concerns at the programming language level. With AspectO ptima  we present a design of an aspect-oriented framework that implements the transaction run-time support. We show how the ACID properties for transactional objects and transaction life cycle management for advanced transaction models can be implemented by a set of individually reusable aspects. To read more about the design of AspectO ptima  and its implementation in AspectJ click  here . Reusable Aspect Models Reusable Aspect Models (RAM) is a novel approach to aspect-oriented modeling that makes scalable multi-view modeling possible. It allows the modeler to define stand-alone reusable aspect models, which support the modeling of structure (using UML class diagrams) and behavior (using UML state and sequence diagrams). RAM supports aspect dependency chains, which allows an aspect providing complex functionality to reuse the functionality provided by other aspects. The approach also provides the modeler with means to resolve conflicts among aspect models in a reusable way, i.e. without creating any dependencies between the conflicting aspects. To read more about RAM click  here . Mammoth Since Spring 2005 I have been leading the development of Mammoth, a massively multiplayer game research framework. The goal of Mammoth is to provide an environment for experimentation in areas such as distributed systems, fault tolerance, databases, modeling and simulation, artificial intelligence and aspect-orientation. Our industrial partners are  Quazal ,  Electronic Arts Montreal , and  EJ-Technologies . To read more about Mammoth, click  here . Last modified: November 13, 2013, Jörg Kienzle Research Links ⬢ DREP ⬢ OMTT ⬢ O PTIMA  /  AspectO PTIMA ⬢ RAM ⬢ MammothdocContentEnd
72docContentStartHexomania  is a strategic game for two players (or one player against the computer). It also supports TCP/IP in order to play against a remote opponent over the Internet. About the Game Each player must try to build a path from one end of the board to the other one: the green player from the top left side to the bottom right one, the red player from the top right side to the bottom left one. The players are allowed to set on any field that is still free. Although the rules are simple, the game is not easy to play. One wrong move and you'll lose. The game uses the Apple Speech Manager (if installed) to speak the computer moves. Netplay is possible if Open Transport or TCP/IP is installed. System Requirements ⬢A Macintosh (or Power Macintosh) with 4MB of memory ⬢A color display (256 colors or grays) or more ⬢1.5MB of hard disk space ⬢System 7.5 or higher ⬢Optional: Speech Manager (for speech), Open Transport (for net play) Hexomania does not run on Intel Macs. New: Version 1.1 Network play has been extensively tested/debugged. Color-blind people can now swap between green/red or blue/red stone sets. Download To download version 1.1, click  here  (bin-hexed, about 1.1MB) or  here  (bin-hexed and gzipped, about 850k). Game History Thanks to the feedback of Ingemar Ragnemalm, I can now tell you more about the history of Hexomania: It seems like the game, which used to be called Hex, is known since about 50 years now, and that it has been analysed by lots of people. It is proven that the first player has a theoretical win, but the proof does not indicate how. The following publications have been written about Hex: ⬢Martin Gardner.  The Scientific American Book of Mathematical Puzzles and Diversions . Simon and Schuster 1959. ⬢S. Even and R. E. Tarjan. A Combinatorial Problem Which Is Complete in Polynomial Space.  Journal of the Associaction for Computing Machinery , volume 23 number 4, October 1976. ⬢David Gale. The Game of Hex and the Brouwer Fised-point Theorem.  American Mathematical Monthly , number 86, 1979. ⬢Stefan Reisch, Hex ist PSPACE-vollstaendig.  Acta Informatica , volume 15, pp. 167-191, 1981. A FAQ file on Hex can be found at  http://www.cs.cmu.edu/~hde/hex/hexfaqdocContentEnd
73docContentStartThis is me and my lovely wife Erin. She is the most adorable person I've ever met. She cares so much about the feelings of others, and always puts in all her energy to make everyone happy or help out. Her love brings sunshine to every day of my life! She is also incredibly fun to be with. With her intelligent humor she makes me laugh, and as many people from the  School of Computer Science  at  McGill  know, she can be quite a party animal when the night is long. She is also highly intelligent: she worked on a Ph.D. in Theoretical Computer Science and Mathematics with  Luc Devroye . But that is not her only talent. She plays an amazing piano, used to sing with the  Algorhythmics , and can build / craft / sow / construct the most beautiful things you can imagine. As you can see from the picture, she is also super cute and good-looking! Tall, deep strawberry-blond hair, blue eyes, and the softest skin you can imagine. Click on our picture to see some more pictures of her and me. This is my daughter, Julie. She was born on the 27th of January 1994 at the Bethesta hospital in  Basel , Switzerland (48 cm tall, weight 2.57 kg). She started walking when she was about one year old during my exchange year at  Carnegie Mellon  University  in Pittsburgh.  Now she is all grown up... She is also a very intelligent girl (She was able to read all letters of the alphabet when she was 15 month old!). She started playing the violin when she was 4, and attends the ENBC dance school in Montreal since grade 5. She also likes arranging and organizing things. Often, she spends a lot of time solving puzzles, and one of her big passions is reading. She also likes to compose her own songs, and recently started writing a book. Click  here  to see some more pictures of Julie. Julie also has a page on  Facebook . This is my daughter, Mira. She was born on the 2nd of April 2008 at the  St. Mary "s hospital  in  Montreal , Quebec, Canada. She was 50 cm tall and weighed 3.05 kg. When she was born she was really calm, her eyes wide open. She has the most amazing big blue eyes as you can see on the picture to the left. She is so adorable, always gives us huge smiles when she sees us, and is never angry or cranky on purpose. She already slept 6 hours through the night when she was 3 weeks old, 12 hours when she was 3 months. A dream baby! When she was 5 days old, we took her to a Sbaby photographer. He took some amazing pictures of Mira that you can find  here . Check out some  other pictures of Mira  on her photo page. This is Isabelle. She was born on the 15th of March 2000 at the Clinique Cecil in  Lausanne , Switzerland. At birth, she was the smallest of all four: 48 cm tall and 2,4 kg! Isabelle is cute and feisty. She is very independent. Often she just walks off and starts crafting something, like a knight"s armor made out of paper, or creates a funny drawing... Her paintings are incredible! She started playing the cello as a student of  Velitchka  Yotcheva  when she was 5 years old. Click here to listen to her play (June 2008). Click  here  to see more pictures of her... This is my daughter Laura. She was born at the Betesta hospital in  Basel , Switzerland, on the 15th of July 1996 (like her sisters, she was a small baby: 48.5 cm tall, weight 2.79 kg). Laura  is a very sweet girl with an interesting sense of humor. She loves to tell jokes, or make funny faces. She also is very active and constantly moves. She is very intelligent (she was able to count up to 30 when she was 2 1/2 years old). She has a special artistic sense, attends the ENBC dance school and used to play the piano. She loves to play with her sisters Julie and Isabelle, and they get along very well most of the time. Click  here  to see more pictures of Laura.docContentEnd
74docContentStartProgramming My first computer was an Apple II Europlus that my uncle built for me in 1982. That was one hell of a machine: Motorola 6502 processor (1 MHz), 48k memory, 6 colors (anyway, I only had a monochrome monitor), and a disk drive. I think the number of BASIC programs I wrote are innumerable (text and "high-res" graphical adventure games, a Dungeon & Dragons monster-generator, etc...) Then, in 1988, I bought an Apple II GS. Somehow similar to an Amiga (although without graphic coprocessor), this computer could still run the old Apple II stuff. Equipped with a 65C816 processor (2.8 MHz), 4096 color graphics, 32 channel stereo sound and a 3 1/2 disk drive, I started writing games in assembly language.  Gate , written together with two friends, Henrik Gudat and Yann Le Tensorer, and later on Spacefox were published by Toolbox, a French game company, and later on  Seven Hills Software, a company located in the USA . Finally, I switched to Macintosh. After some years using a Mac IIsi (I ported  Gate  to the Macintosh), I finally bought a PowerMac 8500. I wrote a couple of programs in C++, mostly semester projects, including a interactive simulator of mechanical interactions ( SimKit ) for the  graphics lab  at  Carnegie Mellon University  and a Tierra simulator for the  LSL , the Department of Logical Systems at the  Swiss Federal Institute of Technology , Lausanne (EPFL). During the preparation for my final exams, I have written a strategic board game,  Hexomania . Then I worked on a new game, Stormwind, which was supposed to be a mixture between strategic, action and simulation game, but since I am a professor at McGill my programming time is very limited. So I guess it will remain in "alpha" stage for a long time! Skating I started ice-skating when I was 8 years old, and started a serious Ice Dancing career when I was 14. In 1992 I won the Swiss Championships and participated in the European Championships and World Championships. At the European Championships (Lausanne, Switzerland) I finished at the 16th place, at the World Figure Skating Championships (San Francisco, CA, USA) I finished at the 18th place (out of 27 competitors), just behind the Lithuanian couple who have won the 3rd place at the World Figure Skating Championships in 2000. Music Very early, I started learning to play the recorder and really loved it. Then, as every *good* "Basler" (habitant of  Basel ), I learned to play the piccolo. This instrument is played during the annual spring carnival. I also tried to learn how to play the clarinet, but after one year of studies I abandoned it. What I enjoyed the most was playing the piano. If I remember correctly I started playing the piano when I was 8, and I took lessons for about 9 years. As soon as I got my first computer, I started making music using  MIDI , and therefore I gradually bought a  Yamaha  Clavinova CLP-250 (8 polyphonic), a  Korg  M3R Expander, a  Yamaha  Sy22 synthesizer, an  Alesis  QuadraVerb, two microphones and a mixer. I then changed my electric piano and bought a Clavinova CLP-570 (16 polyphonic), and then a Yamaha MP-80T, a combined acoustic and digital (32 polyphonic) piano when I moved to Canada. When I married Erin, we realized that having two pianos at home is not ideal, and then we Scombined our two pianos into one Yamaha CS2 grand, and one Yamaha 90ES synthesizer. Among writing some classical music for my Ice Dancing, I also wrote some piano pieces and songs. Below are some samples. Click on them to check them out: Skating Music ⬢ Nightbells  (1990, M3R) ⬢ On the Ice  (1990, M3R) ⬢ The Awakening  (1991, M3R) ⬢ Raindrops  (1991, M3R, Sy22) Piano Music ⬢ A Winter Night  (MP-80T) ⬢ Prelude to a Dream  (MP-80T) ( sheet music) Songs ⬢ Conestogorap  (Garageband) I am also in a band called the  Algorhythmics . We"re just a bunch of guys from the department that get together and jam, and once or twice a year we perform for our friends or the department. We mainly play blues and rock songs.docContentEnd
75docContentStartGate  blends action, adventure, and brain-teasing challenges into an addictive fast-action game with smooth animation, exciting music and sound effects. Escape the castle's prison, battle enemies, solve puzzles, and defeat you captor to restore peace to the land. The game is available in  English ,  French ,  German  or  Kanji . Prologue Flames in the night sky and the screams of dying men and women: these are the memories which linger in your mind as you contemplate your fate from behind the bowels of your dungeon cell. It was but a fortnight ago when your small village was attacked by the hideous minions of Darg, the Firemaster. If only the village elders had heeded the prophesy of Vladorf the Wise and armed themselves against the encroaching hoard that now overruns the land of Divesia, perhaps your family and friends might still be alive. The signs were clear enough in retrospect: first came the ominous fiery veils of light in the evening skies;  sudden snowstorms and gales past the vernal equinox; tremors in the ground; and rivers that reversed their courses. The crops were pounded by hail, then withered as if from great drought the next day. The fishermen's nets were filled with strangely twisted fish whose flesh was unwholesome, and brought madness to those who ate of it. Then the huntsmen returned with tales of wild animals gone mad: gigantic toads the size of wolves; swarms of winged spiders and scorpions; and raptor birds garbed in feathers that seemed to burn with a terrible, unquenchable fire. One farmer on the outlands had told that the earth rejected the bodies of the dead, and cast them from their graves to wander as immaterial wraiths. The very land itself seemed gripped by delirium, and a great lamentation arose from the people. The villagers petitioned their elders for guidance,, but none could fathom these dire omens. Some asserted that the people had strayed from the teachings of the Ol d Ones, while others averred that the Old Ones warred amongst themselves. Reports that the Giants had awoken from their age-old slumber to renew their pacts with the race of men served only to further confound the elders. They could only agree that all the other villages should be gathered to form one council, as tradition demanded. They chose the four swiftest runners to bear the urgent declarations to the four corners of the land, but none were heard from again. In panic the elders recalled the prophesy of Vladorf the Wise, who foretold that when the land went mad, only a single brave warrior armed with the marvelous 'Bow of Many Arrows' could restore the balance, and then only with the assistance of the Forgotten Magi. Your father was known to be the greatest archer in the village, and so he was chosen to bear this great honor. It was retrieved from the sacred vaults and given to his keeping. But as night fell on the village that same day, a strange and hideous army stormed the village. Warrior s with ashen countenance and baleful gaze, whose very souls seemed burned from their hearts, attacked and brutalized the good people. Invisible Fire Giants, whose only trace was the scorched footprints where they trod the soil, smashed the gates of the village. Huge fire elementals swirled on vortices of malefic flame, engulfing the huts and barns in awful conflagration. Through your father slew scores of Darg's minions with the 'Bow of Many Arrows', in the end you were both overcome and taken prisoners of the foul hoard. Now you find yourself in a dank cell, with your father mortally wounded. You have only your untested valor with the Bow and a fervent hope that the promise of aid foretold by Vladorf the Wise was more than just a legend. System Requirements Gate is quite an old game. I've written it using a combination of Think Pascal, Think C and 680x0 assembly language when the first Macintosh Quadra had just been released. Using assembly language was necessary in order to get smooth scrolling on my Mac IIsi! In order to run Gate, you'll need: ⬢ Any Power Mac or 68k Mac with 68020 processor or better (old 68k Macs must turn on 32 bit addressing in the Memory Control Panel) ⬢ 4 MB memory ⬢ 4.5 MB of disk space ⬢ 640x480 screen or larger, support 256 colors/grays or more ⬢ System 6.0.7 or later If game scrolling is too fast (well, on the IIsi it was too slow :) ), check the  Slower  option in the menu. Gate does not run on Intel Macs. It runs in under MacOS 10.2 or older in classic mode. Known Bugs The game was written under System 6.0.7, prior to the availability of Game Sprockets. In order to get fast scrolling on older Macintosh models, most of the display routines are written in assembly language. They directly write to the screen memory: they don't use Quickdraw! Depending on your graphic card this can cause display problems. Some new OS features have been introduced in later system versions, and Gate might not handle them correctly. The control strip for instance is not hidden when playing Gate. Download Use the links below to download Gate: ⬢Gate Demo,  bin-hex'd  (.hqx / 1.7 MB) ⬢Gate 1.3.0 (English, French, German),  bin-hex'd  (.hqx / 1.5 MB),  stuffit  (.sit / 1.1 MB) ⬢Gate 1.3.0k (English, French, German, Kanji),  bin-hex'd  (.hqx / 2.4 MB),  stuffit  (.sit / 1.7 MB)docContentEnd
76docContentStartSimKit is an interactive simulation program for mechanical interations. The object oriented framework of the program has been written by  David Baraff  who is an adjunct professor at  Carnegie Mellon University , currently working for  Pixar  studios. I ported the framework to the PowerMac and added interactive functions to the simulation program. (The original Silicon Graphics application was not interactive.) To the right you can see a screen-shot of the PowerMac application. You can create any (polygon-based) shapes, specify the mass (or density), choose global behaviors (such as "can rotate", "can move", "affected by gravity", etc...") and assign static and dynamic friction coefficients to them. Shapes can also be joined, and the gravity center of an object can be moved around. You then can add joints between shapes or nails that pin the object against the background. You can also specify that objects can only move between two parallel lines, etc... Springs can also be added to the system, and rest length, spring constant and damping factor can be specified. There are also active components that can be added to the system. Rotating motors (you can specify the speed and maximum force) and shrinking/expanding motors can be placed in the system. Then turn on gravity, dynamics and friction, and watch your system evolve. Of course you can apply forces on objects with the mouse during the simulation. Editing is made easy with snap-to grid and zooming functions. A special camera mode lets you follow a moving body around. Some limited sound-features can be used to signal collisions. At this moment, only rigid objects are supported. Nevertheless, deformable shapes can be simulated though small rigid bodies connected with springs. Unfortunately, this technique can result in very time-consuming calculations. I have also written a small demo program called  GeoKid  based on the same framework. It's basically an application that allows you to place squares, triangles and other 2D forms on a table, apply forces to them, and watch the system evolve. You can also turn gravity or friction on and off. If you want to check it out, click  here  (about 235k, bin-hexed). It only runs on the PowerMac, since it is a very computing-intensive application. If your Mac slows down too much, be sure that you are running in 256 color mode and try turning friction off. GeoKid does not run on Intel Macs.docContentEnd
77docContentStartThe Algorhythmics are the official band of the School of Computer Science of McGill University. The current permanent members are  Godfried T. STerminator Toussaint  on the drums (computational geometry professor),  David SCrazy Hands Avis  on the guitar (professor working on combinatorial optimization and operations research),  Gena SFretless Hahn  on the bass (professor working on graph theory),  Jörg S88 Fingers Kienzle  on the keyboard (professor working in the field of fault tolerance), and  Sean Kennedy , our main singer and guitarist (Ph.D. student in theoretical computer science). Over the years, many other visitors of the School of Computer Science played with us (see below). We"re no accomplished musicians, but just a bunch of guys that get together once a month to jam. Usually we perform once or twice per year for our friends or for the department or the faculty of Science. We mainly play Sblues and Srock songs. Here"s a list of some of the songs we regularly play: Eric Clapton:  Lay Down Sally Bruce Springsteen: Fire Santana: Black Magic Woman Queen: Crazy Little Thing Called Love Robert Johnson: Sweet Home Chicago Muddy Waters: Hoochie Coochie Man Van Morrison: Moondance Muddy Waters: I Got My Mojo Working Dire Straits: Walk of Life Louie Prima:  Jump Jive and Wail Fats Domino: Ain"t That A Shame The Beach Boys: Surfing USA The Rolling Stones: Miss You Buddy Holly: True Love Ways Norah Jones: Turn Me On The Beatles: Revolution David Bowie: Rebel Rebel Past Events SOCS Alumni Event, May 16th 2008, Thompson House CCCG Conference Banquet, August 14th 2008, Thompson House Casino Night, Nov. 21st 2008, Trottier Building, 2nd floor Previous Members Guest Members Last modified November 13, 2013, Jörg KienzledocContentEnd
78docContentStartI am an associate professor at the  School of Computer Science  of  McGill University , where I head the  Software Engineering Lab . Research My current research interest include fault tolerance (software fault tolerance, transactions, exception handling, fault tolerance in distributed games), software engineering (software development methods, software architecture) and aspect-orientation. For more information on my research, check out my  research page . Contact Info Address: Office: Phone: Fax: Email: School of  Computer  Science McGill University 3480 University, McConnell Eng. 318 H3A 0E9 Montreal, QC, Canada McConnell 327 +1 (514) 398-2049 +1 (514) 398-3883 Joerg.Kienzle@mcgill.ca Teaching In Fall 2014 I am  COMP-361 Software Engineering Project .  For a list  of courses I taught in the past, look at my  teaching page . CV If you want to know everything about my professional career, download my  CV . Other Activities When I arrived at McGill, I started the  School of Computer Science Colloquium  lecture series. I have also been involved in the creation of the  School of Computer Science Game Programming Guru summer camp  for high school students. I am also regularly organizing one week modeling workshops at the Bellairs McGill Research Institute in Barbados ( April 2009 ,  April 2010 ,  April 2011 ,  April 2012 ,  February 2013 ). The  2014 edition  of the Bellairs modelling workshop is themed SModelling outside the Box. Personal If you want to know more about my private life, check out my  family ,  family pictures  and  hobby  pages. Last modified: October 1, 2014, Jörg KienzledocContentEnd
79docContentStartDoina Precup Home Publications Research Students Teaching Service Biography Personal Related LinksdocContentEnd
80docContentStartMachine Learning (COMP-652) Winter 2014 Home Syllabus Lectures Assignments Project Resources News Assignment 1 is now available on the assignments web page. Matlab will be required for some of the assignments. For people who do not know Matlab, we suggest watching  the online Matlab tutorials . The first class takes place Monday, January 6. General Information Where:  Trottier room 1090. When:  Monday and Wednesday, 1:05-2:25pm.. What:  The goal of this class is to provide an overview of the state-of-art algorithms used in machine learning.  The field of machine learning is concerned with the question of how to construct computer programs that improve automatically with experience.  In recent years, many successful applications of machine learning have been developed, ranging from data-mining programs that learn to detect fraudulent credit card transactions, to autonomous vehicles that learn to drive on public highways.  At the same time, there have been important advances in the theory and algorithms that form the foundation of this field.  During this course, we will study both the theoretical properties of machine learning algorithms and their practical applications. Instructor Doina Precup School of Computer Science Office:  McConnell Engineering building, room 111N (left from elevators) Office Hours:  Monday and Wednesday, 2:30-3:00pm, as well as Monday 10:30am-12:00pm.  Meetings at other times  by appointment only Phone:  (514) 398-6443 E-mail:   dprecup@cs.mcgill.ca Teaching assistants Neil Girdhar (neil dot girdhar at mail dot mcgill dot ca).  Office hours: Thursday, 3-4pm, McConnell Engineering room 111 (NOT 111N!) Boyu Wang (boyu dot wang at mail dot mcgill dot ca).  Office hours: Tuesday 2-3pm, McConnell Engieering room 108. References There is no required textbook.  However, the material we cover is described in several books.  The schedule will include recommended reading, either from these books, or from research papers, as appropirate. Christopher M. Bishop, "Pattern Recognition and Machine Learning", Springer , 2006. Richard S. Sutton and Andrew G. Barto, "Reinforcement learning: An introduction", MIT Press , 1998. Tom Mitchell, "Machine Learning", McGraw-Hill , 1997. Richard O. Duda, Peter E. Hart & David G. Stork, "Pattern Classification. Second Edition", Wiley & Sons , 2001. Trevor Hastie, Robert Tibshirani and Jerome Friedman, "The Elements of Statistical Learning", Springer , 2009. David J.C. MacKay, "Information Theory, Inference and Learning Algorithms", Cambridge University Press, 2003. Ethem Alpaydin, "Introduction to Machine Learning", MIT Press , 2004. Lecture notes and other relevant materials are linked to the  lectures web page .  Assignments are linked to the  assignments web page MyCourses  will be used only for bulletin board, discussion groups and assignment submission and grading.docContentEnd
81docContentStartResearch Interests A list of the projects I am currently working on is available from the Reasoning and Learning Lab  web page.  Look at my  publications  list if you want to find out more details. Prof. Doina PRECUP Last modified: Tue Jul  9 14:53:07 EDT 2002docContentEnd
82docContentStartCurrent and Former Students PhD Students Bohdana Ratitch . Main research topic: Study of Reinforcement Learning Methods with Generalization Capabilities. Co-supervision with  Prof. Denis Therien . Danielle Azar. Main research topic: Genetic Algorithms for Software Engineering Co-supervision with  Prof. Houari Sahraoui and  Prof. Sue Whitesides . Masoumeh Tabae Izadi. Main research topic: TBD Mohamed Mostagir. Main research topic: TBD MSc Students David Allard Sebastian Grobys Martin Stolle Graduating MSc Students John Boadway. Reinforcement Learning for Trading Agents. Yannick Daoudi . Neural Networks Applications in Bioinformatics. Co-supervision with  Prof. Michael Hallett . Francois Rivest . Knowledge-Based Methods for Constructing Neural Networks Co-supervision with  Prof. Thomas Shultz . Ron Singer Main research topic: Information Extraction from Text using Hidden Markov Models. Past Students Mark Segal Learning semicomputable sets (MSc, 2002) Co-supervision with  Prof. Denis Therien . Last known location: computer consultant in Toronto. Doina PRECUP Last modified: Wed Aug 21 13:20:08 EDT 2002docContentEnd
83docContentStartCourses COMP-424: Artificial Intelligence I COMP-652: Machine Learning COMP-526:: Probabilistic reasoning in AI Doina PRECUP Last modified: Thu Sep  4 18:57:39 EDT 2003docContentEnd
84docContentStartDoina Precup's Publications Note: Publications from 2002 are not yet listed! DISSERTATION Precup, D.  (2000). " Temporal Abstraction in Reinforcement Learning ". Ph.D. Dissertation,  Department of Computer Science , University of Massachusetts, Amherst. JOURNAL ARTICLES Sutton, R. S. , Precup, D. ,  Singh, S.  (1999). " Between MDPs and semi-MDPs: A Framework for Temporal Abstraction in Reinforcement Learning ". In  Artificial Intelligence , vol. 112, pp.181-211. An earlier version appeared as  Technical Report UM-CS-1998-74 , Department of Computer Science, University of Massachusetts, Amherst, MA 01003-4610. REFEREED CONFERENCES AND WORKSHOPS Letia, I.A.,  Precup, D. ,  Craciun, F.  (2001)  " Developing collaborative Golog agents by reinforcement learning.  To appear in  Proceedings of the Thirteenth Conference on Intelligent Tools with Artificial Intelligence ( ICTAI 2001 ) . IEEE Computer Press Precup, D. ,  Sutton, R.S. ,  Dasgupta, S.  (2001)  " Off-policy temporal-difference learning with function approximation  ".  In  Proceedings of the Eighteenth Conference on Machine Learning ( ICML 2001 ) , pp.417-424. Morgan Kaufmann. Precup, D. , Sutton, R. S. , Singh, S.  (2000)  " Eligibility Traces for Off-Policy Policy Evaluation ".  In  Proceedings of the Seventeenth Conference on Machine Learning ( ICML 2000 ) , pp. 759--766. Morgan Kaufmann. Sutton, R. S. ,  Singh, S. ,    Precup, D. ,   Ravindran, B.  (1999) " Improved Switching among Temporally Abstract Actions ". In Advances in Neural Information Processing Systems 11 (Proceedings of  NIPS'98 ) , pp.1066-1072. MIT Press. Sutton, R. S. ,  Precup, D. ,   Singh, S.  (1998). " Intra-Option Learning about Temporally Abstract Actions ".In  Proceedings of the Fifteenth International Conference on Machine Learning ( ICML'98 ) , pp.556-564. Morgan Kaufmann. Precup, D. ,  Utgoff, P.E.  (1998). " Classification using Phi-machines and constructive function approximation ". In  Proceedings of the  Fifteenth International Conference on Machine Learning, ICML'98 , pp.439-444. Morgan Kaufmann. An earlier version appeared as  Technical Report UM-CS-1997-005 , Department of Computer Science, University of Massachusetts, Amherst, MA 01003-4610. Precup, D. ,  Sutton, R. S. ,  Singh, S.   (1998). " Theoretical  Results  on  Reinforcement  Learning with Temporally Abstract Options ". In  Machine Learning: ECML-98.  10th European Conference on Machine Learning, Chemnitz, Germany, April 1998 . Proceedings , pp. 382-393. Springer Verlag. Precup, D. ,  Sutton, R. S.  (1998). " Multi-Time Models for Temporally Abstract Planning ". In Advances in Neural Information Processing Systems 10 (Proceedings of  NIPS'97 ) , pp. 1050-1056. MIT Press. Moss, J. E. B. ,  Utgoff, P. E. ,  Cavazos, J. ,  Precup, D. ,  Stefanovic, D. ,  Brodley, C. E. ,  Scheeff, D. T.  (1998). " Learning to Schedule Straight-Line Code ". In Advances in Neural Information Processing Systems 10 (Proceedings of  NIPS'97 ) , pp.929-935. MIT Press. Precup, D. ,  Sutton, R. S. ,  Singh, S.  (1997). " Planning with Closed-Loop Macro Actions ". In  Working Notes of the  AAAI Fall Symposium '97 on Model-directed Autonomous Systems , pp. 70-76. Precup, D. ,  Sutton, R. S.  (1997) " Multi-Time Models for Reinforcement Learning ". In Proceedings of the  ICML'97 Workshop on Modelling in Reinforcement Learning . Precup, D. ,  Sutton, R. S.  (1997) " Exponentiated Gradient Methods for Reinforcement Learning ". In Proceedings of the Fourteenth International Conference on Machine Learning ( ICML'97 ) , pp.272-277. Morgan Kaufmann, An earlier version appeared as Technical Report UM-CS-1996-070 ", Department of Computer Science, University of Massachusetts, Amherst, MA 01003-4610. McGeoch, C.C. ,  Precup, D. ,  Cohen, P.R.  (1997) " How to Find Big-Oh in Your Data Set (and How Not To) ". In " Advances in Intelligent Data Analysis: Reasoning about Data." Proceedings of the  Second International Symposium on Intelligent Data Analysis, IDA-97 ,  pp. 41-52. Springer Verlag. Letia, I.A. ,  Precup, D.  (1995) " Knowledge Transfer when Learning a Second Programming Language " In  Proceedings of the 6th IFIP World Conference on Computers in Education , pp.97-106. Chapmann and Hall. Precup, D. ,  Precup, T.  (1995) " Trajectory Simulation and Optimization for Fuzzy Controlled Mobile Robot " In  Proceeding of the 3rd IFAC/IFIP/IFORS Workshop, Intelligent Manufacturing Systems, IMS'95, Bucharest, Romania. Preprints , pp. 39-43.  Also accepted for publication in the post-prints, edited by Elsevier Science. BOOK CHAPTERS Utgoff, P.E. ,  Precup, D.  (1998). " Constructive function approximation." In Motoda & Liu (Eds.),  Feature extraction, construction, and selection: A data-mining perspective . Kluwer. An earlier version appeared as  Technical Report UM-CS-1997-004 , Department of Computer Science, University of Massachusetts, Amherst, MA 01003-4610. UNREFEREED PUBLICATIONS McGovern, A. ,  Precup, D. ,  Ravindran, B. ,    Singh, S. ,  Sutton, R. S.  (1998). " Hierarchical Optimal Control of MDPs ".  Proceedings of the  Tenth Yale Workshop on Adaptive and Learning Systems , pp.186-191. Maties, V.,  Precup, T. ,  Precup, D. , Sipos, C.(1994). " Simulation of a Fuzzy-Guided Mobile Robot in a Static Environment " In  Proceedings of the National Conference on Systems Theory, Robotics and Automatic Control SINTES 7, Craiova, Romania , pp. 203-208. Precup, D. ,  Precup, T. ,  Sipos, C.(1994). "Simulation of Automatic Fuzzy Controllers for Robot Guidance " In  Proceedings of the Basis of Electronics Workshop, Cluj-Napoca, Romania , pp.58-63. TECHNICAL REPORTS WHICH DO NOT OVERLAP WITH PREVIOUS PUBLICATIONS Perkins, T.J. ,  Precup, D.  (1999) " Using Options for Knowledge Transfer in Reinforcement Learning ", Technical Report UM-CS-1999-034, Department of Computer Science, University of Massachusetts, Amherst, MA 01003-4610. Utgoff, P.E. ,  Precup, D.  (1997) " Relative Value Function Approximation ", Technical Report UM-CS-1997-003, Department of Computer Science, University of Massachusetts, Amherst, MA 01003-4610. OTHER DOCUMENTS Using Analogic Reasoning for Natural Language Semantic Processing, " Advanced studies in computer science" MScCSE graduation project, Technical University Cluj-Napoca, Romania, 1995. Student Modeling for Learning a Second Programming Language, BScCSE graduation project, Technical University Cluj-Napoca, Romania, 1995.docContentEnd
85docContentStartMartin Robillard Associate Professor · McGill University Home Publications Blog Activities Teaching Students Software Martin Robillard, Ph.D.,  Eng. Associate Professor School of Computer Science McGill University 3480 University Street McConnell Engineering Building, Office 114N Montréal, QC   H3A 2A7 Canada Tel.: (514) 398-4258 (by appointment) Martin Robillard is an Associate Professor of Computer Science at McGill University. His current research focuses on problems related to API usability, information discovery, and knowledge management in software engineering. He recently served as the Program Co-Chair for the 20th ACM SIGSOFT International Symposium on the Foundations of Software Engineering and on the editorial board of the IEEE Transactions on Software Engineering and is currently on the editorial board of Empirical Software Engineering. He received his Ph.D. and M.Sc. in Computer Science from the University of British Columbia and a B.Eng. from École Polytechnique de Montréal. Research Interests:  Software engineering, software archive mining, API usability, recommendation systems, natural language processing, and research methods for empirical software engineering. [ Robillard  is pronounced  row-bee-yaar ]. Tweets by @mp_robillard ©  Martin Robillard  2013 · Based on a design by:  Luka Cvrk  · Released under a  Creative Commons LicencedocContentEnd
86docContentStartMartin Robillard Associate Professor · McGill University Home Publications Blog Activities Teaching Students Software Blog 28 November 2014 - Summarizing Qualitative Evidence with Spark-Histograms When reporting on data analyzed using a qualitative research approach, a major challenge is to properly indicate the nature and amount of the evidence that support a given observation... 15 October 2014 - Code Examples: Less is More, but What Should We Chop Off? A lot of the documents we need to understand and use software technologies include code examples... To decide whether to study a code example in detail, it's useful to have a summary of what it's about, just like for any other document. But most techniques for summarizing "normal" documents don't apply to code... 8 August 2014 - Embracing Discrimination (in API Documentation) A flat (non-hierarchical) content presentation mostly assumes the reader wants to read everything sequentially. This assumption is fine for suspenseful novels, but it crumples in the case of API documentation... 26 June 2014 - Good Practices for Software Analytics Papers Much effort is currently invested to increase our understanding of software development by analyzing large data sets [...]. This type of effort is now known as  Software Analytics  [...]. We [provide] a list of desirable practices for reporting on software analytics projects. 12 May 2014  - APIs: What Should We Document (and Not Document)? APIs are not always self-explanatory, so we need to complement them with documentation for better usability...But how do we do that? ... ©  Martin Robillard  2013 · Based on a design by:  Luka Cvrk  · Released under a  Creative Commons LicencedocContentEnd
87docContentStartETX 2006 Eclipse Technology Exchange Workshop at  OOPSLA 2006 Home CFP Organization Program Event Eclipse Technology eXchange (ETX) Workshop at OOPSLA 2006 Portland, Oregon October 22-23, 2006 The Eclipse platform (http://www.eclipse.org) is designed for building integrated development environments (IDEs) for object-oriented application development. The goal of the Eclipse Technology Exchange workshop (ETX) was to bring together researchers and practitioners to exchange ideas about potential new uses of Eclipse and how the core Eclipse technology can be leveraged, improved and/or extended for research and teaching projects. Building on the success of the Eclipse Technology eXchange workshops at OOPSLA 2003, 2004, and 2005, this 1.5 day workshop included the presentation of 17 original papers on a number of topics related to the Eclipse platform. The workshop is now over. Thanks to all of our 35 attendees for their participation and congratulations to  Tom Zimmermann  for winning the Best Student Paper award for the paper "Fine-grained Processing of CVS Archives with APFEL". See the  program  for the complete list of papers, including the Best Student Paper award short list. Previous instances of workshop: Eclipse Technology eXchange, OOPSLA 2005 Eclipse Technology eXchange, OOPSLA 2004 Eclipse Technology eXchange, OOPSLA 2003docContentEnd
88docContentStartETX 2006 Eclipse Technology Exchange Workshop at  OOPSLA 2006 Home CFP Organization Program Event The workshop is now over. This call for paper is left on-line for archival purposes. Download a PDF version of the call for paper Call for Papers:  Eclipse Technology eXchange (ETX) Workshop at OOPSLA 2006 Portland, Oregon October 22-23, 2006 The Eclipse platform ( http://www.eclipse.org ) is designed for building integrated development environments (IDEs) for object-oriented application development.  Building on the success of the Eclipse Technology eXchange workshops at OOPSLA 2003, 2004, and 2005, we invite original papers that describe potential new uses of Eclipse and how the core Eclipse technology can be leveraged, improved and/or extended for research and teaching projects.  Accepted papers will be presented at the workshop. Due to the popularity of this workshop in the past, this year's ETX will be a 1.5 day event.  Workshop topics include (but are not limited to) the use of Eclipse for: IDEs supporting the software development process debugging or testing design requirements/specification modeling environments or frameworks aspect-oriented programming program analysis and transformation, such as for refactoring, optimization, or obfuscation computer-based learning software engineering education teaching foundations of object-oriented programming courseware teaching an introductory undergraduate programming course web service applications rich client applications Submissions should have a maximum of  5 pages  in the standard ACM conference format. Wednesday,  August 30 , 2006 midnight  (in Dateline Standard Time = GMT -12:00) is the deadline for submission (extended from August 23).  Authors will be notified by  September 12, 2006 . (Please be aware that early registration for OOPSLA 2006 is September 14th, 2006.) Proceedings will be included in the ACM Digital Library.  To have their work included in the ACM Digital Library, authors will need to sign the ACM Copyright Form (please refer to  http://www.acm.org/pubs/copyright_form.html for details on rights retained by the authors).  Submitted papers should be formatted according to the ACM Digital library guidelines, see  http://www.acm.org/sigs/pubs/proceed/template.html . Note: Admission to the workshop will be extended to those who have submitted a relevant position paper.  Each position paper will be reviewed by the Program Committee.  There will also be a Best Student Paper Award.  Candidate papers for the Best Student Paper Award can have multiple authors (students and non-students) as long as the most significant portion of the work (research and or experience) that the paper reports was done by student(s) and the student(s) are listed as lead author(s).  The prize for the Best Student Paper Award will be awarded to the student author(s) only. Workshop Organizers: Michael G. Burke , IBM Thomas J. Watson Research Center, USA Cheryl Morris , IBM Toronto Lab, Canada Alessandro Orso , Georgia Institute of Technology, USA Martin Robillard , McGill University, Canada Previous instances of workshop: Eclipse Technology eXchange, OOPSLA 2005 Eclipse Technology eXchange, OOPSLA 2004 Eclipse Technology eXchange, OOPSLA 2003docContentEnd
89docContentStartETX 2006 Eclipse Technology Exchange Workshop at  OOPSLA 2006 Home CFP Organization Program Event Organization Workshop Organizers Michael G. Burke , IBM Thomas J. Watson Research Center, USA Cheryl Morris , IBM Toronto Lab, Canada Alessandro Orso , Georgia Institute of Technology, USA Martin Robillard , McGill University, Canada Program Committee Kris De Volder, University of British Columbia, Canada Michael Ernst, Massachusetts Institute of Technology, USA Sudipto Ghosh, Colorado State University, USA William Griswold, University of California (San Diego), USA Arno Jacobsen, University of Toronto, Canada Christophe Lüth, University of Bremen, Germany Alfredo Olivero, Universidad Argentina de la Empresa, Argentina David Redmiles, University of California (Irvine), USA Robby, Kansas State University, USA Václav Rajlich, Wayne State University, USA Atanas Rountev, Ohio State University, USA Wim Vanderperren, Vrije Universiteit Brussel, Belgium Arie van Deursen, Delft University of Technology, The Netherlands Kenny Wong, University of Alberta, CanadadocContentEnd
90docContentStartETX 2006 Eclipse Technology Exchange Workshop at  OOPSLA 2006 Home CFP Organization Program Event Notes and Photos from the Event Workshop participants unwinding at a local restaurant. Workshop participants unwinding at a local restaurant.docContentEnd
91docContentStartETX 2006 Eclipse Technology Exchange Workshop at  OOPSLA 2006 Home CFP Organization Program Event Program Preliminary workshop program. The links are to the version of each paper that was originally submitted. The revised versions will be available through the ACM digital library after the workshop. Sunday 22 October 2006 08:30-10:00 - Software Maintenance and Process  -  Chair: Alessandro Orso Embedded Device Solution Life Cycle Support with Eclipse  (C. Jung, H. Chen) Next-Generation DPP with Sangam and Facetop  (K. Navoraphan, E.F. Gehringer, J. Culp, D. Stotts) Lighthouse: Coordination through Emerging Design  (I. da Silva, P. Chen, C. Van der Westhuizen, R. Ripley, André van der Hoek) 10:30-12:00 - Repository Mining  -  Chair: Alessandro Orso Fine-grained Processing of CVS Archives with APFEL  (T. Zimmermann) -  Best Student Paper Award HAM: Cross-Cutting Concerns in Eclipse  (S. Breu, T. Zimmermann, C. Lindig) MolhadoRef: A Refactoring-aware Infrastructure for OO Programs  (D. Dig, K. Manzoor, T. Nguyen, R. Johnson) 13:30-15:00 - Analysis and Verification  -  Chair: Michael Burke SSVChecker: Unifying Static Security Vulnerability Detection Tools in an Eclipse Plug-In (J. Dehlinger, Q. Feng, L. Hu) A Toolsuite for the Verification of RealTime Systems in Eclipse  (L. Cavatorta, G. de Caso, A. Ferrari, V. Braberman, D. Garbervetsky, N. Kicillof, A. Olivero, F. Schapachnik) Generating Run-Time Progress for a Points-to Analysis in Eclipse  (J. Sawin, M. Sharp, A. Rountev) Proof General in Eclipse  (David Aspinall and Christoph Lüth) 15:30-17:30 - Program Understanding  -  Chair: Martin Robillard Visualization of Clone Detection Results  (R. Tairas, J. Gray, I. Baxter) FrUiT: IDE Support for Framework Understanding  (M. Bruch, T. Schäfer, M. Mezini) - Best Student Paper Short List Guidance through Active Concerns  (B. Dagenais, H. Ossher) JASPER: An Eclipse Plug-In to Facilitate Software Maintenance Tasks  (M. Coblenz, A. Ko, B. Myers) Monday 23 October 2006 08:30-10:00 - Education  -  Chair: Michael Burke JExercise  a specification-based and test-driven exercise support plugin for Eclipse  (H. Traetteberg, T. Aalberg) A Focused Learning Environment for Eclipse  (I. Safer, G.C. Murphy, J. Waterhouse, J. Li) - Best Student Paper Short List XPlainer: Explaining XPath within Eclipse  (J.W.S. Liu, M.P. Consens, F. Rizzolo) 10:30-12:00 - PaneldocContentEnd
92docContentStartMartin Robillard Associate Professor · McGill University Home Publications Blog Activities Teaching Students Software Publications 2014 Barthélémy Dagenais and Martin P. Robillard.  Using Traceability Links to Recommend Adaptive Changes for Documentation Evolution . To appear in  IEEE Transactions on Software Engineering , 23 pages,  2014.  abstract Annie T.T. Ying and Martin P. Robillard.  Selection and Presentation Practices for Code Example Summarization.   To appear in  Proceedings of the 22nd ACM SIGSOFT International Symposium on the Foundations of Software Engineering , pages 460-471, 2014.  [ACM SIGSOFT Distinguished Paper]   abstract ·  pdf  ·  data Gias Uddin and Martin P. Robillard.  How API Documentation Fails.   To appear in  IEEE Software , 2014. Yam B. Chhetri and Martin P. Robillard.  Recommending Reference API Documentation.    Empirical Software Engineering , 2014. 28 pages.  abstract ·  pdf  ·  site Martin P. Robillard and Robert J. Walker.  An Introduction to Recommendation Systems in Software Engineering.   In Martin P. Robillard, Walid Maalej, Robert J. Walker, and Thomas Zimmermann (Eds.)  Recommendation Systems in Software Engineering . Springer, 2014. Pages 1-11.  abstract ·  site Annie T. T. Ying, Martin P. Robillard.  Developer Profiles for Recommendation Systems.   In Martin P. Robillard, Walid Maalej, Robert J. Walker, and Thomas Zimmermann (Eds.)  Recommendation Systems in Software Engineering . Springer, 2014. Pages 199-222.  abstract ·  site Martin P. Robillard, Walid Maalej, Robert J. Walker, and Thomas Zimmermann (Eds.)  Recommendation Systems in Software Engineering.   Springer, 2014, ISBN 978-3-642-45134-8  abstract ·  site 2013 Walid Maalej and Martin P. Robillard.  Patterns of Knowledge in API Reference Documentation.    IEEE Transactions on Software Engineering , 39(9):1264-1282, September 2013. abstract  ·  pdf ·  site Annie T.T. Ying and Martin P. Robillard.  Code Fragment Summarization.   New Ideas Paper.   9th joint meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering , 4 pages, August 2013. Peter C. Rigby and Martin P. Robillard.  Discovering Essential Code Elements in Informal Documentation . In  Proceedings of the 35th IEEE/ACM International Conference on Software Engineering , pages 832-841, May 2013.  abstract ·  pdf Martin P. Robillard, Eric Bodden, David Kawrykow, Mira Mezini, and Tristan Ratchford. Automated API Property Inference Techniques.    IEEE Transactions on Software Engineering , 39(5):613-637, May 2013.  abstract ·  site 2012 Barthélémy Dagenais and Martin P. Robillard.  Recovering Traceability Links between an API and its Learning Resources . In  Proceedings of the 34th IEEE/ACM International Conference on Software Engineering , pages 47-57, June 2012.  abstract  ·  pdf Ekwa Duala-Ekoko and Martin P. Robillard.  Asking and Answering Questions About Unfamiliar APIs: An Exploratory Study . In  Proceedings of the 34th IEEE/ACM International Conference on Software Engineering , pages 266-276, June 2012.  abstract  ·  pdf Gias Uddin, Barthélémy Dagenais, and Martin P. Robillard.  Temporal Analysis of API Usage Concepts . In  Proceedings of the 34th IEEE/ACM International Conference on Software Engineering , pages 804-814, June 2012.  abstract  ·  pdf 2011 Gias Uddin, Barthélémy Dagenais, and Martin P. Robillard.  Analyzing Temporal API Usage Patterns . Short paper. In  Proceedings of the 26th IEEE/ACM International Conference on Automated Software Engineering , pages 456-459,  November 2011.  abstract  ·  pdf Barthélémy Dagenais and Martin P. Robillard.  Recommending Adaptive Changes for Framework Evolution .  ACM Transactions on Software Engineering and Methodology , 20(4), September 2011.  abstract  ·  pdf Ekwa Duala-Ekoko and Martin P. Robillard.  Using Structure-Based Recommendations to Facilitate Discoverability in APIs . In  Proceedings of the 25th European Conference on Object-Oriented Programming , pages 79-104, July 2011.  abstract  ·  pdf Annie T.T. Ying and Martin P. Robillard.  The Influence of the Task on Programmer Behaviour . In  Proceedings of the 19th IEEE International Conference on Program Comprehension , pages 31-40, June 2011.  abstract  ·  pdf David Kawrykow and Martin P. Robillard.  Non-Essential Changes in Version Histories . In Proceedings of the 33rd ACM/IEEE International Conference on Software Engineering , pages 351-360, May 2011.  abstract  ·  pdf Martin P. Robillard and Robert DeLine.  A Field Study of API Learning Obstacles .  Empirical Software Engineering , 16(6): 703-732, 2011.  abstract  ·  site 2010 Barthélémy Dagenais and Martin P. Robillard.  Creating and Evolving Developer Documentation: Understanding the Decisions of Open Source Contributors . In Proceedings of the 18th ACM SIGSOFT International Symposium on the Foundations of Software Engineering , pages 127-136, November 2010.  [ACM SIGSOFT Distinguished Paper] abstract  ·  pdf Martin P. Robillard, Robert J. Walker and Thomas Zimmermann.  Recommendations Systems for Software Engineering .  IEEE Software , 27(4):80-86, July-August 2010.    abstract  ·  site Ekwa Duala-Ekoko and Martin P. Robillard.  Clone Region Descriptors: Representing and Tracking Duplication in Source Code .  ACM Transactions on Software Engineering and Methodology , 20(1):1-31, June 2010.  abstract  ·  pdf Barthélémy Dagenais, Harold Ossher, Rachel K.E. Bellamy, Martin P. Robillard, and Jacqueline P. de Vries.  Moving into a New Software Project Landscape . In  Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering , pages 275-284, May 2010.  abstract  ·  pdf Martin P. Robillard and Barthélémy Dagenais.  Recommending Change Clusters to Support Software Investigation: An Empirical Study .  Journal of Software Maintenance and Evolution: Research and Practice , 22(3):143-164, April 2010.  abstract  ·  pdf 2009 Martin P. Robillard.  What Makes APIs Hard to Learn? Answers from Developers .  IEEE Software - Special Issue on the Collaborative and Human Aspects of Software Engineering , 26(6):27-34, November/December 2009.  abstract  ·  pdf  ·  site David Kawrykow and Martin P. Robillard.  Improving API Usage through Detection of Redundant Code . In  Proceedings of the 24th IEEE/ACM International Conference on Automated Software Engineering , pages 111-122, November 2009.  abstract  ·  pdf  ·  site Reid Holmes, Tristan Ratchford, Martin P. Robillard, and Robert J. Walker.  Automatically Recommending Triage Decisions for Pragmatic Reuse Tasks . In  Proceedings of the 24th IEEE/ACM International Conference on Automated Software Engineering , pages 397-408, November 2009.  abstract  ·  pdf  ·  site Ekwa Duala-Ekoko and Martin P. Robillard.  A Detailed Examination of the Correlation Between Imports and Failure-Proneness of Software Components . In  Proceedings of the 3rd International Symposium on Empirical Software Engineering , pages 34-43, October 2009.  abstract  ·  pdf  ·  site Barthélémy Dagenais and Martin P. Robillard.  SemDiff: Analysis and Recommendation Support for API Evolution . Formal research demonstration. In  Proceedings of the 31th ACM/IEEE International Conference on Software Engineering , pages 599-602, May 2009.   abstract  ·  pdf ·  site ·  tool David Kawrykow and Martin P. Robillard.  Detecting Inefficient API Usage . New ideas and emergent results paper. In  Proceedings of the 31th ACM/IEEE International Conference on Software Engineering - Companion , pages 183-186, May 2009.  abstract  ·  pdf  ·  site Barthélémy Dagenais, Harold Ossher, Rachel K. E. Bellamy, Martin P. Robillard, and Jacqueline P. de Vries.  A Qualitative Study on Project Landscapes . In  Procceedings of the ICSE 2009 Workshop on Cooperative and Human Aspects of Software Engineering , pages 32-35, May 2009.  abstract  ·  pdf  ·  site 2008 Martin P. Robillard. Topology Analysis of Software Dependencies.  ACM Transactions on Software Engineering and Methodology , 17(4):Article 18 (36 pages), August 2008.  pdf  ·  site  ·  tool Martin P. Robillard and Barthélémy Dagenais. Retrieving Task-Related Clusters from Change History. In Proceedings of the 15th Working Conference on Reverse Engineering , pages 17-26, October 2008.  pdf  ·  site Martin P. Robillard and Putra Manggala. Reusing Program Investigation Knowledge for Code Understanding. In  Proceedings of the 16th IEEE International Conference on Program Comprehension , pages 202-211, June 2008.  pdf  ·  site Barthélémy Dagenais and Martin P. Robillard. Recommending Adaptive Changes for Framework Evolution. In  Proceedings of the 30th ACM/IEEE International Conference on Software Engineering , pages 481-490, May 2008.  [ACM SIGSOFT Distinguished Paper]   pdf  ·  site Ekwa Duala-Ekoko and Martin P. Robillard. CloneTracker: Tool Support for Code Clones Management. Formal Research Demonstration. In Proceedings of the 30th ACM/IEEE International Conference on Software Engineering , pages 843-846, May 2008.  pdf  ·  site 2007 Barthélémy Dagenais, Silvia Breu, Frédéric Weigand Warr and Martin P. Robillard. Inferring Structural Patterns for Concern Traceability in Evolving Software. In  Proceedings of the 22nd IEEE/ACM International Conference on Automated Software Engineering , pages 254-263, November 2007.  pdf  ·  site Brian De Alwis, Gail C. Murphy, and Martin P. Robillard. A Comparative Study of Three Program Exploration Tools. In Proceedings of the 15th International Conference on Program Comprehension , pages 103-112, June 2007.  pdf  ·  site Ekwa Duala-Ekoko and Martin P. Robillard. Tracking Code Clones in Evolving Software. In  Proceedings of the 29th International Conference on Software Engineering , pages 158-167, May 2007.  [ACM SIGSOFT Distinguished Paper]   pdf  ·  site Frédéric Weigand-Warr and Martin P. Robillard. Suade: Topology-Based Searches for Software Investigation. Research demonstration. In  Proceedings of the 29th International Conference on Software Engineering , pages 780-783, May 2007.  pdf  ·  site  ·  tool Martin P. Robillard and Gail C. Murphy.  Representing Concerns in Source Code.  ACM Transactions on Software Engineering and Methodology , 16(1):1-38, February 2007.  pdf  ·  site  ·  tool Martin P. Robillard, David Shepherd, Emily Hill, K. Vijay-Shanker, and Lori Pollock. An Empirical Study of the Concept Assignment Problem. Technical Report SOCS-TR-2007.3, School of Computer Science, McGill University, June 2007.  pdf  ·  data . Isaac Yuen and Martin P. Robillard. Bridging the Gap between Aspect Mining and Refactoring. Position paper for the  AOSD 2007 Workshop on Linking Aspect Technology and Evolution (LATE) , March 2007.  pdf 2006 Olivier Giroux and Martin P. Robillard.  Detecting Increases in Feature Coupling using Regression Tests.  In  Proceedings of the 14th ACM SIGSOFT International Symposium on the Foundations of Software Engineering , pages 163-173, November 2006.  pdf  ·  site Jean-Sébastien Boulanger and Martin P. Robillard. Managing Concern Interfaces. In  Proceedings of the 22nd IEEE International Conference on Software Maintenance , pages 14-23, September 2006.  pdf  ·  site ·  tool Martin P. Robillard.  Tracking Concerns in Evolving Source Code: An Empirical Study. In  Proceedings of the 22nd IEEE International Conference on Software Maintenance , pages 479-482, September 2006.  pdf  ·  site Martin P. Robillard. Tracking and Assessing the Evolution of Scattered Concerns.  In  Proceedings of the AOSD 2006 Workshop on Linking Aspect Technology and Evolution (LATE) , March 2006.  pdf 2005 Imran Majid and Martin P. Robillard.  NaCIN - An Eclipse Plug-In for Program Navigation-based Concern Inference. In  Proceedings of the Eclipse Technology Exchange at OOPSLA , pages 70-74, October 2005.  pdf  ·  site Martin P. Robillard and Frédéric Weigand-Warr. ConcernMapper: Simple View-Based Separation of Scattered Concerns. In  Proceedings of the Eclipse Technology Exchange at OOPSLA , pages 65-69, October 2005.   pdf  ·  site  ·  tool Martin P. Robillard.  Automatic Generation of Suggestions for Program Investigation.  In  Proceedings of the Joint European Software Engineering Conference and ACM SIGSOFT Symposium on the Foundations of Software Engineering , pages 11-20, September 2005.  [ACM SIGSOFT Distinguished Paper]   pdf  ·  site  ·  tool Martin P. Robillard.  Workshop on the Modeling and Analysis of Concerns in Software (MACS 2005).  Workshop summary.  Software Engineering Notes, 30(4), pages 1-3, July 2005.  pdf  ·  site Gail C. Murphy, Mik Kersten, Martin P. Robillard, and Davor Cubranic. The Emergent Structure of Development Tasks.  Invited Paper.  In  Proceedings of the 19th European Conference on Object-Oriented Programming , volume 3586 of  Lecture Notes in Computer Science , pages 33-48.  Springer-Verlag, July 2005.  pdf Martin P. Robillard and Gail C. Murphy.  Just-in-Time Concern Modeling.  Position paper.  In  Proceedings of the 1st International Workshop on the Modeling and Analysis of Concerns in Software.  Software Engineering Notes, 30(4), pages 1-3, July 2005.  pdf  ·  site Martin P. Robillard and Peri Tarr.  First International Workshop on the Modeling and Analysis of Concerns in Software (MACS 2005). Workshop description.  In  Proceedings of the 27th International Conference on Software Engineering , page 685, May 2005.  pdf  ·  site Martin P. Robillard and Gail C. Murphy. Evolving Descriptions of Scattered Concerns.  Technical Report SOCS-TR-2005.1, McGill University, Canada, January 2005.  pdf 2004 Martin P. Robillard, Wesley Coelho, and Gail C. Murphy. How Effective Developers Investigate Source Code: An Exploratory Study. IEEE Transactions on Software Engineering , 30(12):889-903, December 2004.  pdf  ·  site ·  data Gail C. Murphy, William G. Griswold, Martin P. Robillard, Jan Hannemann, and Wesley Leong.  Design Recommendations for Concern Elaboration Tools.  Chapter 22 of  Aspect-Oriented Software Development , pages 507-530.  Addison-Wesley, 2004. Martin P. Robillard and Gail C. Murphy.  Program Navigation Analysis to Support Task-aware Software Development Environments.  In Proceedings of the ICSE Workshop on Directions in Software Engineering Environments , pages 83--88.  May 2004.   pdf 2003 Martin P. Robillard.  Representing Concerns in Source Code. Ph.D. Thesis. Department of Computer Science, University of British Columbia.  November 2003.   pdf  ·  site ·  tool Martin P. Robillard and Gail C. Murphy.  Automatically Inferring Concern Code from Program Investigation Activities.  In Proceedings of the 18th International Conference on Automated Software Engineering , pages 225-234, October 2003.   pdf Martin P. Robillard and Gail C. Murphy.  FEAT: A tool for locating, describing, and analyzing concerns in source code. Research demonstration.  In  Proceedings of the 25th International Conference on Software Engineering , pages 822-823, May 2003. pdf  ·  site ·  tool Martin P. Robillard and Gail C. Murphy.  Static Analysis to Support the Evolution of Exception Structure in Object-Oriented Systems. ACM Transactions on Software Engineering and Methodology , 12(2):191-221, April 2003.   pdf  ·  site  ·  tool Martin P. Robillard and Gail C. Murphy.  A Study of Program Evolution Involving Scattered Concerns.  Technical Report UBC-CS-TR-2003-06, Department of Computer Science, University of British Columbia, 26 March 2003.   pdf 2002 Martin P. Robillard and Gail C. Murphy. Capturing Concern Descriptions During Program Navigation.  Position paper for the OOPSLA 2002 Workshop on Tool Support for Aspect Oriented Software Development.  November, 2002.   pdf Martin P. Robillard and Gail C. Murphy.  Concern Graphs: Finding and Describing Concerns Using Structural Program Dependencies. In Proceedings of the 24th International Conference on Software Engineering , pages 406-416, May 2002.  pdf  ·  site Martin P. Robillard.  A Representation for Describing and Analyzing Concerns in Source Code.  Doctoral Symposium abstract.  In Proceedings of the 24th International Conference on Software Engineering , pages 721-722, May 2002.   pdf  ·  site 2001 Gail C. Murphy, Robert J. Walker, Elisa L.A. Baniassad, Martin P. Robillard, Albert Lai, and Mik A. Kersten. Does Aspect-oriented Programming Work?.   Communication of the ACM , 44(10):75-77, October 2001.  pdf  ·  site Martin P. Robillard and Gail C. Murphy.  Analyzing Concerns Using Class Member Dependencies.  Position paper for the ICSE 2001 Workshop on Advanced Separation of Concerns in Software Engineering. pdf Wim De Pauw, Nick Mitchell, Martin P. Robillard, Gary Sevitsky and Harini Srinivasan.  Drive-by Analysis of Running Programs.  Position paper for the ICSE 2001 Workshop on Software Visualization.    pdf Gail C. Murphy, Albert Lai, Robert J. Walker, and Martin P. Robillard. Separating Features in Source Code: An Exploratory Study.  In  Proceedings of the 23rd International Conference on Software Engineering , pages 275-284, May 2001.  pdf  ·  site 2000 Pierre N. Robillard and Martin P. Robillard.  Types of Collaborative Work in Software Engineering.   Journal of Systems and Software , 53(3):219-224, 15 September, 2000.  site Robert J. Walker, Gail C. Murphy, Jeffrey Steinbok, and Martin P. Robillard.  Efficient Mapping of Software System Traces to Architectural Views>.  In  Proceedings of CASCON 2000 , pages 31-40, 2000.   pdf  ·  site Martin P. Robillard and Gail C. Murphy.  Designing Robust Java Programs with Exceptions.  In  Proceedings of the ACM SIGSOFT Eight International Symposium on the Foundations of Software Engineering , pages 2-10, November 2000.   pdf  ·  site Martin P. Robillard and Gail C. Murphy.  An Exploration of a Lightweight Means of Concern Separation.  Position paper for the ECOOP'2000 Workshop on Aspects and Dimensions of Concerns , June, 2000.   pdf 1999 Martin P. Robillard and Gail C. Murphy.  Migrating a Static Analysis Tool to AspectJ.  Position paper for the  OOPSLA'99 Workshop on Multi-Dimensional Separation of Concerns in Object-Oriented Systems , November, 1999.   pdf Martin P. Robillard and Gail C. Murphy.  Analyzing Exception Flow in Java Programs. In  Proceedings of the 7th European Software Engineering Conference and 7th ACM SIGSOFT Symposium on the Foundations of Software Engineering , volume 1687 of  Lecture Notes in Computer Science , pages 322-337.  Springer-Verlag, September 1999.  pdf  ·  site  ·  tool Martin P. Robillard.  Analyzing Exception Flow in Java Programs. Master's thesis.  University of British Columbia, 1999.   pdf 1998 Pierre N. Robillard and Martin P. Robillard.  Improving academic software engineering projects: A comparative study of academic and industry projects.   Annals of Software Engineering ,6:343-363, 1998.  Special issue on software engineering education.  Published April 1999.  site Other Bibliographies ACM Author Page DBLP Query Microsoft Academic Search Google Scholar ©  Martin Robillard  2013 · Based on a design by:  Luka Cvrk  · Released under a  Creative Commons LicencedocContentEnd
93docContentStartETX 2007 Eclipse Technology Exchange Workshop at  OOPSLA 2007 Home CFP Submissions Organization ProgramdocContentEnd
94docContentStartETX 2007 Eclipse Technology Exchange Workshop at  OOPSLA 2007 Home CFP Submissions Organization ProgramdocContentEnd
95docContentStartETX 2007 Eclipse Technology Exchange Workshop at  OOPSLA 2007 Home CFP Submissions Organization ProgramdocContentEnd
96docContentStartETX 2007 EclipsedocContentEnd
97docContentStartConcernMapper  Release Notes Release 2.0.3 (14 November 2008) Bug fixes. ISSUE (#187):   Inconsistent elements cannot be reloaded. ISSUE (#186):   Invalid access to disposed menu. ISSUE (#185):   ConcernMapper doesn't refresh if a parent of a ConcernElement was changed. Release 2.0.2 (16 July 2008) Small bug fixes to the user interface. ISSUE (#181):   Inefficient method. ISSUE (#180):   Update plug-in tests. ISSUE (#178):   Misleading message when loading invalid elements. ISSUE (#177):   Incorrect dirty state management when deleting concerns. ISSUE (#176):   Incorrect management of the dirty state when selecting concern elements. ISSUE (#166):   Agressive decorator activity. ISSUE (#164):   Port tests to JUnit4. Release 2.0.1 (25 January 2008) ISSUE (#167):   Can not display Concern Model with references to another project Release 2.0.0 (21 January 2008) ConcernMapper now supports attaching comments to concerns and elements in a concern model. ISSUE (#165):   Make the display of the degree slider optional ISSUE (#163):   Comments in concern models ISSUE (#161):   Silent failure for unreadable elements ISSUE (#160):   Retire legacy format ISSUE (#153):   Useless status bar message when concerns are selected Release 1.4.3 (18 June 2007) ISSUE (#142):   ConcernModel.MAX_DEGREE should be public or there should be a default addElement() ISSUE (#146):   NullPointerException throw if a manually edited concern (.cm) is dragged into the ConcernMapper view ISSUE (#148):   Specify format encoding ISSUE (#149):   Wrong formal results in ugly exception ISSUE (#151):   Add link to webpage Release 1.4.2 (30 May 2007) ISSUE (#100):   Add all elements of a class ISSUE (#129):   Testing Concern Loading ISSUE (#139):   No exception message on loading of invalid concern Release 1.4.1 (18 April 2007) ISSUE (#135):   Initialization problem on cleared workspace ISSUE (#136):   Rename action no longer visible ISSUE (#138):   Increase visibility of IConcernMapperView Release 1.4.0 (9 April 2007) Release 1.4.0 is a complete rework of ConcernMapper. The internal structure has been greatly simplified, resulting in many small performance improvements.  Java elements can (and should) now be serialized as Eclipse handles as opposed to the custom ConcernMapper Java handles. To preserve backward compatibility, an option in the ConcernMapper preferences allows users to choose between the two formats. Concern files should be converted to the new format as we plan to remove support for the old format eventually. See  Use the legacy (pre 1.4) format for serializing Java elements . ISSUE (#134):   InvocationTargetException when loading ISSUE (#133):   Use Eclipse handles for serializing Java elements ISSUE (#130):   Intermittent fillMenu bug Release 1.3.2 (29 March 2007) ISSUE (#132):  Deleting a concern breaks inconsistency management REFACTORING (#131):  Decouple DeleteAction from Element node ISSUE (#128):  Weak recovery from corrrupted files. Release 1.3.1 (3 January 2007) ISSUE (#110):  Unexported packages cause dependency problems. Release 1.3.0 (26 December 2006) ISSUE (#99):  Add elements from pop-up menu. Elements can now be added to the concern model from the context menu in any view or editor supporting Java elements. ISSUE (#104):  Model Inconsistency Architecture Refactoring (new ConcernModel API, backward-compatible). ISSUE (#93):  Port to Eclipse 3.0 plug-in format (OSGi manifest file). Now only the packages  ..cm.model ,  ..cm , and ..cm.model.io  are exported. ENHANCEMENT (#90):  Use generics in model package. Release 1.2.0 (20 June 2006) LICENSE:  Starting with Release 1.2.0, ConcernMapper is distributed under the terms of the  Eclipse Public License v. 1.0 ENHANCEMENT (#73):  View fully-qualified names BUG (#37):  Deal with inconsistencies (see  Manage Inconsistencies Task ) Release 1.1.3 (5 May 2006) ENHANCEMENT (#38):  Disconnect concern model from plugin ENHANCEMENT (#42):  Auto Save Concerns BUG FIX (#47):  Freshly loaded concerns are now clean ENHANCEMENT (#48):  Auto Load Concerns BUG FIX (#66):  Saving to an unavailable file now opens the save dialog BUG FIX (#67):  File extension preference fixed Release 1.1.2 (3 March 2006) ENHANCEMENT (#3):  Support JDT actions on JavaElements in the ConcernMapper View BUG FIX (#34):  Single refresh for multiple additions BUG FIX (#36):  Progress bar for loading concerns should work ENHANCEMENT (#39):  Redundancy in the release notes page Release 1.1.1 (14 February 2006) BUG FIX (#2):  Problem with the copy on drop Release 1.1.0 (19 August 2005) Filtering:  It is now possible to filter out elements in a concern model whose membership degree is lower than a certain value. Preferences:  ConcernMapper now has a preference page to set a number of preferences including: Decorator preferences. Automatically save concern models with .cm file extension. Drop to load:  It is now possible to load a concern model simply by dropping the file onto the ConcernMapper view. Set degree of multiple elements:  It is now possible to set the membership degree of several elements at once. Progress bar:  A progress bar indicates the state of the operation while loading a concern model. ConcernMapper Guide:  Help documentation accessible through the Eclipse Help table of contents. BUG FIX (#1):  A bug that created problems while loading concern elements when two types with the same qualified name existed in the workspace was fixed. Release 1.0.0 (13 July 2005) Initial release.docContentEnd
98docContentStartMartin Robillard Associate Professor · McGill University Home Publications Blog Activities Teaching Students Software The Software Technology Research GroupdocContentEnd
99docContentStartMartin Robillard Associate Professor · McGill University Home Publications Blog Activities Teaching Students Software TeachingdocContentEnd
100docContentStartMartin Robillard Associate Professor · McGill University Home Publications Blog Activities Teaching Students Software Professional ActivitiesdocContentEnd
101docContentStartIntroduction The Eclipse Platform allows you to view the files comprising a system, to modify these files, and to run a program.  This demo will give you a quick tour of the functionalities you need to know to carry out this study. Perspectives  The Eclipse graphical user interface (or Workbench), can be organized into various  perspectives .  A Perspective is simply a pre-determined set of views.  For this study, you will only use the  Java Perspective .  A perspective tool bar is on the left of the Eclipse Workbench.  To open the Java perspective, click on the top button and select  Java Perspective , or, alternately, click on the Java perspective shortcut button.  You can also use the general menu: select Window  |  Open Perspective , and select the  Java Perspective . By default, the Java perspective includes four views: The package explorer (on the left), the editor (in the middle), the outline view (on the right), and the tasks view (on the bottom).  If at any point your views get mixed up, you can come back to the default Java perspective by selecting the menu  Window |  Reset Perspective .  However, it is not recommended to do this as some short cuts which are preset for this study will be removed.  The package explorer, editor, and task views will be explained in detail as part of this demo.  The outline view will not be used in this study.  You should close the view by clicking on the X in the top right corner, and refrain from using it during the study. To open or close individual views, use the menu and select  Window  |  Show View . To close all the editors, use the menu and select  File  |  Close All . Tutorial Close the Java perspective (right-click on the button with the 'J' in its icon, in the left tool bar, and select  close . Open the Java perspective (in the same tool bar, click on the button with the 'plus' in its icon. Choose  Java  from the menu. Close the Outline view. Close all the editors. Close the package explorer. Open the package explorer (In the workbench menu, select  Window | Show View | Packages .  You might have to close the hierarchy view to reveal the package view). Package Explorer The Package Explorer contains the structure and files of the system you are to modify.  In this demo, we use the example system JHotDraw 5.3.  The top-level node in the package explorer is the the project: JHotDraw5.3.  Clicking on the plus sign expands the project to reveal its various components: in this case a single source directory.  Double-clicking on the source directory (or clicking on the corresponding plus sign) will reveal all the packages and source directories which constitute the system.  The package directories contain java files, and the other directories contains other source files such as icons. If you expand the  CH.ifa.draw.figures package , a collection of Java source objects will appear.  There are various actions you can perform on Java files.  Double-click on the ArrowTip.java  object.  The code for this file should appear in the editor.  You can also expand an object.  Expand the  ArrowTip.java  object. This will reveal the internal structure of the object, in this case, an import declarations node and the ArrowTip  class.  Expand the  ArrowTip class.  You will see the class members.  A red square indicates a private member, a yellow diamond a protected member, a blue triangle a default member, and a green circle a public member.  Clicking on a member will show the declaration of this member in the editor. To create a new element in the package explorer, right-click on a package a select  New . Tutorial Show the  CH.ifa.draw.applet.DrawApplet.java  file in the Editor. Display the  fDrawing  field in the window. Create a new class  Test  in the package  CH.ifa.draw.contrib . Editor The editor lets you change a file.  Modifications in a Java file are automaticaly compiled in the project when a file is saved.  To save a file in the editor, type  Ctrl-S , or use the  File  menu.  If file contains compilation errors, they will automatically be indicated in the editor.  Errors for which a suggestion is available are indicated on the left side bar with a yellow light bulb. Clicking on the light bulb will reveal a set of possible corrections.  Otherwise, the error will be indicated with a red X.  All errors also appear in the task view, in at the bottom of the screen. Clicking on a task in the task view will show the corresponding part in the code which needs to be addressed. The side bar on the right of the editor contains bookmarks for the various errors. The editor also supports an auto-completion feature.  When an identifier is partially typed, typing  Ctrl-Spacebar will attempt to complete the identifier.   Ctrl-Spacebar  after a type name will attempt to enter an import declaration for this name. Tutorial Open  ArrowTip.java .   Change getAngle()  to  getAngleX() . Observe the different errors and bookmarks.  Click on the errors in the Tasks view to go to the corresponding location in the editor.  Use the bookmarks in the right side bar to navigate to the locations of the errors.   Make a new TextFigure  object in the  ArrowTip constructor to show the autocomplete. Search It is possible to search for the references and declarations to a class or class member, either from the package explorer, or through a search menu.  To start a general search, select  Search  from the menu, then click on the  Java Search  tab. The results of the search will be displayed in a view below the editor.  Clicking on a search result will display the corresponding code in the editor. Right-clicking on a search result will allow you to perform new searches, for the references or declarations of the search result element. It is also possible to launch a search from the package explorer.  Right-click on an element and select references or declarations, and then  Workspace .  This will produce a list of all the elements in the workspace referring to the selected element. Tutorial Search for all  Text*  class declarations. Sort by parent name (Right-click in the search results view, and select  Sort by | Parent Name . Search for references to class TextHolder : Right-click on TextHolder  in the search results view, and select  References | Workspace . Display a few of them in the editor. Obtain all the methods accessing the field CH.ifa.draw.figures.TextTool.fTypingTarget (in the search results or in the package explorer, right-click on the field, and select  References | Workspace . Display the field accesses by double-clicking on the search results. Remove all searches by clicking on the 5th icon from the left in the search results tool bar. Running a program You run a compiled program by launching it through the run button on the menu, or through the  Run  |  Run... menu.  The configuration for the program you will need to execute will be pre-set for you. Tutorial Run the JHotDraw5.3 configuration.docContentEnd
102docContentStartWe ask you to make a change to the code of JEdit.  JEdit is a programmer's text editor developed in Java.  It allows users to open, modify, and save text files.  In this part of the study, you will first familiarize yourself with JEdit and one of its feature:  autosave .  You will then be asked to prepare a change to the autosave feature. JEdit Launch JEdit to check it out.  From the Eclipse Run configurations menu, choose  jEdit-4-1-pre6 .  You see JEdit appear.  Some warning messages will be displayed in the console.  This is normal.  Do not close JEdit. In JEdit, an opened text file is called a  Buffer . The following is an extract from the JEdit Manual (section 2.1): Several files can be opened and edited at once.  Each open file is referred to as a  buffer .  The combo box above the text area selects the buffer to edit.  Different emblems are displayed next to buffer names in the list, depending on the buffer's state; a red disk is shown for buffers with unsaved changes, a lock is shown for read-only buffers, and a spark is shown for new buffers which don't yet exist on disk. JEdit has an  autosave  feature.  The following is an extract from the JEdit Manual (section 3.3.1): "The autosave feature protects your work from computer crashes and such.  Every 30 seconds, all buffers with unsaved changes are written out to their respective file names, enclosed in hash ("#") characters.  For example,  program.c  will be autosaved to  #program.c# ." JEdit will also generate  backup  files, which are terminated with a tilde (~) character.  These have nothing to do with your task in this study.  You can completely ignore them. Saving a buffer using one of the commands in the previous section automatically deleted the autosave file, so they will only ever be visible in the unlikely event of a JEdit (or operating system) crash. If an autosave file is found while a buffer is being loaded, jEdit will offer to recover the autosaved data. The autosave feature can be configured in the  Loading and Saving  pane of tthe  Utilities>Global Options  dialog box; In JEdit, set the autosave frequency to 5 seconds. Open the file  C:\temp\Test.txt Add a character to the file and do not save the file. Look in  C:\temp .  You should see the autosave file. Save the test buffer in JEdit.  The autosave file should disappear. Add a character to the test buffer and do not save it. Wait 5 seconds. Kill JEdit using the terminate button on the Eclipse console (the button with the red square). Launch jEdit again. JEdit will attempt to recover the autosave file.  Click yes.   ATTENTION:  A bug in the code of JEdit will cause the program to hang if you do not click  yes  or  no  in the recovery dialog before the time in the autosave frequency.  To avoid this, just click yes or no before the 5 seconds (or whatever) of the autosave frequency are over.  If the program hangs, you can kill it using the terminate button on the console.  You do not have to worry about this bug for the study.  Your modification will pass the test cases even in the presence of this bug. From a user perspective, that's all there is to the autosave feature.  You can close JEdit now. Change Request You will need to implement the following change to jEdit: Modify the application so that the users can explicitly disable the autosave feature.  The modified version should meet the following requirements: jEdit shall have a checkbox labeled "Enable Autosave" above the autosave frequency field in the Loading and Saving pane of the global options. This checkbox shall control whether the autosave feature is enabled or not. The state of the autosave feature should persist between different executions of the tool. When the autosave feature is disabled, all autosave backup files for existing buffers shall be immediately deleted from disk. When the autosave feature is enabled, all dirty buffers should be saved within the specified autosave frequency. When the autosave feature is disabled, the tool should never attempt to recover from an autosave backup, if for some reason an autosave backup is present.  In this case the autosave backup should be left as is. Expert Knowledge You are given the following expert knowledge about the source code: A checkbox should be added to  org.gjt.jedit.options.LoadSaveOptionPane to enable/disable the autosave.  The autosave timer is in org.gjt.sp.jedit.Autosave . Test Cases To determine whether or not you have successfully implemented the change, we will perform the following tests: With autosave enabled, modify a buffer. The buffer should be autosaved within the specified time. Save the buffer.   The autosave file should be deleted. Modify the buffer.   The buffer should be autosaved within the specified time.   Disable the autosave feature.   The autosave file should be deleted. Enable the autosave feature.  The buffer should be autosaved within the specified time. Disable the autosave feature.  The autosave file should be deleted.  Modify the buffer.   No autosave file should appear. Enable autosave.  Close JEdit.  Launch JEdit.   Autosave should be enabled. Disable autosave.  Close JEdit.  Copy and rename the test file so it looks like an autosave file.  Launch JEdit.   No recovery should be attempted.  Autosave should be disabled. Enable autosave.  Close JEdit.  Copy and rename the test file so it looks like an autosave file.  Launch JEdit.  Recovery should be attempted.   Select YES within 5 seconds. Task You must now investigate the code related to the change you must make.  You can takes notes about the code to change, or other aspects you deem useful.  These notes should be stored in the file  Notes.txt  in the JEdit project. You must make  no change  to the source code.  You are not allowed to perform temporary changes, or try out different alternatives. Do not use the debugger. You have one hour to investigate the code.  Use this time to learn as much as possible about the code you must change. You will need to rely on this knowledge to perform the change in the required time. If you are ready to go, please notify the investigator.docContentEnd
103docContentStartIn this part of the study, you will familiarize yourself with the Eclipse platform.  Eclipse is the integrated development environment in which you will perform the task required for this study.  Please read on even if you are an experienced Eclipse user. You have 30 minutes to complete this step.  You can ask any questions to the investigator. To familiarize yourself with Eclipse, follow the instructions in the  Eclipse Tutorial  (also available as a link through the study documentation table of contents).  If you are an experienced Eclipse user, at least breeze through the tutorial to make sure you know all the features described. If you finish before the 30 minutes are over, you can use the extra time to familiarize yourself with Eclipse and ask questions.  If you feel this is not necessary, just notify the investigator that you are ready to move to the next step of the study. Before moving on to the next step of the study, the investigator will ask you a series of questions to ensure you understand the basic concepts of Eclipse necessary to carry out the study.docContentEnd
104docContentStartPerforming the Change You must now implement the change you have investigated. Implement the requirements described in the change investigation instructions. Implement the revised version of JEdit in the JEdit-4.1-pre6-exp  project.  Leave the original project unchanged.  When you run JEdit, make sure you select the  JEdit-4.1-pre6-exp  configuration. Do not use the debugger.  If you want to print to the console, you can use the following call: Log.log( Log.WARNING, null, "A message" ); , importing the class  org.gjt.sp.util.Log . Your implementation of the changes must past the tests described in the change investigation instructions. When you have completed the change, notify the investigator. You have up to two hours to complete the change.docContentEnd
105docContentStartMartin Robillard Associate Professor · McGill University Home Publications Blog Activities Teaching Students Software Software Research prototypes and software engineering tools developed by members of my research group. Software Description License Status Recodoc Analysis platform for developer learning resources. New BSD Active Qualyzer Tool to support researchers conducting qualitative inquiries by helping them manage and annotate interview transcripts. EPL Active API Explorer A recommendation-based tool to support discoverability and understandability of APIs. McGill Active DiffCat A tool for detecting non-esential differences in the revision histories of software systems. EPL Active Partial Program Analysis Static analysis framework that transforms the source code of an incomplete Java program into a typed Abstract Syntax Tree. LGPL Active SemDiff Software repository analysis framework. Bundled with a recommendation system that suggests how to adapt clients of changed libraries or frameworks. LGPL Active ConcernMapper Eclipse plug-in supporting advanced separation of concerns. EPL Legacy CloneTracker Eclipse plug-in to track clone regions in evolving source code. EPL Legacy Suade Eclipse plug-in for automatic generation of suggestions for program investigation. EPL Legacy JayFX Formerly known as JavaDB, the search engine powering FEAT is now distributed as a separate plug-in. EPL Legacy ConcernDetector Eclipse plug-in that automatically notifies developers when current changes overlap with documented concerns. EPL Legacy JMantlet Eclipse plug-in to manage and enforce concern interfaces in Java programs. GPL Legacy FEAT A tool for locating, describing, and analyzing concerns in source code. UBC Legacy Jex A tool for analyzing exception flow in Java programs. GPL Legacy ©  Martin Robillard  2013 · Based on a design by:  Luka Cvrk  · Released under a  Creative Commons LicencedocContentEnd
106docContentStartOPERATING SYSTEMS PROJECTS Here are the programming assignments as promised. You will hand in assignments via a hand-in facility. For a description of how to use it see  http://wocsinfo.cs.mcgill.ca/wiki.Handin You can make use of the labs in Trottier in doing these assignments.  These machines support Ubuntu Linux version 10). Please note that there will be a series of tutorials on Linux. You can find a schedule of when and where they are to be given at  http://socsinfo.cs.mcgill.ca/wiki/Unix_Seminars> There are some good C tutuorials on the web which you might wish to avail yourself of. Here are a couple: http://www.strath.ac.uk/IT/Docs/Ccourse http://www.lysator.liu.se/c/bwk-tutor.html For C FAQ: http://www/eskimo.com/~scs/C-faq/top.html For GDB (GNU Debugger) http://arioch.unomaha.edu/~jclark/gdb plus.html The assignments for this course are  individual . Talk to your colleagues, but don't hand in the same project(s). My policy for copying is simple: all of the parties get a zero on the assignment, and I don't want to hear any stories. Same policy if the solution comes via a third  party on the web. The lateness policy for projects is simple. The projects must be on time; no excuses (documented medical excuses are an exception). You get a zero if they are late. So, turn in your code in whatever state it happens to be by the deadline. It will be read through and graded. Just because a semi-colon is missing does not mean that you get a bad grade. And now a word from our institution. "McGill University values academic integrity. Therefore, all students must understand the meaning and consequences of cheating, plagiarism and other academic offences under the Code of Student Conduct and Disciplinary Procedures (see www.mcgill.ca/integrity for more information)." Project 1 .Due date:Friday, September 23, 11:59 PM Project 2  Due date:,Fridaty, October 21, 11:59 PM Project 3  Due date:Friday, Project 4  Due date:Friday, Project 5  Due date:docContentEnd
107docContentStartOPERATING SYSTEMS COMP 310/ECSE 427docContentEnd
108docContentStartPARALLEL SIMULATIN COURSE SCHEDULE The papers which we will read and the text/slides are in the table below. Date   Paper   Slides January 20   Computing GVT in Shared Memory Multiprocessors   10/21/05 and 10/12/05 January 25   An Efficient GVT Computation Using Snapshots January 27   An Empirical Evaluation of Performance-Memory Tradeoffs in Time Warp February 1 Febrary 3    The Dyanamic Load Balancing of Clustered Time Warp for Logic Simulation February 8    Large Scale TCP Models Using Optimistic Parallel Simulation February 10 February 15    On Checkpointing and Rolling Back in Time Warp February 17    DVS:An Object Oriented System for Distributed Verilog Simulationi February 22 February 24 March 1 March 3 March 8 March 10 March 15 March 17 March 22 March 24 March 29 March 31 April 5 April 7docContentEnd
109docContentStartProblem 2-A kernel timer In this assignment, you will use the  ITIMER_REAL, ITIMER_VIRTUAL, and  ITIMER_PROF interval timers to measure the processor usage of a process. You will prepare a report which provides real-time (i.e. wall-clock time) of execution using the ITIMER_REAL timer, processor time (the time that a process is actually running in both user and kernel space), user space time, and kernel space time. You can check the accuracy of your wall clock time by calling gettimeofday( ). Design your solution to have millisecond precision, although not all clocks do have millisecond precision. Use signals to keep track of the number of seconds for the 3 categories of time by raising signals once per second. Measure the times of a parent and two child processes, each executing the Fibonacci program for N=20,30 and 36. Background UNIX keeps track of  the time elapsed (seconds and microseconds) since the beginning of the UNIX "time epoch", i.e. since January 1, 1970, making use of two long integer variables. The data structure which the UNIX kernel uses for holding time values is struct timeval { long tv_sec; long tvusec; } UNIX updates the timeval structure by making use of programmable timer devices, which are used to produce interrupts at precise time intervals (e.g. 100 times per second in Linux). When the OS is initialized, it sets the time variable to zero and increments it each time an interrupt occurs. If the interrupt occurs every 10 ms. the timer device handler adds 10 ms. to the OS time variable tv_usec filed, and carries the overflow into the tv_sec field whenever there is an overflow. The kernel accumulates time and is responsible for managing timers for each process. For example,  in order to implement a scheduling strategy, each process has to keep a record of the amount of CPU time it has used since it last accessed the CPU. The kernel keeps track of three different time intervals for each process: ITIMER_REAL: Passage of real time, implemented using the it_real_value and it_real_incr fields. ITIMER_VIRTUAL: Passage of virtual time, i.e. this timer is incremented only when the process is executing in user mode. ITIMER_PROF: Passage of time during which the process is active (virtual time) plus the time that the kernel is doing work on behalf of teh corresponding process (e.g. executing a system call). Each of these timers is a "countdown timer"-it is first initialized with some value and then counts down to zero. Upon reaching zero, it raises a signal to another part of the system (either the OS or a user program). It then resets the period and starts counting down again. Each timer is initialized via the setitmer( ) system call: #include ..... setitimer{ int timerType, const struct timerval *value, struct itimerval *oldValue }; The struct itimerval includes the fields stuct itimerval { struct timeval it_interval; struct timeval it_value: }; More details can be found on the man page for setitimer( ). The timerType parameter is set to ITIMER_REAL, ITIMER_VIRTUAL, OR ITIMER_PROF\ (constants define in the sys/time.h include file) . The value parmeter is used to initialize the second and microsecond fields of the timer, the it_value difeines the current value for the timer, and the it_interval field defines the value used to rest the timer when it reaches zero. A timer's value can be read with the getitimer( ) system call: #include ... getitimer{ int timerType, const struct timerval *value, }; The value parameter is used to return the value of the kernel clock. The following code sets ITIMER_REAL and then reads it. #include ... sturct itimerval v; \ .... v.it_interval.tv_sec=9; v.it_interval.tv_userc=99999; v.it_value.tv_sec=9; v.it_value.tv_usec=99999; setitimer(ITIMER_REAL, &v;, NULL); ... getitimer(ITIMER_REAL, &v;); printf("...%1d seconds, %1d microseconds.....",..., v.it_value.tvsec, v.it_value.tv_usec, ...); .... When ITIMER_REAL reaches zero, it will be reset to (9, 99999) once again. SKELETON All forms of UNIX make use of signals, which are mechanisms which are used by a process to notify another process that an event has occurred. Some examples are  the user pressing the delete key, the run time system detecting an attempt to divide by zero, or one of the itimers reaching zero. Upon receiving a signal, the process executes code for that particular signal. Note that signals can be used between application processes. There are 31 different types of signals built into contemporary UNIX systems. The system include file, signal.h defines symbolic names for the signal types. For example, SIGINT is raised by the terminal driver when the user presses the interrupt character (delete or cntl-C). Application programmers are not allowed to create their own signals; however SIGUSR 1 AND SIGUSR 2  are included in most versions of UNIX for application to application signaling. A signal is raised by calling the kill (  ) function and identifying the process to receive the signal and the signal type. The receiving process can cause the signal to be handled in the default manner, to be ignored, or to be processed by user-defined code. For example, to ignore the SIGALARM signal, the process must execute the signal (SIGALRM, SIG_IGN) system call. Default handling is obtained via signal(SIGALRM, SIG_DFL). By supplying a function s the second argument in signal, the application can use its own code to process the signal. The function takes an integer argument and returns void. In the following code we provide an outline of  how how the mechanism operates. The code is not intended to do anything real; it is merely an illustration of how signals are raised and caught. #include static void sig_handler(int); int main void\{ int i, parent_pid, child_pid, status; /*Prepare the sig_handler routine to catch SIGUSR1_ AND SIGUSR2*/ if (signal(SIGUSR1, sig_handler)= =SIG_ERR) printf("Parent: unable to create sig_handler for SIGUSR1\\n"); if (signal(SIGUSR2, sig_handler)= =SIG_ERR) printf("Parent: unable to create sig_handler for SIGUSR2\\n"); parent_pid=getpid( ); if ((child_pid=fork( )= =0)) { kill(parent_pid, SIGUSR1);/*raise SIGUSR1*/ for (;;) pause( ); /*child waits for signal*/ } else\{ kill(child_pid, SIGUSR2);/*parent raises SIGUSR2*/ printf("Parent: terminating child with prejudice"); kill(child_pid.SIGTERM); /*Parent raises SIGTERM*/ wait(&status;); /*Parent waits for kid to terminate*/ printf("done\\n"); } } static void sig_handler(int signo){ switch (signo) { case SIGUSR1; /*incoming SIGUSR1 signal*/ printf("Parent: received SIGUSR1\\n"); break; case SIGUSR2; /*incoming SIGUSR1 signal*/ printf("Parent: received SIGUSR2\\n"); break; } return; } Solution Outline This is one possible outline for a solution.  Feel free to use your own approach. #include #include #include #include long unsigned in fibonacci(unsigned int n); //The following variables are used to record the accumulated times. They are set by //the signal handlers and are read by the processes when they report the results. static long p_realt_secs = 0, c1_realt_secs=0, c2_realtsecs =0; static long p_virtt_secs = 0, c1_virtt_secs=0, c2_virtt_secs =0; static long p_proft_secs = 0, c1_proft_secs=0, c2_proft_secs =0; static struct itimerval p_realt, c1_realt, c2realt; static struct itimerval p_virtt, c1_virtt, c2_virtt; static struct itimerval p_proft, c1_proft, c2_proft; main( int argc, char **argv) { long unsigned fib = 0; int pid1, pid2; unsigned int fibarg; int status; //get command line argument, fibarg (the value of N in the problem statement ... //Initialize parent, child1 and child 2 timere values p_realt.it_interval.tv_sec = ...; p_realt.it_interval.tv_usec = ...; p_realt.it_value.tv_sec = ...; p_realt.it_value.tv_usec = ...; ... //Enable parent's signal handlers signal(SIGALARM,....); signal(SIGVTALARM,...); signal(SIGPROF,...); //Set parent's itimers if(setitimer(ITIMER_REAL,...)== -1 perror("parent real timer set error"); if(setitimer(ITIMER_VIRTUAL,...)== -1 perror("parent virtual timer set error"); if(setitimer(ITIMER_PROF,...)== -1 perror("parent profile timer set error"); pid1=fork( ); if(pid1 == 0)\{ //Enable child 1 signal handlers (disable parent handlers) //Enable child 1 itimers //Set child 1 itimers //Start child 1 on the fibonacci program fib=fibonacci(fibarg); //Read child 1 itimer values and report them getiimter(ITIMER_PROF,...); getiimter(ITIMER_REAL,...); getiimter(ITIMER_VIRTUAL,...); printf("\\n"); printf("Child 1 fib = %1d, real time = %1 d sec, %1 d usec, %1d msec\\n", fib, c1_realt_secs, elapsed_usecs(c1_realt.it_value.tv_sec, c1_realt.it_value.tv_usec / 1000); printf("Child 1 fib = %1d, cpu time = %1 d sec, %1 d usec, %1d msec\\n", fib, c1_realt_secs, elapsed_usecs(c1_proft.it_value.tv_sec, c1_proft.it_value.tv_usec / 1000); printf("Child 1 fib = %1d, user time = %1 d sec, %1 d usec, %1d msec\\n", fib, c1_virtt_secs, elapsed_usecs(c1_virtt.it_value.tv_sec, c1_virtt.it_value.tv_usec / 1000); printf("Child 1 fib = %1d, kernel time = %1 d sec, %1 d usec, %1d msec\\n", fib, c1_delta_time(c1_proft, c_virtt), elapsed_usecs(c1_proft.it_value.tv_sec, c1_proft.it_value.tv_usec / 1000)- apsed_usecs(c1_virtt.it_value.tv_sec, c1_virtt.it_value.tv_usec / 1000); fflush(stdout); exit(0); } else\{ \ pid2 = fork( ); if (pid2 = = 0) { //Enable child 1 signal handlers ... //Set child 2 itimers ... Start child 2 on the fibonacci program fib= fibonacci (fibarg); // Read child 2 itimer values and report them .... } else{/*this is the parent*/ // Start parent on the fibonacci program fib =fibonacci(fibarg); // Wait for children to terminate waitpid(0, &status;, 0); waitpid(0, &status;, 0); //Read parent itimer values and report them ..... } long unsigned int fibonacci(unsigned int n) { if(n == 0) return 0; else if (n==1||n==2) return 1; else return(finbonacci(n-1) + fibonacci(n-2) } }docContentEnd
110docContentStartDISTRIBUTED ALGORITHMS COMP 575docContentEnd
111docContentStartParallel Gate Level Simulation The goal of this project is to develop a scalable distributed Verilog simulation suitable for execution on both distributed and shared memory multi-processors. The raison d'etre of this project is that gate level simulation has proved to be the principle bottleneck in digital circuit designs. Large designs (e.g. NVIDIA's game chips) can take weeks to simulate on conventional uni-processors. It has become necessary to employ parallel architectures in order to accommodate large circuit designs and to obtain significant reductions in the run time of these simulations. We chose Verilog because of its wide-spread industrial use as a design language. Fittingly, we are confronted with major challenges in distributed simulation on this project. A small laundry list includes (1)the simulation has a small computational granularity(2)a small fraction of the simulation processes are active at any time and (3)the load continuously changes its location throughout the course of the simulation. Our first approach to the problem was Clustered Time Warp (CTW). CTW is a hybrid approach, making use of clusters, or groups of simulation processes (gates) which are simulated sequentially while Time Warp synchronization is used between clusters. The use of clusters was inspired by the low level of activity at the individual gate level. Three checkpointing algorithms and accompanying strategies for rolling back clusters or LPs were developed. When compared to "standard" Time Warp, we saw a significant reduction in the exection time as well as memory savings. poralso developed a dynamic load balancing algorithm which reduced the running time of a CTW simulation by about 25%. Our next effort involved the use of an open source Verilog compiler (Icarus) as a front end to a distributed simulator which was based upon CTW. We called it DVS (Distributed Verilog Simulator). DVS consists of 3 layers. The bottom layer is the communications layer, which provides a common message passing interface to the upper layers. Inside this layer, the software communication platform can be either PVM or MPI. The middle layer is a parallel discrete event simulation kernel, OOCTW, an object-oriented version of CTW. It provides services such as rollback, state saving and restoration, GVT computation and fossil collection to the top layer. The top layer is the distributed simulation engine, which includes an event handler and an interpreter which executes instructions in the code space of a virtual thread. A partitioning framework was created and included in this environment in order to experiment with a number of partitioning algorithms. A simple hierarchical partitioning algorithm,CAKE,which minimizes the inter-processor communication was developed, resulting in the best speedup when compared to breadth first search, depth first search and string partitioning. DVS served as an experimental vehicle for research on event reconstruction, reinforcement learning, parallel Verilog compilation, compiled code simulation,distributed direct cancellation, and partitioning. Event reconstruction eliminates event saving by reconstructing events from the state queue. It results in a significant reduction in memory utilization compared to dynamic checkpointing. Reinforcement learning is an AI technique which we use to control the optimism in Time Warp via a bounded window. Because partitioning is central to the success of distributed simulation, we briefly summarize the work on static partitioning. Our static partitioning algorithm takes advantage of the hierarchical information described by Verilog modules and their instances. A Verilog instance represents one vertex in a circuit hypergraph. The algorithm attempts to minimize the cutsize of the hypergraph while maintaining a balanced load. A vertex can be flattened into multiple vertices in the event that a sufficiently good load balance is not achieved by the algorithm. In this case, the algorithm flattens the largest instance and moves gates between the partitions in order to improve the load balance.We  compared the algorithm to {\em hmetis}, a well-known interative algorithm which extracts clusters from a flattened netlist, achieving a 4.5 reduction in the cutsize of a circuit. It also resulted in a decrease in the simulation time compared to a sequential simulation. Our research then took a new turn in which resulted in a new simulation engine which we named XTW. In this project we developed a new event scheduling mechanism and a new rollback procedure \cite{Xu06}. LPs are grouped into a cluster-level queuewhich is used to schedule events in the cluster. Each input channel to a logical process (a gate) is managed separately in order to maintain the FCFS property. A separate LP input queue is also maintained together with a cluster queue, which is used for the actual scheduling of events. The resulting event scheduling mechanism has an O(1) complexity, a vast improvement over well-know scheduling mechanisms- the splay-tree,the heap,and the red-black tree. In addition, the cost of finding and deleting a scheduled event in the cluster queue is $O(1)$, a distinct improvement over CTW, for which the cost is $O(\log n)$. The new rollback procedure in XTW involves the replacement of anti-messages  by rb messages, resulting in a lower time complexity- $O(\log n)$ versus $O(n\log n)$ for anti-messages. The output queue at an LP is eliminated as well, resulting in a large savings of memory. Experimental results on a 90,000 gate circuit clearly demonstrate that XTW is far superior to CTW with any number of processors. CTW ran out of memory with more then 3 processors, while XTW continued to show scalable results. The scalability of XTW was investigated utilizing 5M,10M and 25M gate circuits, on a 128 node Beowulf cluster-our results indicated that XTW scales almost linearly with the number of processors and scales well with the size of the circuits. Several years ago, Sun made several of its old CPU designs (at the register transfer level) available to the design community to serve as benchmarks. We took advantage of this by creating gate level netlists which could be used as input to XTW. Our results for these (realistic) designs indicated that XTW is indeed highly scalable. For example, we observed 4 million gates per second for an 8k gate Viterbi decoder. Recently, our work has focused on the use of AI techniques to develop dynamic load balancing algorithms and to control the optimism in Time Warp by means of a bounded window. The bonded window mechanism prevents Time Warp can become unstable in the event that its optimism runs unchecked, hence it is important to control it. A number of classical AI techniques were used including genetic algorithms, learning algorithms and simulated annealing for both of these objectives. Several papers which are representative of the work which we have done on gate level simulation are listed below. On the Scalability and Dynamic Load Balancing of Time Warp  Scalability of XTW for the Sun CPUs and AI based algorithms for dynamic load-balancing. Towards Large Scale Optimistic VLSI Simulation Describes XTW along with a performance study.docContentEnd
112docContentStartLecture slides Introduction Chapter 1 Chapter 2 Chapter 3 Chapter 4 Chapter5docContentEnd
113docContentStartSchool of Computer Science Computer Science 308-767: Parallel Programming Life and death in the ocean: fish and sharks (WATOR)docContentEnd
114docContentStartOS COURSE SCHEDULE An approximation to the schedule is below. By approximation I mean that I will make an attempt to follow it, but no guarantees. The problems which you should do are part of the table. The problems should not be handed in-they are intended to help you prepare for the midterm and final exams. You can do them with classmates, as this is a great way to learn. Date   Topic   Problems September 2   Introduction to OS   3,7,19,20,28 September 7   Introduction to OS September 9   Processes and Threads September 14   Processes and Threads September 16   Processes and Threads September 21   Processes and Threads September 23   Processes and Threads   26,33,29,31,44,46,47 September 28   Processes and Threads September 30   Memory Manangement October 5   Memory Manangement October 7   Memory Manangement October 12   Memory Manangement   7,9,10,11,15,26,29,33 October 14   MIDTERM October 19   File Systems October 21   File Systems   11,14,19,20,21,27,33,32 October 26   Input/Output October 28   Input/Output   12,15,21,8,25 November 2   Deadlocks November 4   Multiprocessor OS November 9   Multiprocessors OS November 11   Multiprocessor OS November 16   Multiprocessor OS November 18   Security November 23   Security November 25   Security November 30   Multimedia OS December 2   Multimedia OSdocContentEnd
115docContentStartSchool of Computer Science Computer Science 308-767: Parallel Programming The Big Dance as seen by Barnes and HuttdocContentEnd
116docContentStartProblem 3-Simulation of an RR Scheduler In this exercise, you will write a discrete event simulator which you will use to analyze the RR scheduling mechanism. First a bit of background on discrete-event simulation, followed by a description of the problem itself. Computer simulations are programs which are used to model the behavior of a real system and predict its behavior by examining the behavior of the model instead of the system itself. These programs are widely used  to determine the behavior of man-made systems (aircraft, computer systems and networks) before they are built. They are also used to examine the behavior of natural systems such as the human brain and planetary motion. A simulation program is comprised of a set of modules, each of which is meant to model part of the system which we are studying (the target system). For example, one module might represent a the enqueuer portion of a scheduler, another the ready list, another the dispatcher. The enqueuer module places the jobs in the ready list module, the dispatcher module retrieves simulated jobs from the simulated ready list, etc. Each simulation module is constructed as a simulation procedure, i.e. one or more programming language functions (think C or C++). As an example, consider the behavior of an airport reservation agent (they might be machines now) who are supposed to help passengers with their reservations, and ask them if they are terrorists. When a passenger enters the airport he goes to the back of a line to wait for help from the agent, waits his turn and is served by the agent, after which he goes on his way. The airlines might be interested in determining the average waiting time and the maximum waiting time for a customer, given a particular arrival pattern by the passengers. To answer these questions, we can construct a model of the system and simulate it. In a discrete-event model, the entities of interest (agents, passengers in the example)  are represented by data structures. The state of the system is represented by values assigned to these data structures. In a discrete event system, the state of the system changes at discrete instants in time (as opposed to continuous simulations). In the airport model, if we assume that the simulation starts with all of the agents idle, then the first transition occurs when the first passenger arrives to be served. The events in the simulation would be: Event 1 (Passenger arrival) Causes the simulator to run a function which creates a new instance of the passenger data structure and puts the instance into a data structure which represents the line of waiting passengers. Fields in the passenger data structure should identify the passenger, save the time of the passenger arrival, save the time at which the passenger begins service, and save the time at which the passenger leaves. These entities enable us to determine the waiting time of the customers. After the passenger arrives, the function should place him on a line. The function should check to see if there are idle agents; if so, the agent should be paired with the passenger. This time at which the next passenger arrives can also be scheduled. Event 2(Customer departure) When a passenger begins service, the corresponding fucntion determines the time at which the service completes, and adjusts the data strutures to reflect this, and schedules the next event #2. If there are no passengers waiting, then the agent waits. This function can determine the amount of time that the agent is busy and is waiting. In general, a simulation program is comprised of a simulation application and simulation kernel. The application part is specific to the model, e.g. the airport model or a model of the RR scheduling algorithm. The kernel's job is to manage simulated time, calling the functions associated with the events at the right times. An outline of the simulation kernel follows. simulated-time==0; while(true) { event=select-next-event(); if (event->time>simulated_time) simulated_time=event->time; evaluate(event->function,....); } You will need to implement a simulation kernel and the simulation application for this exercise. Here is an outline for the kernel. void runKernel(in quitTime) { Event *thisEvent; if (wuitTime <=) quitTime=99999999; simTime==0; while(simTime < quitTime) { if(eventList= =NIL { thisEvent ==eventList; eventList=thisEvent->next; simTime=thisEvent->getTime( ); thisEvent->fire(); delete(thisEvent); }; } You will need a data structure to keep the events in time-stamped order. A priority queue (heap) ordered by the time of each event is a standard approach. Now for the simulation application. Design it so that each procedure implements data structures that you need (e.g. the system's ready list) or procedures to change the simulations's state(creating a new job, entering the job into the ready list, dispatching a job, simulating an interrupt, etc). First define the modules that you will need in the program, and then encode them as procedures. Finally, you should instrument your simulation appliction to collect the necessary information you will need to measure the performance of the system. You will need to compare the performance of the system with different context switching times and time-slice values. Create an input file with entries having the form (job ID, job arrival time, job service time). Run the simulations for dispatcher overhead times to be 0,5,10,15,20,25 msec. and time quanta of 50,100,250 and 500 msec. Run the simulation a number of times to gather the information and use a graphing package to plot the performance. You can decide on what the package should portray.docContentEnd
117docContentStartSelected Papers Here are  some of my (recent) papers. In the event that you are interested, you can click on the title in order to download the paper. On the Scalability and Dynamic Load Balancing of Time Warp VXTW is described A Multi-State Q-Learning Approach for the Dynamic Load Balancing of Time Warp XTW, A Parallel and Distributed Logic Simulator   Describes XTW On Determining How Many Computers to Use in Parallel VLSI Simulation DVS:An Object Oriented System for Distributed Verilog Simulation   Describes DVS Towards Distributed Verilog Simulation A Multiway Design Driven Partitioning Algorithm for Distributed Verilog Simulation   Static partitioning using DVS A Design Driven Partitioning Algorithm for Distributed Verilog Simulation Nominated for the best paper award at Pads 2007. The Dependence List in Time Warp   Nominated for the best paper at Pads 2001 Event Reconstruction in Time Warp Using Genetic Algorithms to Limit the Optimism in Time Warp Optimizing Time Warp Simulation with Reinforcement Learning Techniques Parallel Logic Simulation of Million Gate VLSI Circuits An Efficient GVT Algorithm Using Snapshots On Rolling Back and Checkpointing in Time Warp   Describes Clustered Time Warp Dynamic Load Balancing of Clustered Time Warp for Logic SimulationdocContentEnd
118docContentStartA Simple File Manager In this exercise, you will write a simple space file manager. In doing so, you will make a number of simplifying assumptions: Your on-disk file descriptor will fit into one disk block. It should contain (1) a filename of six or fewer characters (2) at most four disk blocks per file (you can use 2-byte block addresses) The disk blocks are small, e.g. 50 bytes per block Directories can contain the smallest amount of information possible, just enough to get your file manager working Don't implement file sharing (no locks) Don't implement file modes (read,write,execute) Don't include protection in your file system Don't implement path names, just filenames within the current directory Don't implement buffering Part A The file manager should implement the following API; int fLs(); int fOpen(char *name); int fClose(in fileID); int fRead(in fileID,char *buffer,int length); int fSeek(int fileID,int position); Generally, fOpen(),fClose(),fRead(),and fSeek() functions should behave like the UNIX kernel functions open(),close(),read(), and lseek() respectively. The behavior will be modified by your asumptions, of course. For example, fOpen() does not have a flag parameter, so your function should operate as if O_RDWR | O_CREAT were used in the kernel function equivalent. The fLs() fuinction should print all of the information your systme knows about the file, then return -1 if you detect an error and 0 otherwise. Use the follwoing disk interface: #define NUM_BLOCKS 100 #define BLOCK_SIZE 50 void initDisk(); int dRead(int addr, char *buf); You may also add a few more routines to the API-for example if you wish to initialize the file manager prior to using it the first time. Although it is not necessary, you can add a fcntl/ioctl command if you need one. Part B The file manager must contain the following API: int fMkdir(char *name); int fCd(char *name); int fWrite(int fileID, char *buffer, int length); Generally, the fWrite() functions should behave like the UNIX kernel write() function, except  with behavior that is simplified by the assumptions. It returns the number of bytes actually written by the function call. The fMkdir()  function should create the named directory, then return -1 if you detect an error and 0 otherwise. The fCd() function should change the current directory to the named directory if it exists, then return -1 if you detect an error and 0 otherwise. Part C  Write a driver program that tests each function and feature, e.g. sub-directories. Background This section will help with the organization of your file system Disk Layout When a disk is formatted, it is done so with the expectation that the file manager will access certain information which it needs in fixed locations. You will need to define your own format for your simulated disk. File Descriptors  When the file manager laods the external file descriptor into primary memory, it copies all of the information from the disk representation,a ndadds other information that it need to manage the open file. For example, the external file descriptor does not indicate which user and process currently has the file open or what the current location is for the file pointer. When the file is opened, the file manager looks up the file in the directory to obtain the inode. The inode is copied into a memory-resident set of inodes. The file manager then creates an entry in the file table that will contain the new dynamic information needed by the process when the file is open (e.g the struct file defintion in /usr/src/linux/include/linux/fs.h). The file table entry references the inode. Finally, the file manager creates an entry in the process's file descriptor table; this entry establishes the "file identification number" returned by the open command and points to the file table entry. Directories  A directory entry must contain enough information to allow the file manager to match a character string filename with the entry's name and to find the external file descriptor on the disk if the names match. In a UNIX system, the directory entry must have only the name and the inode number for the file. To list the files in a directory, the file manager traverses the directory contents, printing the name from each entry and then retrieving any other information to be included in the listing directly from the inode. The layout for a directory entry is shown in the table below. All multibyte integers are in little-endian order, meaning that the least significant bit is stored first. Offset   Length   Description 0x00   8   Filename 0x08   3   Extension 0x0B   1   Bit field for attributes 0x0C   10   Reserved 0x16   2   Time 0x18   2   Date 0x1   2   Starting cluster number A 0x1C   4   File size in bytes The filename and extension are stored as uppercase ASCII characters. Invalid entries have names beginning with 0x00(the entry has not been used before) or 0xe5(the entry was used before, but has been released). The starting cluster(sector) number cannot reference serctors used for teh boot record or the root directory. Hence if the starting clsuter number is k, it acttually refers to logical sector number 31+k. The attribute byte stores bits for attributes, similar to UNIX. The bit fields are shown in the table below. Bit 0 is the least significant bit. A bit set to 1 means that the file has that attribute, and 0 means it does not have it. Bit   Mask   Atribute 0   0x01   Read-only 1   0x02   Hidden 2   0x04   System 3   0x08   Volume lable 4   0x10   Subdirectory 5   0x20   Archive 6   0x40   Unused 7   0x80   Unused Attacking the Problem You need to create a disk layout and file descriptor formats. You are given a disk interface are are required to provide an API. Disk Interface The virtual disk is implemented s blocks of primary memory. It includes a statement to randomly produce disk read and write errors. You can  change the threshold of the statment. Here is code on which to base your virtual disk code. disk.h #include #include NUM_BLOCKS       100 #incldue BLOCK_SIZE        50 #include RELIABILITY      0.95 #include PERIOD           2147483647.0 #include ERROR            0 #include NO_ERROR         1 #include NULL             0 void initDisk(); int dRead(int addr,char *buf); int dWrite(int addr, char *buf); disk.cs #include #include "disk.h" static int threshold; static char *bList[NUM_BLOCKS]; void initDisk() { int i: for(i=0; i<NIM_BLOCKS; i++) bList[i] = NULL; threshold = (int) (RELIABILITY*PERIOD); sleep(3); } int dRead(int addr,char *buf){ int i; char *bufPtr; if(addr >= NUM_BLOCKS) return error; if(rand() > threshold)return error; if(bList[addr] != NULL { bufPtr=bList[addr]; for(i=0; i<BLOCK_SIZE;i++)buf[i]=*bufPtr++; } else for(i=0;i<BLOCK_SIZE;i++)buf[i]=0; return no_error; } int dWrite(int addr, char *buf) { int i; char *bufPtr; if(addr>=NUM_BLOCLS) return error; if(rand()>threshold) return error; if(bList[addr]==NULL) bList[addr]=(char*)malloc(BLOCK_SIZE); bufPtr=bList[addr]; for(i=0;i<BLOCK_SIZE;i++) *bufPtr++=buf[i]; return no_error; } This virtual disk statically allocates 100 blocks of 50 bytes each, then reads and writes those with the possibility of I/O failure. You may change the block size and the reliability values. Game Plan The disk simulation code does not format the disk. You will need to design your own low-level format. No bootstrap area is needed, but information on the layout of the disk and the root directory are going to be needed. You will need to decide how inodes are laid out on the disk(use inodes please) Design your directories. You need to be able to associate a name and a file descriptor. Then implement the root directory. Build a tool which creates a simple file system with a root dierctory and a few files. Build a tool which dumps the virtual disk contents so that you can analyze it as you design it and also debug it. Implement your first version of the fls() command which works only on the file system root directory. After implementing subdirectories, you can finish fls(). Design and implement the file descriptor and the open-file data structure(s). Implement the commands on the API. Start with the commands which only read the directory and don't write to it. Implement the file operations-open/close and read/write. Start with the reads. Implement a fWrite(), which means that you need to do block allocation. Implement subdirectories. Implement fmkdir() and fCD(). Write your driver program as you are developing the parts. When you implement fLs(), your driver only needs to invoke the fLs() function. Test your program as you go along.docContentEnd
119docContentStartParallel and Distributed Simulation Papers For each paper, you can click on  the title  to download it. On the Scalability and Dynamic Load Balancing of Time Warp A Multi-State Q-Learning Approach for the Dynamic Load Balancing of Time Warp XTW, A Parallel and Distributed Logic Simulator   Describes XTW On Determining How Many Computers to Use in Parallel VLSI Simulation DVS:An Object Oriented System for Distributed Verilog Simulation   Describes DVS Towards Distributed Verilog Simulation DVS: An Object Oriented Framework for Distributed Simulation Design Driven Partitioning XTW, A Parallel and Distributed Logic Simulator Parallel Event-Driven Network Simulations Using the Hodgkin-Huxley Neuron Model On Checkpointing and Rolling Back in  Time Warp Improving Lookahead in Parallel Discrete Event Simulations of Large-Scale Applications using Compiler Analysis Event Reconstruction in Time Warp Addressing Blocking and Scalability in Critical Channel Traversing The Dependence List in Time Warp Parallel Network Simulation Under Distributed Genesis Hybrid Packet/Fluid Flow Network Simulation A Scalable Architecture for Supporting Interactive Games on the Internet Stoneaxes and Warhammers:A Decade of Distributed Simulation in Aviation Research Large-Scale TCP Models Using Optimistic Parallel Simulation Optimistic Parallel Discrete Event Simulations of Physical Systems using Reverse Computation Performance Benchmark of a Parallel and Distributed Network Simulator XTW, A Parallel and Distributed Logic Simulator 7 O'Clock, A New Network GVT Algorithm Using Atomic Operations Batch Based Cancellation: A Rollback Optimal Cancellation Scheme in Time Warp Simulations Analysis of Bounded Time Warp and Comparison with YAWNS An Empirical Evaluation of Performance-Memory Trade-Offs in Time Warp Clustered Time Warp and Logic Simulation Conservative Simulation of Large-Scale Network Simulations The Dynamic Load Balancing of Clustered Time Warp for Logic Simulation Integrated Fluid and Packet Network Simulations Large Scale Network Simulation:How Big? How Fast? Optimal Memory Management for Time Warp Parallel Simulation An Efficient GVT Computation Using Snapshots An Empirical Evaluation of Performance Memory Trade-Offs in Time Warp Optimistic Fossil Collection for Time Warp Simulation Performance Benchmark of a Parallel and Distributed Network Simulator Event History Based Sparse State Saving in Time Warp Parallel Simulation on a Hypercube Multiprocessor Computing Global Virtual Time on a Shared Memory Multiprocessor musik-a microkernel for parallel/disributed simulation systems analysis of time warp on a 32,768 processor ibm blue gene/l supercomputer timewarp rigid body simulation a simulated annealing technique for optimizing time warp simulation scalable time warp on blue gene supercomputers genesis parallel and distributed spatial simulation of chemical reactions Bigsim-a Parallel Simulator for the Performance Prediction of Extremely Large Machines A new asynchronous methodology for modeling  of physical systems: breaking the curse of the Courant condition Parallel Discrete Event n-Body Dynamics A Genetic Algorithm for Optimistic Parallel Discrete Event SimulationdocContentEnd
120docContentStartDISTRIBUTED ALGORITHMS PROJECTdocContentEnd
121docContentStartSchool of Computer Science Computer Science 308-767: Parallel Computing Gaussian Elimination Using MPI : In this assignment, you will use what you learned about parallelizing Gaussian elimination with partial pivoting to develop a scalable message passing implementation using MPI. You should write your program in C+MPI. You may want to use some of the MPI collective communication primitives in your program. Use problem size 6000 x 6000 to evaluate the performance of your implementation. You should randomly generate the input matrix  a  and solution vector  b . Your program should measure the elapsed time of your solver, which includes the elimination and back solve phases, but not the matrix initialization or answer verification. Write a document that describes how your program works. This document should  not  include your programs, though it may include figures containing pseudo-code that sketch the key elements of your parallelization strategy for each implementation. Explain how your program partitions the data, work, and exploits parallelism. If your program uses collective communication, explain how; if not, explain why not. Your writeup should include a table with timing measurements for your solver on the processors which you use. Plot the  parallel efficiency of your program executions. The x axis should show the number of processors. The Y axis should show your measured parallel efficiency for the execution.docContentEnd
123docContentStartSchool of Computer Science Computer Science 308-767: Parallel Programming Introduction Parallel Programming Platforms Parallel Algorithm Design Comuunication Operations MPI Shared Memory Programming Dense Matrix GraphsdocContentEnd
124docContentStartSchool of Computer Science Computer Science 308-767: Parallel Programming Instructor : Carl Tropper 112N  McConnell Phone: 398-3743 E-mail:carl@cs.mcgill.ca Office hours Tuesday, Thursday 10:30-12:00 Teaching assistant TBAi 2@cs.mcgill.ca Office hours: TBA Course Description : In attempting  to explain the natural wold, it is standard practice for a scientist to develop  a theory and to then subject this theory to experimental verification. Similarly, engineers build prototypes to investigate their designs. This paradigm is becoming increasingly difficult to pursue because of the sheer size and complexity of the systems which we are trying to design and the phenomena which we are trying to understand. Trying to subject theories on the evolution of the galaxy or climate change to experimental verification or building a new aircraft on the basis of a paper design are not realistic approaches.  This traditional approach is largely being replaced by a new paradigm, a computational science approach in which high performance computer systems are used to simulate the phenomena which we wish to either explain and the systems which we wish to design.  Examples of this  approach in science include global climate modeling, computational chemistry and brain modeling. Familiar examples in engineering include computational fluid dynamics for aircraft design, semiconductor design and nuclear weapons design. In the business world, economic forecasting models drive both business decisions and stock trading programs. One inescapable conclusion is that the computing platforms on which we implement these numerical models (or simulations) must be powerful.  They are also parallel machines. The reason that they are parallel is that there are limitations to the number of transistors which can be packed onto a chip and we are rapidly approaching this limit, in spite of all of the efforts made by VLSI designers. Moore's law ( enunciated in 1965)  predicted that the number of transistors which could be etched on a chip would double once every 18 months. In 1975 that meant about 4,000. In 2006 it means about a billion!! In that time period the clock rate of a microprocessor went from about 1 MHz to 1 GHz. This came at a cost, however. Moore's second law saw in increase in the cost of a semi-conductor foundry go from about  $10,000,000 to $10,000,000,000 (constant 1995 dollars).  There is an inevitable consequence, which is physical. There is a limit to how far a transistor can shrink. At present, they are not the size of atoms, which will be necessary in order to continue this growth. In short, the future is parallel- for those of little faith, you need look no further then the  January, 2006 announcement by Apple that the iMac and the MacBook Pro are now dual core machines. Syllabus The focus of this course is on parallel programming. There will be an emphasis on the use of clusters because they are there-by this I mean that they are cheap and can be built from off the shelf CPU's and networks. Here is an outline of the topics which we are going to cover. Parallel machine and programming models-shared memory, distributed shared memory, message passing Programming techniques-partitioning, pipelined computations, synchronous computations, load balancing and termination detection Algorithms and applications-linear algebra, partial differential equations, particle methods. These topics are subject to time limitations and the instructor's whims ...... How the course will be run : I am going to cover material from the course text and other places in the form of lectures. You will build parallel programs based on the material which we cover in the course. This is a seriously hands on course. You have the option of replacing one of the assignments which I give you with a project of your very own. It can be from your research. Needless to say, I have to be happy with it. I will expect a detailed description of the algorithms which you chose to implement, a detailed description of related algorithms, a detailed description of the application which you chose along with your motivation for chosing the problem. Class Materials Texts There is a text for the course: Parallel Computing, by Grama,Gupta, Karypis,Kumar, Addison-Wesley. It is in the bookstore. Other texts for the material which we plan to cover include Parallel Programming, by Wilkinson and Allen ( Pearson-Prentice Hall) Fundamentals of Parallel Processing by Jordan and Alaghband (Prentice Hall) On-line references/course materials The McGill Clumeq Supercomputer web page: Clumeq There are a number of workshops and tutorials which are available through Clumeq on parallel programming. Designing and Building Parallel Programs, by Ian Forster. Originally published as a textbook, this is a web version of the text. Designing and Building Parallel Programs The IEEE on-line Parallel Processing Home-Page: IEEE Parallel Processing Home mpi:  mpi mpi-standard:  mpi-standard mpi tutorials:  tutorial web pages:  web-pages mpich 2:  mpich2 mpi-text:  Using MPIt Slides for the course can be found at Course slides . The slides are in powerpoint-if you don't have it on your machine, you can download open office. Course Evaluation Assignments: 100% Assignments fishnsharks distributed memory Gaussian nbodydocContentEnd
125docContentStartSchool of Computer Science Computer Science 308-575 Distributed Algorithms Papers Papers  : For each paper, you can click on  the title  to download it. An Optimal Algorithm for Mutual Exclusion in Computer Networks ricart-agrawala pseudocode Detecting Termination of Disributed Computations Using Markers An improved algorithm for decentralized extrema-finding in circular configurations of processors An O(nlogn) Unidirectional Distributed Algorithm for Ectrema Finding in a Circle Decentralized Extrema Finding in Circular configuration of processors Time,Clocks and Ordering of Events in a Distributed System Termination Detection of Diffusing Computations Derivation of a termination detection algorithm for distributed computations A Distributed Solution of the Distributed Termination Problem Distributed Deadlock Detection A Distributed Graph Algorithm:Knot Detection Distributed Snapshots On Distributed Snapshots Efficient Algorithms for Distributed Snapshots and GVT Computation Distributed Shortest Path Depth Parallel Operations on a Distributed Graph Distributed Algorithm for Minimum Weight Spanning Trees The Byzantine Generals Problem Impossibility of distributed concensus with one faulty process garbagedocContentEnd
126docContentStartComputer Science 308-655 Parallel and Distributed Simulation Instructor Carl Tropper Office:112N McConnell email: carl@cs.mcgill.ca Phone: 398-3743 Office hours:TBA Course meets on: Teaching assistant Sina MerajiA e-mail:smeraj@@cs.mcgill.ca Office hours: TBA Course Description : Discrete event simulation has long played a central role in modeling and design of large systems, both natural and man-made. Man-made systems include VLSI circuitry, computer systems and networks and manufacturing simulations. Natural systems include modeling of the brain and cosmology simulations. Really, the list is endless. As our desire to understand complicated natural phenomena and to build larger systems has grown, so have the size of the simulations. With the advent of parallel computers (think multi-core as well as distributed memory machines) our ability to simulate these systems can keep pace. Efforts to make use of parallel simulation include: The paralllel simulation of VLSI circuitry can give an enormous competitive advantage to a circuit manufacturer. This is an area being actively pursued by my research group. The  design of large manufacturing environments for VLSI wafers. Efforts to create a realistic simulation of the brain. (Parallel)N-body simulations, which have applications in astrophysics,molecular dynamics and computer graphics. This is an active research area in my group. In the area of computer networks, an on-going effort is being undertaken to provide a parallel simulation of the Internet. The intention is to provide a realistic test-bed for the development of new Internet protocols and to locate performance problems. To date, it has been necessary to do experiments with actual networks. Military simulations. A major goal in this area is the unification of simulations of different aspects of combat together. The inclusion of live exercises into the scenario creates a training environment. A descendent of this military training simulation environment is a virtual laboratory , in which scientists interact with a simulation in a virtual environment. (e.g. The CAVE Automatic Virtual Environment) Distributed gaming simulations are also an outgrowth of the DIS-RT (Distributed Interactive Real Time Simulation) area. Air-traffic simulations. Like any distributed program, a distributed simulation is composed of processes which communicate with one another. This communication may occur via shared memory in a shared memory multiprocessor or via message passing in a distributed environment. The processes in distributed simulation are each intended to simulate a portion of the system being modeled and are referred to as Logical Processes (LPs). An LP creates events, sends events to other LPs and  receives events from other LPs in the course of a simulation. Associated with each LP are input queues used to store messages from other LPs, state variables which reflect the state of the physical process which is being modeled, and a local simulation clock. The purpose of the simulation clock is to capture the advance of simulation time at each LP. The treatment of time in a distributed system is of fundamental importance to understanding and building distributed systems. A distributed simulation poses a particularly vexing problem. In a uniprocessor, the events in a discrete event simulation are stored in a priority queue nd simulated in the order of the smallest timestamp first. This is easily done in a uniprocessor because all of the events in the simulation are stored in memory. In a distributed simulation, however, the events are spread out among the processors involved in the simulation. A causality violation occurs if we simulate an event at an LP and an event generated by another LP with a smaller timestamp arrives afterwards in real time. This late arrival can easily cause incorrect results in the simulation. In a military simulation it matters in which order the two events "aim the gun" and "fire the gun" are executed. The central problem of distributed simulation is the development of synchronization algorithms which are capable of maintaining causality and which do so with minimal overhead. This overhead can be in the form of increased memory demands and increased execution time. Two primary approaches to synchronization algorithms have been developed, the conservative and the optimistic classes of algorithms. A conservative algorithm is characterized by its blocking behavior. In a conservative simulation, if one of the input queues at an LP is empty, the LP blocks, awaiting a message from another LP. This behavior insures causality. However, it does so a price. To begin with, when an LP suspends processing there may be an increase in the execution time of the n addition, it is entirely possible for deadlocks to form. This occurs if a group of LPs is arranged in the form of a cycle such that each LP in the cycle is awaiting a message from its predecessor in the cycle. More generally, a deadlock occurs if a knot of LPs forms. Hence, if a conservative synchronization algorithm is used in a distributed simulation, it becomes necessary to either find means to avoid deadlocks or to detect and break them. There are a plethora of algorithms for each of these approaches. The other major class of synchronization algorithm is known as optimistic, the prime example of which is Time Warp. In optimistic algorithms, LPs maintain one input queue. All of the events which arrive from other LPs are stored in the queue in increasing order of their timestamps and are processed without any concern for the arrival of events with smaller timestamps. If such a "straggler" event arrives at an LP, the LP restores its state just prior to the arrival of the straggler and continues with the simulation from that point. This process is known as rolling back. In order to restore previous states, the LP must checkpoint its state prior to the processing of an event. It is also necessary to cancel messages which were produced subsequent to the straggler. This is accomplished via the use of so-called anti-messages, which cancel, or annihilate the original messages. In this course, we plan to focus on the synchronization algorithms at the heart of distributed simulation and on the applications of these algorithms to real-world problems. The course will be conducted as a seminar course; we will read papers prior to each class and dissect them in class, trying to get a feeling for their strengths and weaknesses. There will be one programming project which will involve the construction of a distributed simulation on a network of workstations, making use of MPI to connect them. In addition, students will write a paper which summarizes and compares the research done in an area of parallel simulation. For a summary article on distributed simulation (even if it is slightly dated)  you can consult survey article  written by me. It is expected that the students maintain an adequate supply of coffee for the professor during class. A good time will be had by all. Class Materials The course will be in the form of a research seminar. This means that students will be responsible for reading papers and also participating in discussions of the papers. Part of your grade will be the extent and quality of this participation. We will make use of a text to cover some of the fundamentals in the area.  The text is Parallel and Distributed Simulation Systems , by Richard Fujimoto, Wiley Interscience Publsihers It is available in the bookstore and may also be purchased at www.amazon.com. Slides based upon this text may be found at  Fujimoto Slides There are used copies of the text available on amazon at a considerable discount from the new and kindle versions. The collection of papers may be found at papers A  schedule of papers  to read may be found at  schedule Course Evaluation Class participation:20% Project: 40% Paper:40% Project The project may be found at TWproject . It is a simplified version of Time Warp, including a GVT algorithm (Samadi's algorithm). As indicated in the description, you will be expected to demo your project and hand in a written description of the program. The demos will be scheduled for the week after classes end. If you finish before the end of the semester, we should be able to arrange an earlier demo. MPI References The following references should be of help for learning MPI mpi-standard:  mpi-standard mpi tutorials:  tutorial web pages:  web-pages mpich 2:  mpich2 mpi-text:  Using MPI Paper The purpose of the project is for you to read papers in an area of parallel simulation and to write a critical summary of these papers. You are free to choose the topic; try to make it close to your research area if this is at all possible. I am looking for an analysis of the papers which you read. By this I mean that I would like you to compare the papers to one another. You should describe their stregnths, their weaknesses and how they relate to one another. Tell me what they don't say in addition to what they do say. I prefer not to give you a specific number of papers to summarize; however I expect you to do a thorough job of covering the topic. By this I mean that if the paper matters, it will be reviewed in your paper. As to the legnth of the paper, think of at least 10 pages. You should first compile the list of papers which you want to read and send them to me by email or meet with me to discuss the list.  I will try to make suggestions about your list. For each paper, you should summarize the contents of each paper, write a section which explains how it is related to other papers, and another section which analyzes its stregnths and weaknesses. There should be a concluding section which summarizes the connections between the papers and indicates the major breakthroughs and their influence on other papers. You should start by making an outline of the paper. Once this is done, it will be much easier to write it. A list of suggested topics follows. Global Virtual Time (GVT) Network Simulations-Conservative OR Optimistic. It is not necessary to cover both conservative and optimistic approaches. Either topic is quite sufficient. Dynamic Load Balancing Algorithms Gate level parallel simulation. You can chose a subset of papers here to cover. One possible split would be Verilog or VHDL simulation. Time management in distributed virtual environments Reverse computation The paper is due on the last day of class.docContentEnd
127docContentStartUsing pipes-assignment 4 In this exercise, you will use anonymous and named pipes to transmit information across address spaces. One process, the source, uses a host file interface to read information from a file and to write the information to an anonymous pipe. A second process, the filter process, reads infomration from the source (passed by the pipe), performs a simple filtering step (such as converting all upper-case letters to lower-case letters), and writes the resulting data to a named pipe. The named pipe is used for IPC between the filter and the sink process. The sink process reads the named pipe from the filter and writes the information to a second file. Remeber not to allow the filter to block on empty input if it has something to transmit. Anonymouus pipes in UNIX Pipes are the main IPC mechanism for UNIX in a single processor. They are implemented by sockets in multiprocessor BSD UNIX. A pipe employs an asynchronous send() and a  blocking receive() operation. The blocking receive() operation can be changed to a non-blocking receive(). Pipes are FIFO buffers designed with an API that is similar (or tries to be) to the file I/O interface. A pipe can contain a (system defined) maximum number of bytes (normally 4KB) at a given time. A process sends information by writing it into one end of a pipe. Another process receives information by reading the other end of the pipe. The buffer is a kernel buffer. A pipe is represented in the kernel by a file descriptor. When a process wants to to create a pipe, it makes a system call of the form: int pipeID[2]; ... pipe(pipeID); The kernel creates the pipe as a kernel FIFO data structure with two file ID's. In this example code, pipeID[0] is a file pointer to the read end of the pipe and pipeID[1] is a file pointer to the write end of the pipe. The file pointer is an index into the process's open file table. In order for two or more processes to use anonymous pipes for IPC, a common ancestor of the processes must create the pipe prior to creating the processes. Because the UNIX fork() command creates a child that has a copy of the parent's open file table, each child ingerits pipes that the parent created. To use a pipe, it need only read and write the proper file descriptors. If a parent creates a pipe, it can create a child and communicate with it as follows: ... pipe(pipeID); if(fork()==0 {/*The child process*/ ... read(pipeID[0],childBuf,len); /*process the message in childBuf*/ ... } else {/* The parent process*/ ... /*Send a message to the child*/ write [pipeID[1],msgToChild,len); ... Consider a pair of processes A and B, which share the variables x and y. Process A writes x and reads y while process B writes y and reads x. B must not read x until A has written to it and A must not read y until B has written to it. Here is a way to arrange this by means of pipes. int A_to_B[2], B_toA[2]; main(){ pipe(A_to_B); pipe(B_to_A); if (fork()==0) {/*This is the first child process*/ execve("prog_A.out",...); exit(1); /*Error; terminate the child*/ } /*This is the parent process code*/ wait(...); wait(...); } proc_A(){ while (TRUE) { ; read)B_to_A[0],y,sizeof(int)); /*Use this pipe to get info*/ } } proc_B() { while (TRUE) { read(A_to_B[0], x, sizeof(int)): /*Use this pipe to get info*/ ; write(B_to_A[1],y,sizeof(int)); /*Use this pipe to send info*/ ; } } Nonblocking read operations in Unix As with any file, the read end of a pipe, a file descriptor, or a socket can be configured to use nonblocking semantics with an ioctl() call in Unix. After the call has been issued on the descriptor, a read() on the stream returns immediately with the error code set to EAGAIN in Posix (or EWOULDBLOCK in 4.3 BSD). Also, the read() will return a value of 0, thereby indicating it did not read any information into the buffer. Alternatively, the program can check the length value to see if it is non-zero and if the read succeeded. The following code fragment illustrates the use of the ioctl() to switch the read end of a pipe from its default blocking behavior to non-blocking behavior: #include int errno; /*For non-blocking read flag ... main() { int pipeID[2]; ... pipe(pipeID); /*Switch the read end of the pipe to the non-blocking mode*/ ioctl(pipeID[0],FIONBIO,&on;); ... while(...)  { /*Poll the read end of the pipe*/ read(pipeID[0],buffer,BUFLEN0; if (errno != EWOULDBLOCK){ /*Incoming info available from the pipe; process it*/ ... }... { /*Check the pipe for input again later-do other things*/ ... } } ... } Attacking the Problem It is necessary to check the asynchronous behavior of the solution. In order to do this your processes have to be able to sleep or do a busy loop for random amounts of time, thereby allowing information to build up in the pipes. Make use of the rand() function to introduce the random delay in your program.docContentEnd
128docContentStartContact Information Anil Ada School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 (ext. 00576) Manindra Agrawal Department of Computer Science and Engineering Indian Institute of Technology Kanpur Kanpur 208016, INDIA +91 512 2597338 Eric Allender Department of Computer Science Rutgers, the State University of NJ 110 Frelinghuysen Road Piscataway, NJ 08854-8019, USA (732) 445-3629 Arkadev Chattopadhyay School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7, Canada (514) 398-7071 (ext. 0524) Victor Dalmau Departament de Tecnologia Universitat Pompeu Fabra Passeig de Circumvallació, 8 08003 Barcelona, Spain Laszlo Egri School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 (ext. 00576) Faith E. Fich Department of Computer Science University of Toronto 10 King's College Road Toronto, Ontario M5S 3G4, Canada (416) 978 6183 Ricard Gavaldà Universitat Politècnica de Catalunya Departament de Llenguatges i Sistemes Informàtics Campus Nord, edifici C6 Jordi Girona, 1-3 08034 Barcelona, Spain. +34-93-401-7294 Valentine Kabanets School of Computing Science Simon Fraser University Burnaby BC V5A 1S6 Canada (604) 268 6912 Antonina Kolokolova School of Computing Science Simon Fraser University Burnaby BC V5A 1S6 Canada Michal Koucký Mathematical Institute AS CR Zitna 25, 115 67 Praha 1 Czech Republic +420 - 222 090 780 Benoit Larose Department of Mathematics Champlain Regional College 900 Riverside Drive St-Lambert Québec J4P 3P2 Canada (450) 672-7360 ext 278 Troy Lee LRI, Batiment 490 Universite Paris-Sud 91405 Orsay Cedex, France +33 1 69 15 69 05 François Lemieux Université du Québec à Chicoutimi Dpartement d'informatique et de mathmatique 555, boulevard de l'Université Chicoutimi, Québec, G7H 2B1 Canada (418) 545-5011 poste 2419 Pierre McKenzie Département d'Informatique et recherche opérationnelle Université de Montréal CP 6128 succ Centre Ville Montral QC, H3C 3J7 Canada (514)343-7090 Mark Mercer School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 (ext. 0524) Toniann Pitassi Sandford Fleming Building 10 King's College Road, Room 2305A Toronto, Ontario, M5S 3G4 Canada Mike Saks Department of Mathematics Rutgers, the State University of NJ 110 Frelinghuysen Road Piscataway, NJ 08854-8019, USA (732) 445-5434 Luc Segoufin INRIA Parc Club Orsay Universit ZAC des vignes 4 rue Jacques Monod 91893  Orsay Cedex, France (33-1) 7292 5930 Pascal Tesson Département d'informatique et de génie logiciel Pavillon Adrien-Pouliot , local 3958 Université Laval, Canada (418) 656-2131 ext 13056 Denis Therien School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 Jacobo Torán Universität Ulm Abteilung Theoretische Informatik Oberer Eselsberg D-89069 Ulm Germany +49 0731 502 4103 Sergey Yekhanin Stata Center, Room G614, 32 Vassar Street Cambridge, Massachusetts 02139,  USA (617) 253-4103docContentEnd
129docContentStartVisa Requirements As this year's workshop will take place during the hosting of the Cricket World Cup, special restrictions have been put into place for travel to Barbados and the West Indies. Please take a moment to make sure that you have the proper documentation. Citizens of the following contries are exempt from the special visa requirement: Canada France & OCTs (Overseas Countries and Territories) Germany Japan Ireland Nationals and Residents of CARICOM Member States (except Haiti) Italy South Africa Spain The Netherlands & OCTs United Kingdom & Dependent Territories United States & Dependent Territories Participants from other European countries and elsewhere will need the special visa. More information: Application Form Instructions The Caribbean community's (CARICOM) security websitedocContentEnd
130docContentStartFacility Information Getting to Bellairs From the Airport To get to Bellairs from the airport, either take a taxi (about $60 Bds) and split the cost if you share) or a bus ($2 Bds). If the taxi driver does not know where Bellairs is, say it is located in between   Folkstone Park   and   Coral Reef Club on the North side of Holetown. These two landmarks are famous; but with all the workshops during the past 15 years, Bellairs is also becoming famous among taxi drivers. If you want to take a bus, there are some direct busses but more interesting is to go to Bridgetown first and change to another bus (at another bus station). Bellairs Telephones:   area code (246), main office: 422-2087, dining hall: 422-2034. FAX: (246) 422-0692. Manager:    Richard Haynes,   email: bellairs@sunbeach.net At Bellairs (consult the  Bellairs Map ) When you arrive at Bellairs just go straight to the dining hall . There, you will find either people or a message for you on the bulletin board or the blackboard telling you which is your room. Our rooms are in the two buildings shaded in dark grey called East Wing  and  West Wing . The rooms are labeled with E  and  W  accordingly. You will find a key to your room, in your room, which should be unlocked unless your roommate has already arrived. In this case, you should look for your roommate on the beach. The Most Important House Rules Kitchen and Food Breakfast is provided by Bellairs and is included in the room rate. The breakfast food is kept in the kitchen fridge. This food is to be used only at breakfast and finished by 9:30 a.m. We are responsible for washing all of our dishes after breakfast. Please leave the kitchen clean. We can make coffee in the kitchen any time we want. There is a guest fridge in the dining hall where we can keep our own private food. Please label your food and remove any left over when you depart. Showers and Sand Sand in the shower drains can cause   enormous   blockage problems. Please be sure to rinse off the sand from your feet before entering your rooms. There are water taps outside both blocks of rooms for this purpose. Locked Doors and Valuables Please leave your room locked when you are not in it. You can leave your money and other valuables in the safe in the main office. If you leave some money in your room I suggest you put it in a purse inside a locked suitcase inside a closed closet; certainly do not leave it within arm's reach of the back windows facing the public park. This was fine ten years ago but Barbados has undergone a lot of   progress  in recent years. Telephone Telephones and computers are available in the main office (sort of). Bellairs Survival Hints Food and Snacks We will have a cook and the food is great but if you need anything special please bring it along. There will be a fridge where we can keep our  private  food items. The coffee there is of the instant variety. If you wish to bring your own coffee you may do so. Vegitarians may want to bring their favorite non-perishables, however it is not necessary since there is already a diverse selection at the local supermarket. There is also good vegetarian roti in several places near Bellairs. Beach, Sun, Snorkeling, and SCUBA diving Bellairs is situated on one of the best beaches in Barbados, so don't forget your bathing suit (and skin protection) for swims before breakfast and in between work sessions. There is also good snorkeling right in front of Bellairs so if you have a mask and fins bring them along too. In fact, if you SCUBA dive bring your gear. There is diving right there as well and air tanks at Bellairs cost only US$8.00 per tank! Mosquitos Depending on the weather conditions and other factors, we may get some mosquitoes. You should bring some bug repellant just in case. Snorers We will be living in intimate quarters. All of us will share a room with one or possibly (but very unlikely) two others (even four to a room has occurred in the past) with a resulting distance of inches between beds. If you snore let me know in advance  and I will put all the snorers together. It is my experience that a snorer has no problem sleeping with another snorer. In fact they enjoy it!docContentEnd
131docContentStart2007 List of Participants Invited Speaker Manindra Agrawal (IIT Kanpur) Organizer Denis Thérien  (McGill) Attendees Anil Ada  (McGill) Eric Allender  (Rutgers) Arkadev Chattopadhyay  (McGill) Victor Dalmau  (UPF) Laszlo Egri  (McGill) Faith Fich  (UToronto) Ricard Gavaldà  (UPC) Valentine Kabanets  (SFU) Antonina Kolokolova  (SFU) Michal Koucký  (Czech Acad. of Sciences) Benoit Larose  (Concordia) Troy Lee   (LRI) François Lemieux  (UQAC) Pierre McKenzie  (UMontréal) Mark Mercer  (McGill) Toniann Pitassi  (UToronto) Mike Saks  (Rutgers) Luc Segoufin  (INRIA) Pascal Tesson  (ULaval) Jacobo Toran  (UUlm) Sergey Yekhanin  (MIT)docContentEnd
132docContentStartAnnual Workshop on Computational Complexity Since 1989, I have organized workshops related to complexity theory at Bellairs Research Institute of McGill University in Holetown, St. James, Barbados. Every winter, a small selected group of senior researchers and graduate students is invited to spend a week at Bellairs Institute to hear a series of lectures on a selected topic and discuss open problems in the area. These workshops have always been quite successful and much international research collaboration has originated in these meetings. Here is a list of the topics and guest lecturers over the years: 1989 : Circuit Complexity 1990 : Circuit Complexity (M. Sipser, MIT) 1991 : Logic and Complexity (P. Clote, Boston College) 1992 : Circuit Lower Bounds : the polynomial method (R. Beigel, Yale University) 1993 : Communication Complexity (N. Nisan, Hebrew University of Jerusalem) 1994 : Derandomization and Universal Hashing (A. Widgerson, Hebrew University of Jerusalem) ( Lecture Notes ) 1995 : Proof Theory and Complexity (S. Buss, UCSD) ( Lecture Notes ) 1996 : Around the PCP TheoremdocContentEnd
133docContentStartContact Information Anil Ada School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 (ext. 00576) [spam-blocked email address] ( webpage ) Manindra Agrawal Department of Computer Science and Engineering Indian Institute of Technology Kanpur Kanpur 208016, INDIA +91 512 2597338 [spam-blocked email address] ( webpage ) Eric Allender Department of Computer Science Rutgers, the State University of NJ 110 Frelinghuysen Road Piscataway, NJ 08854-8019, USA (732) 445-3629 [spam-blocked email address] ( webpage ) Anne Broadbent Université de Montréal Pavillon André-Aisenstadt 2920 chemin de la Tour Montréal, QC, Canada (514) 343-6111 (ext. 3514) [spam-blocked email address] ( webpage ) Arkadev Chattopadhyay School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7, Canada (514) 398-7071 (ext. 0524) [spam-blocked email address] ( webpage ) Henri Darmon Department of Mathematics and Statistics McGill University 805 Sherbrooke Street West Montréal,  Québec  H3A 2K6, Canada (514) 398-2263 [spam-blocked email address] ( webpage ) Matei David Department of Computer Science University of Toronto 10 King's College Road Toronto, ON, Canada M5R 3G4 [spam-blocked email address]    ( webpage ) Isabelle Déchène Assistant Professor Department of Mathematics and Statistics University of Ottawa 613-562-5800 (ext. 3526) [spam-blocked email address] ( webpage ) Laszlo Egri School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 (ext. 00576) [spam-blocked email address] ( webpage ) Ricard Gavaldà Universitat Politècnica de Catalunya Departament de Llenguatges i Sistemes Informàtics Campus Nord, edifici C6 Jordi Girona, 1-3 08034 Barcelona, Spain. +34-93-401-7294 [spam-blocked email address] ( webpage ) Eyal Goren Department of Mathematics and Statistics McGill University 805 Sherbrooke Street West Montréal,  Québec  H3A 2K6, Canada (514) 398-3815 [spam-blocked email address] ( webpage ) Andrew Granville Département de mathématiques et de statistique, Université de Montréal, CP 6128 succ. Centre-Ville, Montréal Québec H3C 3J7, Canada (514) 343-6583 [spam-blocked email address] ( webpage ) Valentine Kabanets School of Computing Science Simon Fraser University Burnaby BC V5A 1S6 Canada (604) 268 6912 [spam-blocked email address] ( webpage ) Kiran Kedlaya Department of Mathematics, Room 2-165 Massachusetts Institute of Technology 77 Massachusetts Avenue Cambridge, MA 02139 USA (617)-253-2946 [spam-blocked email address] ( webpage ) Antonina Kolokolova School of Computing Science Simon Fraser University Burnaby BC V5A 1S6 Canada [spam-blocked email address] ( webpage ) Benoit Larose Department of Mathematics Champlain Regional College 900 Riverside Drive St-Lambert Québec J4P 3P2 Canada (450) 672-7360 ext 278 [spam-blocked email address] ( webpage ) François Lemieux Université du Québec à Chicoutimi Dpartement d'informatique et de mathmatique 555, boulevard de l'Université Chicoutimi, Québec, G7H 2B1 Canada (418) 545-5011 poste 2419 [spam-blocked email address] ( webpage ) Pierre McKenzie Département d'Informatique et recherche opérationnelle Université de Montréal CP 6128 succ Centre Ville Montréal QC, H3C 3J7 Canada (514) 343-7090 [spam-blocked email address] ( webpage ) Mark Mercer School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 (ext. 0524) [spam-blocked email address] ( webpage ) Toniann Pitassi Sandford Fleming Building 10 King's College Road, Room 2305A Toronto, Ontario, M5S 3G4 Canada [spam-blocked email address] ( webpage ) Pavel Pudlák Mathematical Institute of the Academy of Sciences of the Czech Republic Žitná 25 115 67 Praha 1, Czech Republic +420-222 090 721 [spam-blocked email address] ( webpage ) Nitin Saxena Centrum voor Wiskunde en Informatica P.O. Box 94079, NL-1090 GB Amsterdam [spam-blocked email address] ( webpage ) René Schoof Università di Roma "Tor Vergata" Dipartimento di Matematica Via della Ricerca Scientifica I-00133 Roma, ITALY [spam-blocked email address] ( webpage ) Luc Segoufin INRIA Parc Club Orsay Universit ZAC des vignes 4 rue Jacques Monod 91893  Orsay Cedex, France (33-1) 7292 5930 [spam-blocked email address] ( webpage ) Mario Szegedy Department of Computer Science Rutgers, the State University of NJ 110 Frelinghuysen Road Piscataway, NJ 08854-8019, USA (732) 445-4184 [spam-blocked email address] ( webpage ) Pascal Tesson Département d'informatique et de génie logiciel Pavillon Adrien-Pouliot , local 3958 Université Laval, Canada (418) 656-2131 ext 13056 [spam-blocked email address] ( web page ) Denis Therien School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 [spam-blocked email address] ( webpage ) John Voight Department of Mathematics and Statistics 16 Colchester Ave University of Vermont Burlington, VT 05401 USA (802) 656-2271 [spam-blocked email address] ( webpage )docContentEnd
134docContentStartFacility Information Getting to Bellairs From the Airport To get to Bellairs from the airport, either take a taxi (about $60 Bds) and split the cost if you share) or a bus ($2 Bds). If the taxi driver does not know where Bellairs is, say it is located in between   Folkstone Park   and   Coral Reef Club on the North side of Holetown. These two landmarks are famous; but with all the workshops during the past 15 years, Bellairs is also becoming famous among taxi drivers. If you want to take a bus, there are some direct busses but more interesting is to go to Bridgetown first and change to another bus (at another bus station). Bellairs Telephones:   area code (246), main office: 422-2087, dining hall: 422-2034. FAX: (246) 422-0692. Manager:    Richard Haynes,   email: manager.bellairs@caribsurf.com At Bellairs (consult the  Bellairs Map ) When you arrive at Bellairs just go straight to the dining hall . There, you will find either people or a message for you on the bulletin board or the blackboard telling you which is your room. Our rooms are in the two buildings shaded in dark grey called East Wing  and  West Wing . The rooms are labeled with E  and  W  accordingly. You will find a key to your room, in your room, which should be unlocked unless your roommate has already arrived. In this case, you should look for your roommate on the beach. The Most Important House Rules Kitchen and Food Breakfast is provided by Bellairs and is included in the room rate. The breakfast food is kept in the kitchen fridge. This food is to be used only at breakfast and finished by 9:30 a.m. We are responsible for washing all of our dishes after breakfast. Please leave the kitchen clean. We can make coffee in the kitchen any time we want. There is a guest fridge in the dining hall where we can keep our own private food. Please label your food and remove any left over when you depart. Showers and Sand Sand in the shower drains can cause   enormous   blockage problems. Please be sure to rinse off the sand from your feet before entering your rooms. There are water taps outside both blocks of rooms for this purpose. Locked Doors and Valuables Please leave your room locked when you are not in it. You can leave your money and other valuables in the safe in the main office. If you leave some money in your room I suggest you put it in a purse inside a locked suitcase inside a closed closet; certainly do not leave it within arm's reach of the back windows facing the public park. This was fine ten years ago but Barbados has undergone a lot of   progress  in recent years. Telephone Telephones and computers are available in the main office (sort of). Bellairs Survival Hints Food and Snacks We will have a cook and the food is great but if you need anything special please bring it along. There will be a fridge where we can keep our  private  food items. The coffee there is of the instant variety. If you wish to bring your own coffee you may do so. Vegitarians may want to bring their favorite non-perishables, however it is not necessary since there is already a diverse selection at the local supermarket. There is also good vegetarian roti in several places near Bellairs. Beach, Sun, Snorkeling, and SCUBA diving Bellairs is situated on one of the best beaches in Barbados, so don't forget your bathing suit (and skin protection) for swims before breakfast and in between work sessions. There is also good snorkeling right in front of Bellairs so if you have a mask and fins bring them along too. In fact, if you SCUBA dive bring your gear. There is diving right there as well and air tanks at Bellairs cost only US$8.00 per tank! Mosquitos Depending on the weather conditions and other factors, we may get some mosquitoes. You should bring some bug repellant just in case. Snorers We will be living in intimate quarters. All of us will share a room with one or possibly (but very unlikely) two others (even four to a room has occurred in the past) with a resulting distance of inches between beds. If you snore let me know in advance  and I will put all the snorers together. It is my experience that a snorer has no problem sleeping with another snorer. In fact they enjoy it!docContentEnd
135docContentStartAnticipatory Reading MaterialdocContentEnd
136docContentStart2008 List of Participants Invited Speaker René Schoof (Università de Roma) Organizer Denis Thérien  (McGill) Attendees Anil Ada  (McGill) Manindra Agrawal  (IIT Kanpur) Eric Allender  (Rutgers) Anne Broadbent  (UMontreal) Arkadev Chattopadhyay  (McGill) Henri Darmon  (McGill) Matei David  (UToronto) Isabelle Déchène  (UOttawa) Laszlo Egri  (McGill) Ricard Gavaldà  (UPC) Eyal Goren  (McGill) Andrew Granville  (UMontreal) Valentine Kabanets  (SFU) Kiran Kedlaya  (MIT) Antonina Kolokolova  (SFU) Benoit Larose  (Concordia) François Lemieux  (UQAC) Pierre McKenzie  (UMontréal) Mark Mercer  (McGill) Toni Pitassi  (UToronto) Pavel Pudlák  (Czech Acad. of Sciences) Nitin Saxena  (CWI) Luc Segoufin  (INRIA) Mario Szegedy  (Rutgers) Pascal Tesson  (ULaval) John Voight  (UVermont)docContentEnd
137docContentStartProf. Denis Thrien's Home Page / McConnell Engineering Building, Rm. 318 3480 University Street Montreal, Quebec, Canada H3A 2A7 denis@cs.mcgill.ca (514) 398-7073 FAX: (514) 398-3883 RESEARCH My favorite area of research is complexity theory, i.e., trying to classify problems in terms of resources required to compute their solution. This obviously is a very fundamental question for computer scientists. I have done extensive work on developing algebraic characterizations for complexity classes, but I also am a fan of logical tools, combinatorics, probabilistic methods and mathematics in general.docContentEnd
138docContentStartCurriculum Vitae Born     1954 Studies: Ph.D.   1980   Computer Science (University of Waterloo) Employment   1978-... School of Computer Science, McGill University Awards 2000-01   Humboldt-Forschungsstipendien 2002-09   James McGill Professor Marital status     Unmarried to Lynn since 1986 Kids: Ludo (89), Timo (95), Benjo (97)docContentEnd
139docContentStartBienvenue chez Prof. Denis Thérien / McConnell Engineering Building, Rm. 318 3480 University Street Montreal, Quebec, Canada H3A 2A7 denis@cs.mcgill.ca (514) 398-7071 (ext. 00071) FAX: (514) 398-3883 RECHERCHE Ma passion c'est la théorie de la complexité des calculs, c'est-à-dire comprendre la difficulté des problèmes en terme des ressources qui sont nécessaires pour en trouver la solution. C'est fondamental, et ça utilise des mathématiques de toute beauté... J'ai travaillé beaucoup sur les caractérisations algébriques des classes de complexité, mais j'aime bien aussi la logique, la combinatoire, les probabilités et les maths en général.docContentEnd
140docContentStartRencontre annuelle sur la Complexité des Calculs Depuis 1989, j'organise des scéances de travail sur la complexité au Bellairs Research Institute de l'Université McGill, à Holetown, St. James, Barbados. Chaque hiver, un petit groupe de chercheurs professionnels et d'étudiants gradués sont invités à passer une semaine à Bellairs pour assister à des cours sur un sujet donné et pour discuter de problèmes ouverts dans le domaine. Ces ateliers remportent toujours un vif succès et ont donné lieu à de multiples collaborations au niveau international. Voici une liste des sujets traités et des orateurs principaux. 1989 : Circuit Complexity 1990 : Circuit Complexity (M. Sipser, MIT) 1991 : Logic and Complexity (P. Clote, Boston College) 1992 : Circuit Lower Bounds : the polynomial method (R. Beigel, Yale University) 1993 : Communication Complexity (N. Nisan, Hebrew University of Jerusalem) 1994 : Derandomization and Universal Hashing (A. Widgerson, Hebrew University of Jerusalem) ( Lecture notes ) 1995 : Proof Theory and Complexity (S. Buss, UCSD) ( Lecture Notes ) 1996 : Around the PCP Theorem (S. Arora, Princeton University) ( Lecture Notes ) 1997 : Cellular Automata 1998 : Randomness in Complexity (S. Rudich, Carnegie-Mellon) 1999 : Learning (M. Kearns, AT&T) 2000 : Fourier Transforms in Computer Science (U. Vazirani, Berkeley) 2001 : Extractors and Randomness (L. Trevisan, Berkeley) 2002 :   Selected topics 2003 :  Constraint Satisfaction, Complexity, and Logic  (Phokion G. Kolaitis, UCSC) 2004 : Finite metric spaces and low dimensional embeddings  (Nati Linial, Hebrew University of Jerusalem) ( Lecture Notes ) 2005 : Lower Bounds for Algebraic Circuits  (Ran Raz, Weizmann Institute) ( Lecture Notes ) 2006 : Error-correcting codes and Computational Complexity (Madhu Sudan, MIT) ( Lecture notes ) 2007 : Rings and Integer Lattices in Computer Science (Manindra Agrawal, IIT Kanpur) ( Lecture notes ) 2008 : Elliptic Curves (Renée Schoof, Università di Roma "Tor Vergata") Bellairs Research InstitutedocContentEnd
141docContentStartContact Information Arkadev Chattopadhyay School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 (ext. 0524) achatt3@cs.mcgill.ca Ricard Gavaldà Universitat Politècnica de Catalunya Departament de Llenguatges i Sistemes Informàtics Campus Nord, edifici C6 Jordi Girona, 1-3 08034 Barcelona, Spain. +34-93-401-7294 gavalda@lsi.upc.es Michal Koucký School of Computer Science McGill University 3480 University Street McConnell Eng. Bldg., Room 318 Montréal, Québec H3A 2A7 Canada (514) 398-7071 (ext. 0524) mkoucky@cs.mcgill.ca Andreas Krebs Wilhelm-Schickard Institut für Informatik Universität Tübingen Sand 13 D-72076 Tübingen, Deutschland krebs@informatik.uni-tuebingen.dedocContentEnd
142docContentStartFacility Information Getting to Bellairs From the Airport To get to Bellairs from the airport, either take a taxi (about $60 Bds) and split the cost if you share) or a bus ($2 Bds). If the taxi driver does not know where Bellairs is, say it is located in between   Folkstone Park   and   Coral Reef Club on the North side of Holetown. These two landmarks are famous; but with all the workshops during the past 15 years, Bellairs is also becoming famous among taxi drivers. If you want to take a bus, there are some direct busses but more interesting is to go to Bridgetown first and change to another bus (at another bus station). Bellairs Telephones:   area code (246), main office: 422-2087, dining hall: 422-2034. FAX: (246) 422-0692. Manager:    Richard Haynes,   email: bellairs@caribsurf.com At Bellairs (consult the  Bellairs Map ) When you arrive at Bellairs just go straight to the dining hall . There, you will find either people or a message for you on the bulletin board or the blackboard telling you which is your room. Our rooms are in the two buildings shaded in dark grey called East Wing  and  West Wing . The rooms are labeled with E  and  W  accordingly. You will find a key to your room, in your room, which should be unlocked unless your roommate has already arrived. In this case, you should look for your roommate on the beach. The Most Important House Rules Kitchen and Food Breakfast is provided by Bellairs and is included in the room rate. The breakfast food is kept in the kitchen fridge. This food is to be used only at breakfast and finished by 9:30 a.m. We are responsible for washing all of our dishes after breakfast. Please leave the kitchen clean. We can make coffee in the kitchen any time we want. There is a guest fridge in the dining hall where we can keep our own private food. Please label your food and remove any left over when you depart. Showers and Sand Sand in the shower drains can cause   enormous   blockage problems. Please be sure to rinse off the sand from your feet before entering your rooms. There are water taps outside both blocks of rooms for this purpose. Locked Doors and Valuables Please leave your room locked when you are not in it. You can leave your money and other valuables in the safe in the main office. If you leave some money in your room I suggest you put it in a purse inside a locked suitcase inside a closed closet; certainly do not leave it within arm's reach of the back windows facing the public park. This was fine ten years ago but Barbados has undergone a lot of   progress  in recent years. Telephone Telephones and computers are available in the main office (sort of). Bellairs Survival Hints Food and Snacks We will have a cook and the food is great but if you need anything special please bring it along. There will be a fridge where we can keep our  private  food items. The coffee there is of the instant variety. If you wish to bring your own coffee you may do so. Vegitarians may want to bring their favorite non-perishables, however it is not necessary since there is already a diverse selection at the local supermarket. There is also good vegetarian roti in several places near Bellairs. Beach, Sun, Snorkeling, and SCUBA diving Bellairs is situated on one of the best beaches in Barbados, so don't forget your bathing suit (and skin protection) for swims before breakfast and in between work sessions. There is also good snorkeling right in front of Bellairs so if you have a mask and fins bring them along too. In fact, if you SCUBA dive bring your gear. There is diving right there as well and air tanks at Bellairs cost only US$8.00 per tank! Mosquitos Depending on the weather conditions and other factors, we may get some mosquitoes. You should bring some bug repellant just in case. Snorers We will be living in intimate quarters. All of us will share a room with one or possibly (but very unlikely) two others (even four to a room has occurred in the past) with a resulting distance of inches between beds. If you snore let me know in advance  and I will put all the snorers together. It is my experience that a snorer has no problem sleeping with another snorer. In fact they enjoy it!docContentEnd
143docContentStartAnticipatory Reading MaterialdocContentEnd
144docContentStart2004 List of Participants Invited Speaker Nati Linial  (HUJI) Organizer Denis Thérien  (McGill) Attendees Arkadev Chattopadhyay  (McGill) Ricard Gavaldà  (UPC) Anna Gál  (UTexas) Michal Koucký  (McGill) Andreas Krebs  (UTubingen) Benoit Larose  (Concordia) Francois Lemieux  (UQAC) Leonid Libkin  (UToronto) Pierre McKenzie  (UMontréal) Mark Mercer  (McGill) Cris Moore  (UNM) Dana Randall  (GIT) Alex Russell  (UConn) Michael Saks  (Rutgers) Mario Szegedy  (Rutgers) Pascal Tesson  (UTubingen) Santosh Vempala  (MIT)docContentEnd
145docContentStartHome Contact Information Curriculum Vitae Publications Contact Information Email: wenbohe AT cs DOT mcgill DOT ca Office: McConnell Engineering Building, Room 232 School of Computer Science @ McGill University 3480 University Street Montreal, Quebec, Canada H3A 0E9 Office Phone: 514-398-3281docContentEnd
146docContentStartHome Contact Information Curriculum Vitae Publications Wenbo HedocContentEnd
147docContentStartHome Contact Information Curriculum Vitae Publications Publications Conference and Workshop Papers ICDCS'14 Haoxiang Liu, Wei Gong, Lei Chen,  Wenbo He , Kebin Liu and Yunhao Liu, " Generic Composite Counting in RFID Systems. ", in Proceedings of the   34th International Conference on Distributed Computing Systems (ICDCS14) , Madrid, Spain, June, 2014. ICDE'14 Pinghui Wang,  Wenbo He , and Xue Liu, " An Ef?cient Sampling Method for Characterizing Points of Interests on Maps ", in Proceedings of the   30th IEEE International Conference on Data Engineering (ICDE'14) , Chicago, Illinois, USA. INFOCOM'14 Haoxiang Liu, Wei Gong, Xin Miao, Kebin Liu, and  Wenbo He , " Towards Adaptive Continuous Scanning in Large-Scale RFID Systems ", in Proceedings of the   33rd Annual IEEE International Conference on Computer Communications (INFOCOM14) , Toronto, Canada. INFOCOM'14 Lei Wang, Yixin Chen, Jianwei Niu, and  Wenbo He , "  Detecting Collusive Cheating in Online Shopping Systems through Characteristics of Social Networks ", in Proceedings of the   Workshop on Dynamic Social Networks, in conjunction with 33rd Annual IEEE International Conference on Computer Communications (INFOCOM14) , Toronto, Canada. HotPower'13 Mingyuan Xia,  Wenbo He , Xue Liu, and Jie Liu, "  Why Application Errors Drain Battery Easily? A Study of Memory Leaks in Smartphone Apps ", in Proceedings of the   5th Workshop on Power-Aware Computing and Systems (HotPower13), in conjunction with the 24th ACM Symposium on Operating Systems Principles (SOSP'13) , Farmington, Pennsylvania, USA. PerCom'12 Michael M. Groat, Benjamin Edwards, James Horey,  Wenbo He , and Stephanie Forrest, "  Enhancing Privacy in Participatory Sensing Applications with Multidimensional Data ", in Proceedings of the   10th IEEE International Conference on Pervasive Computing and Communications(PerCom12) , Lugano, Switzerland, March 2012. ICDCS'12 Jianguo Yao, Xue Liu,  Wenbo He , and Ashikur Rahman, "  Dynamic Control of Electricity Cost with Power Demand Smoothing and Peak Shaving for Distributed Internet Data Centers. ", in Proceedings of the   32nd International Conference on Distributed Computing Systems (ICDCS12) , Macau, China, June 2012. INFOCOM'12 Fan Zhang, Li He,  Wenbo He , and Xue Liu "  Data Perturbation with State-Dependent Noise for Participatory Sensing. ", in Proceedings of the   31st IEEE Conference on Computer Communications 2012 (INFOCOM12) , Orlando, FL, April 2012. INFOCOM'12 Yu Hua, Xue Liu, and  Wenbo He , "  HOSA: Holistic Scheduling and Analysis for Scalable Fault-tolerant FlexRay Design. ", in Proceedings of the   31st IEEE Conference on Computer Communications 2012 (INFOCOM12) , Orlando, FL, April 2012. MASS'11 Yongping Xiong,  Wenbo He , Canfeng Chen, Jian Ma, Limin Sun, " Phoenix: Peer-to-Peer Location based Notification in Mobile Networks ", in Proceedings of the 8th IEEE International Conference on Mobile Ad-hoc and Sensor Systems (MASS11) , Valencia, Spain, October 2011. ICDCS'11 Huanzhong Li, Xue Liu,  Wenbo He , Jian Li, Wenhua Dou, " End-to-End Delay Analysis in Wireless Network Coding: A Network Calculus-Based Approach ", in Proceedings of the 31th International Conference on Distributed Computing Systems (ICDCS11) , Minneapolis, Minnesota, 2011. ICDCS'11 Fan Zhang,  Wenbo He , Xue Liu, " Defending Against Traffic Analysis inWireless Networks through Traffic Reshaping ", in Proceedings of   the 31th International Conference on Distributed Computing Systems (ICDCS11) , Minneapolis, Minnesota, 2011. ICDCS'11 Wenbo He , Xue Liu, Mai Ren, " Location Cheating: A Security Challenge to Location-based Social Network Services ", in Proceedings of the the 31th International Conference on Distributed Computing Systems (ICDCS11) , Minneapolis, Minnesota, 2011. WiSec'11 Fan Zhang,  Wenbo He , Xue Liu, Patrick Bridges, " Inferring Users Online Activities through Traffic Analysis ", in Proceedings of the  Fourth ACM Conference on Wireless Network Security (WiSec11),  (Best Paper Award) , Hamburg, Germany , June 15-17, 2011. INFOCOM'11 Michael Groat, Wenbo He , Stephanie Forrest, " KIPDA: k-Indistinguishable Privacy-preserving Data Aggregation inWireless Sensor Networks ", in Proceedings of the IEEE Conference on Computer Communications 2011 (INFOCOM11) ,Shanghai, China. ICDCS'10 Wenbo He ,Xue Liu, Long Zheng, and Hao Yang," Reliability Calculus: A Theoretical Framework To Analyze Communication Reliability ", in Proceedings of the The 30th International Conference on Distributed Computing Systems (ICDCS'10) , Genoa Italy, June 22-25, 2010. ISCC'10 Yongping Xiong, Limin Sun, Wenbo He , and Jian Ma," Anycast Routing in Mobile Opportunistic Networks ", in Proceedings of the The 15th IEEE Symposium on Computers and Communications (ISCC'10) , Riccione, Italy, June 22-25, 2010. MP2P'10 Wenbo He ,Ying Huang, Klara Nahrstedt, Bo Wu," Message Propagation in Ad-Hoc-Based Proximity Mobile Social Networks ", in Proceedings of the The The 6th IEEE PerCom Workshop on Mobile Peer-to-Peer Computing (MP2P'10) , Mannheim, Germany, April, 2010. ICAC'09 Liang Liu; Xue Liu,  Wenbo He ," GreenCloud: A New Architecture for Green Data Center ", in Proceedings of the 6th International Conference on Autonomic Computing and Communication (ICAC'09) , Barcelona, Spain, June 2009. ICDCS'09 Ying Huang, Yan Gao,  Wenbo He , Klara Nahrstedt" Optimizing File Retrieval in Delay-Tolerant Content Distribution Community ", in Proceedings of the 29th International Conference on Distributed Computing Systems (ICDCS'09) , Montreal, Quebec, Canada, June 2009. WCPS'09 Wenbo He ,Xue Liu, Hoang Nguyen, and Klara Nahrstedt, " A Cluster-based Protocol To Enforce Integrity and Preserve Privacy in Data Aggregation ", in Proceedings of the 2nd International Workshop on Cyber-Physical Systems (WCPS 2009), in conjunction with ICDCS 2009 , Montreal, Quebec, Canada, June 2009. WCPS'09 Jie Liu, Feng Zhao, Xue Liu,  Wenbo He ," Challenges Towards Elastic Power Management in Internet Data Centers (invited) ", in Proceedings of the 2nd International Workshop on Cyber-Physical Systems (WCPS 2009), in conjunction with ICDCS 2009. , Montreal, Quebec, Canada, June 2009. NSDI'08 Gong Chen,  Wenbo He , Jie Liu, Suman Nath, Leonidas Rigas, Lin Xiao, and Feng Zhao, ( in alphabetic order ), " Energy-Aware Server Provisioning and Load Dispatching for Connection-Intensive Internet Services ", in Proceedings of the 5th USENIX Symposium on Networked Systems Design & Implementation (NSDI'08) , San Francisco, CA, April 2008. Milcom'08 Wenbo He , Hoang Nguyen, Xue Liu, Klara Nahrstedt and Tarek Abdelzaher, " iPDA: An Integrity-Protecting Private Data Aggregation Scheme for Wireless Sensor Networks ", in MILCOM 2008 , in San Diego. Milcom'08 Ying Huang,  Wenbo He , Klara Nahrstedt, Whay C. Lee, " CORPS: Event-driven Mobility Model For First Responders In Incident Scene ", in MILCOM 2008 , in San Diego. WCPS'08 Zhong Xu, Xue Liu, Guoqing Zhang,  Wenbo He , Guanzhong Dai, Weihuan Shu, " McCLS: Certificateless Signature Scheme for Mobile Wireless Cyber-Physical Systems ", The First International Workshop on Cyber-Physical Systems, in conjunction with ICDCS 2008 , Beijing, China. (acceptance rate 27%) INFOCOM'07 Wenbo He , Xue Liu, Hoang Nguyen, Klara Nahrstedt, Tarek Abdelzaher, " PDA: Privacy-preserving Data Aggregation in Wireless Sensor Networks ", 26th Annual IEEE Conference on Computer Communications IEEE INFOCOM 2007 , Anchorage, Alaska, May 2007. (acceptance rate 18%) PerCom'07 Wenbo He , Ying Huang, Klara Nahrstedt, Whay C. Lee, " SMOCK: A Self-contained Public Key Management Scheme for Mission-critical Wireless Ad Hoc Networks ", 5th Annual IEEE International Conference on Pervasive Computing and Communications (PerCom'07) , White Plains, NY, March 2007. (acceptance rate 9.6%) CDC'07 Xue Liu,  Wenbo He , " Active Queue Management Design Using Discrete-Event Control ", Proceedings of the 46th IEEE Conference on Decision and Control (CDC'07) , New Orleans, LA,  December 2007. RTSS'07  (PhD Forum) Wenbo He , Klara Nahrstedt " MobileAds: Advertisement on Mobile Devices ", Ph.D. Forum on Deeply Embedded Real-Time Computing, in The 28th IEEE Real-Time Systems Symposium (RTSS'07) , Tucson, Arizona,  December 2007. Homeland Security'07 Ying Huang,  Wenbo He , Klara Nahrstedt, Whay C. Lee, " Requirements and System Architecture Design Consideration for First Responder Systems ", 2007 IEEE Conference on Technologies for Homeland Security: Enhancing Critical Infrastructure Dependability ,Waltham, MA,  May 2007. FeBID'07 Xue Liu,  Wenbo He , " Control Computing Systems as Queueing Systems: The Case of Optimal Dropping Strategy for Internet Routers ", Second IEEE International Workshop on Feedback Control Implementation and Design in Computing Systems and Networks (FeBID), Co-located with IFIP/IEEE International Symposium on  Integrated Network Management (IM 2007). ,  Munich, Germany, May 2007.. BroadNets'06 Wenbo He , Hoang Nguyen, Klara Nahrstedt, " Experimental Validation of Middleware-based QoS Control in 802.11Wireless Networks (Invited paper) ", 3rd International Conference on Broadband Communications, Netwoks, and Systems (BROADNETs'06) , San Jose, California, October 2006. RTAS'06 Wenbo He , Klara Nahrstedt, " Impact of Upper layer Adaptation on End-to-end Delay Management in Wireless Ad Hoc Networks ", 12th IEEE Real-Time and Embedded Technology and Applications Symposium (RTAS 2006) , San Jose, California, April 2006. WCNC'06 Wenbo He , Klara Nahrstedt, " An Integrated Solution to Delay and Security Support in Wireless Networks ", IEEE Wireless Communications and Networking Conference (WCNC'06),  , Las Vegas, NV, April 2006.docContentEnd
148docContentStartCOMP766: An Introduction to Crowdsourcing and Human-Computation Techniques Winter 2013 Syllabus Initiatives such as Amazon Mechanical Turk and OpenStreetMaps have proven that crowd-sourcing and human-computing techniques are valuable ways to both analyze and annotate large datasets that require human expertise as well as to solve problems that are difficult to treat with classical computer algorithms. Distributed computing platforms such as a SETI@home or Scientific games like Galaxy Zoo, Foldit and Phylo illustrate the potential of these techniques for studying, mining, and processing scientific data. This course aims to provide an introduction to the emerging field of human computation and to discuss its impact on the scientific discovery processes. We will study existing platforms and review related theoretical frameworks. Finally, we will discuss the perspectives offered by new mobile computing technologies. The evaluation will consist of paper reviews and a final project. Topics & Key words Human-Computation, Crowdsourcing, Citizen science, Game with a purpose. Reports The paper reports are due on April 16, 2013. The project reports on April 28, 2013. [Guidelines] Course informations Instructor: Jérôme Waldispühl Lectures:  Tuesday-Thursday 10:05am - 11:25am in McConnell 320. Office hours:  By appointement. Paper Assignment:   Schedule for paper presentation Schedule and Material Lecture 1 (January 9, 2013): Introduction to Human-computation.  [Slides in PDF] Lecture 2 (January 15, 2013): Designing Human-computation Algorithms.  [Slides in PDF] Lecture 3 (January 17, 2013): Aggregating outputs.  [Slides in PDF] Lecture 4 (January 22, 2013): Task routing.  [Slides in PDF] Lecture 5 (January 24, 2013): Know your audience.  [Slides in PDF] Lecture 6 (January 29, 2013): Paper and project presentation. A selection of paper is available  here . Lecture 7 (January 31, 2013): The art of asking question.  [Slides in PDF] Lecture 8 (February 5, 2013): “Leveraging human navigation in information networks to extract conceptual knowledge” by Doina Precup. [Slides in PDF] Lecture 9 (February 7, 2013): “Analyzing social networks using the Amazon Mechanical Turk” by Derek Ruths.  [Abstract] Lecture 10 (February 12, 2013): Scientific games. Lecture 11 (February 14, 2013): Office hours for Project assignments (in Trottier 3106). Lecture 12 (February 19, 2013): Invited Lecture: Éric Bourget. Paper presentation (February 21 - April 2, 2013): Schedule Lecture 13 (February 26, 2013): Departmental seminar: Edith Law. Lecture 14 (February 28, 2013): Departmental seminar: Yuval Filmus. Lecture 15 (April 4, 2013): Swarm computing. Lecture 16 (April 9, 2013): Discussion & conclusion. References Human Computation: An Integrated Approach to Learning from the Crowd Edith Law, Luis von Ahn Morgan & Claypool Publishers Reinventing discovery: The new era of networked science Michael Nielsen Princeton University Press Instructor's homepagedocContentEnd
149docContentStartCOMP766: Paper presentation Winter 2013 February 21 - March 19, 2013 Guidelines The talk are 15 to 20 min long. You are expected to provide a quick overview of the field and a clear description on the contribution of the paper. You will also conclude your talk with a short discussions on the perspectives offered by this work. Your presentation must use slides (not more than 20) and should be sent to the instructor after the talk. You can find a template for your presentation in pdf or ppt format: Thursday February 21, 2013 Ding, Rifeng Krishnamoorthy, Mangala gowri Tuesday February 26, 2013 Dhope, Srushti  White Bear, JavonadocContentEnd
150docContentStartTéléportation Quantique L'Article C.H. Bennett, G. Brassard, C. Crépeau, R. Jozsa, A. Peres, and W. Wootters. Teleporting an unkown quantum state by dual classical and EPR  channels. Physical Review Letter  , 70:1895-1898, 1993. [ DVI / PS / GZIP/PS ] Tutoriel de Téléportation Quantique introduction à l'optique quantiquedocContentEnd
151docContentStartENGLISH Claude Crépeau Adresses Activités Scientifiques LaCIQ Mes publications Mes Cours et PrésentationsdocContentEnd
152docContentStartFORMATS: D = DVI, P = POSTSCRIPT, G = POSTSCRIPT+GZIP Introductory papers to Quantum Computing André Berthiaume. Quantum Computation. [ P / G ] Dorit Aharonov. Quantum Computation. [ P / G ] Eleanor Rieffel and Wolfgang Polak. An Introduction to Quantum Computing for Non-Physicists. [ P / G ] John Preskill. Reliable Quantum Computers. [ P / G ] Vlatko Vedral and Martin B. Plenio. Basics of Quantum Computation. [ P / G ]docContentEnd
153docContentStartFORMATS: D = DVI, P = POSTSCRIPT, G = POSTSCRIPT+GZIP C. Crpeau. Correct and Private Reductions among Oblivious Transfers. [ D / P / G ] PhD thesis, Department of Elec. Eng. and Computer Science, Massachusetts Institute of Technology, 1990. Supervised by Silvio Micali. C. Crpeau. Protocole cryptographique de poker à l'aveugle permettant la confidentialit de la stratgie. [ P / G ] Master's thesis, Dpartement d'Informatique et de R.O., Universit de Montral, 1986. Supervised by Gilles Brassard. G. Brassard, C. Crpeau and M. Sntha. Oblivious Transfers and Intersecting Codes. [ D / P / G ] to appear in IEEE Transaction on Information Theory  , 1996. C.H. Bennett, G. Brassard, C. Crpeau, and U. Maurer. Generalized Privacy Amplification. [ D / P / G ] IEEE Transaction on Information Theory  , 1995. Volume 41, Number 6, pp. 1915-1923, November 1995. C. Crpeau and L. Salvail. Oblivious Verification of Common String. [ D / P / G ] CWI Quarterly  , special issue for   Crypto Course 10th Anniversary  . Volume 8, Number 2, pp. 97-109, June 1995. C. Crpeau. Quantum Oblivious Transfer. [ D / P / G ] Journal of Modern Optics  , special issue on   Quantum Communication and Cryptography  . Volume 41, Number 12, pp. 2445-2454, December 1994. G. Brassard, C. Crpeau, and M. Yung. Constant-round perfect zero-knowledge computationally convincing protocols. [ D / P / G ] Theoretical Computer Science  , 84:23-52, 1991. G. Brassard, D. Chaum, and C. Crpeau. An introduction to minimum disclosure. [ P / G ] Quarterly  , 1:3-17, 1988. G. Brassard, D. Chaum, and C. Crpeau. Minimum disclosure proofs of knowledge. [ P / G ] JCSS  , 37:156-189, 1988. C. Crpeau. What is going on with Quantum Bit Commitment?. [ D / P / G ] invited paper in Proceedings of Pragocrypt '96  , Czech Technical University Publishing House, Prague, 1996. C. Crpeau. Efficient Cryptographic Protocols Based on Noisy Channels. [ D / P / G ] Manuscript, 1996. G. Brassard and C. Crpeau. Oblivious Transfers and Privacy Amplification. [ D / P / G ] Manuscript, 1996. C. Crpeau, J. van de Graaf, and A. Tapp. Committed Oblivious Transfer and Private Multi-Party Computations. [ D / P / G ] Advances in Cryptology: Proceedings of Crypto '95  , Springer-Verlag, pages 110-123, 1995. C. Crpeau, and L. Salvail. Quantum Oblivious Mutual Identification. [ D / P / G ] Advances in Cryptology: Proceedings of Eurocrypt '95  , Springer-Verlag, pages 133-147, 1995. C.H. Bennett, G. Brassard, C. Crpeau, and U. Maurer. Generalized Privacy Amplification (Abstract). [ D / P / G ] Proceedings of the   IEEE Symposium on Information Theory  , page 350. IEEE, 1994. G. Brassard, C. Crpeau, R. Jozsa, and D. Langlois. A quantum bit commitment scheme provably unbreakable by both parties. [ D / P / G ] In   34th Symp. on Found. of Computer Sci.  , pages 42-52. IEEE, 1993. C. Crpeau and J. Kilian. Discreet solitary games. [ D / P / G ] In   Advances in Cryptology: Proceedings of Crypto '93  , Lecture Notes in Computer Science. Springer-Verlag, pages 319-330,1993. C. Crpeau. Cryptographic primitives and quantum theory. [ D / P / G ] In   Proceedings of the second Physics of Computation Workshop, PhysComp '92  , pages 200-204, 1993. C.H. Bennett, G. Brassard, C. Crpeau, and M.-H. Skubiszewska. Practical quantum oblivious transfer protocols. [ D / P / G ] In   Advances in Cryptology: Proceedings of Crypto '91  , volume 576 of   Lecture Notes in Computer Science  , pages 351-366. Springer-Verlag, 1992. C. Crpeau and M. Sántha. Efficient reductions among oblivious transfer protocols based on new self-intersecting codes. [ D / P / G ] In   Sequences II, Methods in Communications, Security, and Computer Science  , pages 360-368. Springer-Verlag, 1991. G. Brassard and C. Crpeau. Quantum bit commitment and coin tossing protocols. [ D / P / G ] In   Advances in Cryptology: Proceedings of Crypto '90  , volume 537 of   Lecture Notes in Computer Science  , pages 49-61. Springer-Verlag, 1991. G. Brassard, C. Crpeau, S. Laplante, and C. Lger. Computationally convincing proofs of knowledge. [ D / P / G ] In   Proceedings of STACS '91  , volume 480 of   Lecture Notes in Computer Science  , pages 251-262. Springer-Verlag, 1991. C. Crpeau and M. Sántha. On the reversibility of oblivious transfer. [ D / P / G ] In   Advances in Cryptology: Proceedings of Eurocrypt '91  , volume 547 of   Lecture Notes in Computer Science  , pages 106-113. Springer-Verlag, 1991. G. Brassard and C. Crpeau. Sorting out zero-knowledge. [ D / P / G ] In   Advances in Cryptology: Proceedings of Eurocrypt '89  , volume 434 of   Lecture Notes in Computer Science  , pages 150-154. Springer-Verlag, 1990. C. Crpeau. Verifiable disclosure of secrets and applications. [ D / P / G ] In   Advances in Cryptology: Proceedings of Eurocrypt '89  , volume 434 of   Lecture Notes in Computer Science  , pages 181-191. Springer-Verlag, 1990. G. Brassard, C. Crpeau, and M. Yung. Everything in NP can be argued in perfect zero-knowledge in a constant number of rounds. [ P / G ] In   16th ICALP  , volume 372 of   Lecture Notes in Computer Science  , pages 123-136. Springer-Verlag, 1989. D. Chaum, C. Crpeau, and I. Damgaard. Multiparty unconditionally secure protocols. [ P / G ] In   19th Symp. on Theory of Computing  , pages 11-19. ACM, 1988. C. Crpeau and J. Kilian. Achieving oblivious transfer using weakened security assumptions. [ D / P / G ] In   29th Symp. on Found. of Computer Sci.  , pages 42-52. IEEE, 1988. C. Crpeau and J. Kilian. Weakening security assumptions and oblivious transfer. [ D / P / G ] In S. Goldwasser, editor,   Advances in Cryptology: Proceedings of Crypto '88  , volume 403 of   Lecture Notes in Computer Science  , pages 2-7. Springer-Verlag, 1990. C. Crpeau. Equivalence between two flavours of oblivious transfers (abstract). [ P / G ] In C. Pomerance, editor,   Advances in Cryptology: Proceedings of Crypto '87  , volume 293 of   Lecture Notes in Computer Science  , pages 350-354. Springer-Verlag, 1988. G. Brassard and C. Crpeau. Zero-knowledge simulation of boolean circuits (extended abstract). [ P / G ] In   Advances in Cryptology: Proceedings of Crypto '86  , volume 263 of   Lecture Notes in Computer Science  , pages 223-233. Springer-Verlag, 1987. G. Brassard, C. Crpeau, and J.-M. Robert. All-or-nothing disclosure of secrets (extended abstract). [ P / G ] In   Advances in Cryptology: Proceedings of Crypto '86  , volume 263 of   Lecture Notes in Computer Science  , pages 234-238. Springer-Verlag, 1987. C. Crpeau. A zero-knowledge poker protocol that achieves confidentiality of the players' strategy or how to achieve an electronic poker face. [ P / G ] In   Advances in Cryptology: Proceedings of Crypto '86  , volume 263 of   Lecture Notes in Computer Science  , pages 239-247. Springer, 1987. G. Brassard and C. Crpeau. Non-transitive transfer of confidence: A perfect zero-knowledge interactive protocol for SAT and beyond. [ P / G ] In   27th Symp. of Found. of Computer Sci.  , pages 188-195. IEEE, 1986. G. Brassard, C. Crpeau, and J.-M. Robert. Information theoretic reductions among disclosure problems. [ P / G ] In   27th Symp. of Found. of Computer Sci.  , pages 168-173. IEEE, 1986. C. Crpeau. A secure poker protocol that minimizes the effects of player coalitions. [ P / G ] In   Advances in Cryptology: Proceedings of Crypto '85  , vol 218 of   LNCS pages 73-86. Springer, 1986.docContentEnd
154docContentStartA Bibliography of Quantum Cryptography by Gilles Brassard Dpartement IRO, Universit de Montral. C.P. 6128, Succursale "Centre-Ville" Montral (Qubec) Canada H3C 3J7 The original PostScript file from Gilles Brassard - provided by Edith Stoeveken - was converted to ASCII and reformatted in HTML; Sept 2 1994, Stephan Kaufmann. HTTP pointers to DVI files added by Claude Crpeau, March 6 1995. Multiple file format added July 21st 1996 by Claude. FORMATS: D = DVI, P = POSTSCRIPT, G = POSTSCRIPT+GZIP Abstract This paper provides an extensive annotated bibliography of papers that have been written on quantum cryptography and related topics. 1. Introduction For ages, mathematicians have searched for a system that would allow two people to exchange messages in perfect privacy. Quantum Cryptography was born in the early seventies when Stephen Wiesner wrote "Conjugate Coding", which unfortunately took more than ten years to see the light of print [1]. In the mean time, Charles H. Bennett (who knew of Wiesner's idea) and Gilles Brassard picked up the subject and brought it to fruition in a series of papers that culminated with the demonstration of an experimental prototype that established the technological feasibility of the concept [2]. Quantum cryptographic systems take advantage of Heisenberg's uncertainty principle, according to which measuring a quantum system in general disturbs it and yields incomplete information about its state before the measurement. Eavesdropping on a quantum communication channel therefore causes an unavoidable disturbance, alerting the legitimate users. This yields a cryptographic system for the distribution of a secret random cryptographic key between two parties initially sharing no secret information that is secure against an eavesdropper having at her disposal unlimited computing power. Once this secret key is established, it can be used together with classical cryptographic techniques such as the one-time-pad to allow the parties to communicate meaningful information in absolute secrecy. In addition to key distribution, quantum techniques may also assist in the achievement of subtler cryptographic goals, important in the post-cold war world, such as protecting private information while it is being used to reach public decisions. Such techniques, pioneered by Claude Crpeau [3, 4], allow two people to compute an agreed-upon function f(x; y) on private inputs x and y when one person knows x, the other knows y, and neither is willing to disclose anything about their private input to the other, except for what follows logically from one's private input and the function's output. The classic example of such discreet decision making is the "dating problem", in which two people seek a way of making a date if and only if each likes the other, without disclosing any further information. For example, if Alice likes Bob but Bob doesn't like Alice, the date should be called off without Bob finding out that Alice likes him|on the other hand, it is logically unavoidable for Alice to learn that Bob doesn't like her, because if he did the date would be on. In the past few years, a remarkable surge of interest in the international scientific and industrial community has propelled quantum cryptography into mainstream computer science and physics. Furthermore, quantum cryptography is becoming increasingly practical at a fast pace. The first quantum key distribution prototype [2] worked over a distance of 32 centimetres in 1989. Two additional experimental demonstrations have been set up since, which work over significant lengths of optical fibre [13, 14]. The purpose of this work is to provide an extensive bibliography of most papers ever written on quantum cryptography, including some unpublished papers. In addition, a limited selection of key papers that describe techniques of crucial importance to quantum cryptography, such as privacy amplification [63, 73], is included. The papers are listed in chronological order within each section. 2. The various uses of quantum physics for cryptography Quantum cryptography is best known for key distribution. The most complete paper written on the subject, which also describes the original prototype, is [2]. However, two applications of quantum physics to cryptography were discovered well before quantum key distribution: quantum bank notes are impossible to counterfeit and quantum multiplexing allows one party to send two messages to another party in a way that the receiver can obtain either message at his choice, but reading one destroys the other irreversibly [1]. (The notion of multiplexing was reinvented ten years later in the context of classical cryptography under the name of oblivious transfer, which will be used henceforth in this paper.) A more elaborate quantum oblivious transfer protocol was designed subsequently [3]. Another quantum cryptographic task that has been studied extensively is bit commitment [4]. Applications of bit commitment and oblivious transfer are mentioned in Section 9. 1. Wiesner, S., "Conjugate coding", Sigact News, vol. 15, no. 1, 1983, pp. 78 - 88; original manuscript written circa 1970. 2. Bennett, C. H., Bessette, F., Brassard, G., Salvail, L. and Smolin, J., "Experimental quantum cryptography", [ D / P / G ] Journal of Cryptology, vol. 5, no. 1, 1992, pp. 3 - 28. Preliminary version in Advances in Cryptology - Eurocrypt '90 Proceedings, May 1990, Springer - Verlag, pp. 253 - 265. 3. Bennett, C. H., Brassard, G., Crpeau, C. and Skubiszewska, M.-H., "Practical quantum oblivious transfer", [ D / P / G ] Advances in Cryptology | Crypto '91 Proceedings, August 1991, Springer - Verlag, pp. 351 - 366. 4. Brassard, G., Crpeau, C., Jozsa, R. and Langlois, D., "A quantum bit commitment scheme provably unbreakable by both parties", [ D / P / G ] Proceedings of the 34th Annual IEEE Symposium on Foundations of Computer Science, November 1993, pp. 362 - 371. 3. Alternative quantum key distribution protocols The original quantum key distribution protocol uses four different polarization states of single photons as carrier of quantum information [2], but other approaches have been put forward. Early variations were to use Einstein-Podolsky-Rosen entangled pairs [5], to use only two nonorthogonal states rather than four [6], and to use phase modulation rather than polarization [6, 7]. A theoretical advantage of using entangled pairs is to allow the key to remain protected by the uncertainty principle even in storage, rather than merely in transit. More recent variations use rejected-data protocols [8, 9], photon pairs [10], and bright light [11]. 5. Ekert, A. K., "Quantum cryptography based on Bell's theorem", Physical Review Letters, vol. 67, no. 6, 5 August 1991, pp. 661 - 663. 6. Bennett, C. H., "Quantum cryptography using any two nonorthogonal states", Physical Review Letters, vol. 68, no. 21, 25 May 1992, pp. 3121 - 2124. 7. Ekert, A. K., Rarity, J. G., Tapster, P. R. and Palma, G. M., "Practical quantum cryptography based on two-photon interferometry", Physical Review Letters, vol. 69, no. 9, 31 August 1992, pp. 1293 - 1295. 8. Barnett, S. M. and Phoenix, S. J. D., "Information-theoretic limits to quantum cryptography", Physical Review A, vol. 48, no. 1, July 1993, pp. R5 - R8. 9. Barnett, S. M. and Phoenix, S. J. D., "Bell's inequality and rejected-data protocols for quantum cryptography", Journal of Modern Optics, vol. 40, no. 8, August 1993, pp. 1443 - 1448. 10. Huttner, B. and Peres, A., "Quantum cryptography with photon pairs", Journal of Modern Optics, to appear. 11. Wiesner, S., "Quantum cryptography with bright light", manuscript, 1993. 4. Implementation At least three experimental apparatuses have been built for implementing quantum key distribution, in addition to the original 32 centimetre implementation [2]. A prototype built in Geneva follows the original protocol of [2]: it uses four different polarization states to carry the quantum information over more than one kilometre of optical fibre [14]. Another prototype built independently by British Telecom in association with the Defence Research Agency works by phase modulation over a distance of 10 kilometres of fibre; it is described in a sequence of two papers [12, 13]. Yet another experimental demonstration is in the works, which uses Einstein-Podolsky-Rosen entangled pairs sent over kilometres of fibre [15]. 12. Townsend, P. D., Rarity, J. G. and Tapster, P. R., "Single photon interference in a 10 km long optical fibre interferometer", Electronics Letters, vol. 29, no. 7, April 1993, pp. 634 - 635. 13. Townsend, P. D., Rarity, J. G. and Tapster, P. R., "Enhanced single photon fringe visibility in a 10 km-long prototype quantum cryptography channel", Electronics Letters, vol. 29, no. 14, 8 July 1993, pp. 1291 - 1293. 14. Muller, A., Breguet, J. and Gisin, N., "Experimental demonstration of quantum cryptography using polarized photons in optical fibre over more than 1 km" Europhysics Letters, vol. 23, no. 6, 20 August 1993, pp. 383 - 388. 15. Rarity, J. G., Owens, P. C. M. and Tapster, P. R., "Quantum random number generation and key sharing", Journal of Modern Optics, vol. 41, no. 12, December 1994, pp. 2435 - 2444. 5. Eavesdropping The key distribution protocol described in [2] has been proven secure regardless of the eavesdropper's computing power, but assuming some restrictions on the type of attack, such as requiring eavesdropping to be independent from one light pulse to another. More sophisticated attacks have been analysed in the papers quoted below, but none of them has yet presented a direct threat to quantum key distribution. Note that, contrary to all known quantum key distribution schemes, the quantum bit commitment protocol of [4] has been formally proven invulnerable to all attacks consistent with the laws of quantum mechanics. 16. Werner, M. J. and Milburn, G. J., "Eavesdropping using quantum-nondemolition measurements", Physical Review A, vol. 47, no. 1, January 1993, pp. 639 - 641. 17. Barnett, S. M., Huttner, B. and Phoenix, S. J. D., "Eavesdropping strategies and rejected-data protocols in quantum cryptography", Journal of Modern Optics, vol. 40, no. 12, December 1993, pp. 2501 - 2513. 18. Huttner, B. and Ekert, A. K., "Tolerable noise in quantum cryptosystems", Journal of Modern Optics, to appear. 19. Ekert, A. K., Huttner, B., Palma, G. M. and Peres, A., "Eavesdropping on quantum cryptosystems", Physical Review A, submitted. 6. Popular accounts These papers appeared in popular science magazines. Many of them offer easy reading for the non specialist. The best introduction to quantum cryptography is perhaps [33]. 20. Gottlieb, A., "Conjugal secrets - The untappable quantum telephone", The Economist, vol. 311, 22 April 1989, page 81. 21. Wallich, P., "Quantum cryptography", Scientific American, May 1989, pp. 28 - 30. 22. Deutsch, D., "Quantum communication thwarts eavesdroppers", New Scientist, 9 December 1989, pp. 25 - 26. 23. Peterson, I., "Bits of uncertainty: Quantum security", Science News, vol. 137, 2 June 1990, pp. 342 - 343. 24. Ekert, A. K., "La mecanique quantique au secours des agents secrets", La Recherche, June 1991, pp. 790 - 791. 25. Ekert, A. K., "Przygoda w kwantowej krainie szyfrow", Wiedza i Zycie, July 1991, pp. 45 - 49. 26. Stewart, I., "Schrodinger's catflap", Nature, vol. 353, 3 October 1991, pp. 384 - 385. 27. Flam, F., "Quantum cryptography's only certainty: Secrecy", Science, vol. 253, 1991, page 858. 28. Ekert, A. K., "Adventures in quantum cryptoland" (in Japanese), Parity, vol. 7, February 1992, pp. 26 - 29. 29. Ekert, A. K., "Cryptography | Beating the code breakers", Nature, vol. 358, 2 July 1992, pp. 14 - 15. 30. Bennett, C. H., "Quantum cryptography: Uncertainty in the service of privacy", [ D / P / G ] Science, vol. 257, 7 August 1992, pp. 752 - 753. 31. Delahaye, J.-P., "Cryptographie quantique", Pour la Science, August 1992, pp. 101 - 106. 32. Zimmer, C., "Perfect Gibberish", Discover, September 1992, pp. 92 - 99. 33. Bennett, C. H., Brassard, G. and Ekert, A. K., "Quantum cryptography", Scientific American, October 1992, pp. 50 - 57. Appeared in December 1992 as translation into German ( Spektrum der Wissenschaft, pp. 96 - 104), Italian ( Le Scienze, pp. 84 - 93), Japanese ( Saiensu, pp. 50 - 60), and Polish (Swiat Nauki, pp. 28 - 37), among others. 34. Collins, G. P., "Quantum cryptography defies eavesdropping", Physics Today, November 1992, pp. 21 - 23. 35. Ekert, A. K., "Quantum keys for keeping secrets", New Scientist, 16 January 1993, pp. 24 - 28. 36. Townsend, P. D. and Phoenix, S. J. D., "Quantum mechanics will protect area networks", Opto and Laser Europe, July 1993, pp. 17 - 20. 7. Historical papers These papers are superseded by other papers listed above; nevertheless they are of historical interest. Of particular importance are the first paper ever published on quantum cryptography [37] (recall that [1] was written earlier) and the first paper that gives a complete description of the quantum key distribution protocol [42]. 37. Bennett, C. H., Brassard, G., Breidbart, S. and Wiesner, S., "Quantum cryptography, or unforgeable subway tokens", Advances in Cryptology: Proceedings of Crypto 82, August 1982, Plenum Press, pp. 267 - 275. 38. Bennett, C. H., Brassard, G. and Breidbart, S., "Quantum cryptography II: How to re- use a one-time pad safely even if P = N P ", unpublished manuscript, November 1982. 39. Bennett, C. H. and Brassard, G., "Quantum cryptography and its application to provably secure key expansion, public-key distribution, and coin-tossing", IEEE International Symposium on Information Theory, September 1983, page 91. 40. Bennett, C. H., Brassard, G., Breidbart, S. and Wiesner, S., "Eavesdrop-detecting quantum communications channel", IBM Technical Disclosure Bulletin, vol. 26, no. 8, January 1984, pp. 4363 - 4366. 41. Bennett, C. H. and Brassard, G., "An update on quantum cryptography", Advances in Cryptology: Proceedings of Crypto 84, August 1984, Springer - Verlag, pp. 475 - 480. 42. Bennett, C. H. and Brassard, G., "Quantum cryptography: Public-key distribution and coin tossing", Proceedings of IEEE International Conference on Computers, Systems and Signal Processing, Bangalore, India, December 1984, pp. 175 - 179. 43. Bennett, C. H. and Brassard, G., "Quantum public key distribution system", IBM Technical Disclosure Bulletin, vol. 28, no. 7, December 1985, pp. 3153 - 3163. 44. Crpeau, C. and Kilian, J., "Achieving oblivious transfer using weakened security assumptions", [ D / P / G ] Proceedings of the 29th Annual IEEE Symposium on Foundations of Computer Science, October 1988, pp. 42 - 52. 45. Bennett, C. H. and Brassard, G., "The dawn of a new era for quantum cryptography: The experimental prototype is working!", Sigact News, vol. 20, no. 4, 1989, pp. 78 - 82. 46. Brassard, G. and Crpeau, C., "Quantum bit commitment and coin tossing protocols", [ D / P / G ] Advances in Cryptology | Crypto '90 Proceedings, August 1990, Springer - Verlag, pp. 49 - 61. 8. Other papers Here are various other papers, theses and book chapters that have been written on quantum cryptography. 47. Wiedemann, D., "Quantum cryptography", Sigact News, vol. 18, no. 2, 1987, pp. 48 - 51; but please read also [48]. 48. Bennett, C. H. and Brassard, G., "Quantum public key distribution reinvented", Sigact News, vol. 18, no. 4, 1987, pp. 51 - 53. 49. Brassard, G., Modern Cryptology, Chapter 6, Springer - Verlag, Lecture Notes in Computer Science, vol. 325, 1988. 50. Crpeau, C., "Correct and Private Reductions among Oblivious Transfers", [ D / P / G ] PhD thesis, Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, February 1990. 51. Ekert, A. K., Correlations in Quantum Optics, Thesis submitted for the Degree of Doctor of Philosophy at the University of Oxford, Wolfson College, Oxford University, September 1991. 52. Bennett, C. H., Brassard, G. and Mermin, N. D., "Quantum cryptography with-out Bell's theorem", [ D / P / G ] Physical Review Letters, vol. 68, no. 5, 3 February 1992, pp. 557 - 559. 53. Brassard, G., Cryptologie contemporaine, Chapter 7, Masson, 1992. 54. Ekert, A. K., "Quantum cryptography and Bell's theorem", in Quantum Measurement in Optics (P. Tombesi and D. Walls, eds), Plenum Press, New York, 1992, pp. 413 - 418. 55. Ardehali, M., "Efficient quantum cryptography", manuscript, 1992. 56. Blow, K. J. and Phoenix, S. J. D., "On a fundamental theorem of quantum cryptography", Journal of Modern Optics, vol. 40, no. 1, January 1993, pp. 33 - 36. 57. Phoenix, S. J. D. and Townsend, P. D., "Quantum cryptography and secure optical communication", British Telecom Technology Journal, vol. 11, no. 2, April 1993, pp. 65 - 75. 58. Barnett, S. M., Ekert, A. K. and Phoenix, S. J. D., "Optical key to quantum cryptography", SERC Nonlinear Optics Update, United Kingdom Science and Engineering Research Council, vol. 5, Summer 1993, pp. 3 - 7. 59. Phoenix, S. J. D., "Quantum cryptography without conjugate coding", Physical Review A, vol. 48, no. 1, July 1993, pp. 96 - 102. 60. Crpeau, C., "Quantum oblivious transfer", [ D / P / G ] Journal of Modern Optics, Vol 41, No 12, December 1994, pp. 2445 - 2454. 9. Useful tools and related papers Raw quantum cryptography is useless in practice because limited eavesdropping may be undetectable, yet it may leak some information, and errors are to be expected even in the absence of eavesdropping. Also, we must protect against an eavesdropper who would impersonate Alice for Bob and Bob for Alice. For these reasons, quantum cryptography must be supplemented by classical tools such as privacy amplification [63, 73], error correction [71] and authentication [62]. Additional useful information-theoretic tools are provided in [70]. Quantum bit commitment [4] can be used to obtain zero-knowledge proofs [67] for arbitrary NP statements [68, 65]. Quantum oblivious transfer [3] can be used for discreet decision making [64, 66]. High-efficiency single- photon detectors [72] are crucial for photon-based quantum cryptography. Quantum teleportation [69] may be useful to increase the distance for quantum key distribution. The Einstein-Podolsky- Rosen effect is ubiquitous in quantum cryptography [61]. 61. Einstein, A., Podolsky, B. and Rosen, N., "Can quantum-mechanical description of physical reality be considered complete?", Physical Review, vol. 47, 1935, pp. 777 - 780. Reprinted in Quantum theory and measurement (J. A. Wheeler and W. Z. Zurek, eds), Princeton University Press, 1983. 62. Wegman, M. N. and Carter, J. L., "New hash functions and their use in authentication and set equality", Journal of Computer and System Sciences, vol. 22, 1981, pp. 265 - 279. 63. Bennett, C. H., Brassard, G. and Robert, J.-M., "Privacy amplification by public discussion", SIAM Journal on Computing, vol. 17, no. 2, April 1988, pp. 210 - 229. 64. Kilian, J., "Founding cryptography on oblivious transfer", Proceedings of the 20th Annual ACM Symposium on Theory of Computing, May 1988, pp. 20 - 31. 65. Brassard, G., Chaum, D. and Crpeau, C., "Minimum disclosure proofs of knowledge", [ P / G ] Journal of Computer and System Sciences, vol. 37, 1988, pp. 156 - 189. 66. Crpeau, C., "Verifiable disclosure of secrets and application", [ D / P / G ] Advances in Cryptology: Proceedings of Eurocrypt '89, April 1989, Springer - Verlag, pp. 181 - 191. 67. Goldwasser, S., Micali, S. and Rackoff, C., "The knowledge complexity of interactive proof-systems", SIAM Journal on Computing, vol. 18, 1989, pp. 186 - 208. 68. Goldreich, O., Micali, S. and Wigderson, A., "Proofs that yield nothing but their validity, or All languages in NP have zero-knowledge proof systems", Journal of the ACM, vol. 38, 1991, pp. 691 - 729. 69. Bennett, C. H., Brassard, G., Crpeau, C., Jozsa, R., Peres, A. and Wootters, W. K., "Teleporting an unknown quantum state via dual classical and Einstein-Podolsky-Rosen channels", [ D / P / G ] Physical Review Letters, vol. 70, 29 March 1993, pp. 1895 - 1899. 70. Maurer, U. M., "Secret key agreement by public discussion from common information", [ D / P / G ] IEEE Transactions on Information Theory, vol. 39, no. 3, May 1993, pp. 733 - 742. 71. Brassard, G. and Salvail, L., "Secret-key reconciliation by public discussion", [ D / P / G ] Advances in Cryptology | Eurocrypt '93 Proceedings, May 1993, to appear. 72. Kwiat, P. G., Steinberg, A. M., Chiao, R. Y., Eberhard, P. H. and Petroff, M. D., "High-efficiency single-photon detectors", Physical Review A, vol. 48, no. 2, August 1993, pp. R867 - R870. 73. Bennett, C. H., Brassard, G., Crpeau, C. and Maurer, U. M., "Generalized privacy amplification", [ D / P / G ] to appear in IEEE Transactions on Information Theory, 1995. 10. Bibliographies This bibliography of quantum cryptography [76] has evolved from an earlier version [75]. An earlier bibliography is available [74]. 74. Crpeau, C., "Cryptographic primitives and quantum theory", [ D / P / G ] Proceedings of Workshop on Physics and Computation, PhysComp 92, Dallas, October 1992, pp. 200 - 204. 75. Brassard, G., "Cryptology column | Quantum cryptography: A bibliography", Sigact News, vol. 24, no. 3, 1993, pp. 16 - 20. 76. Brassard, G., "A bibliography of quantum cryptography", [ D / P / G ] this manuscript. Acknowledgements I wish to thank Charles H. Bennett, Claude Crpeau, Artur K. Ekert, Neil Gershenfeld, Simon J. D. Phoenix and Paul D. Townsend, who helped me put this bibliography together by supplying corrections, updates and additions to previous versions. I am also grateful to Ron Rivest, whose request for a quantum cryptography bibliography set me in motion for this work. Finally I am most grateful to the Rank Foundation and Artur K. Ekert for making possible the first international workshop on quantum cryptography, which was held in Broadway, England, in March 1993. That was a historical event for the field. Latest update: 22 July 1998, Claude CRÉPEAU Recent papers on Quantum Cryptography JMO Special Issue: Quantum Communication Franson, J. D. and Ilves, H., "Quantum Cryptography using polarization feedback", Journal of Modern Optics, Vol 41, No 12, December 1994, pp. 2391 - 2396. Huttner, B. and Peres, A., "Quantum Cryptography with photon pairs", Journal of Modern Optics, Vol 41, No 12, December 1994, pp. 2397 - 2404. Breguet, J., Muller, A. and Gisin, N., "Quantum Cryptography with polarized photons in optical fibres. Experiment and practical limits.", Journal of Modern Optics, Vol 41, No 12, December 1994, pp. 2405 - 2412. Ekert, A.K. and Palma, G.M., "Quantum Cryptography with interferometric quantum entanglement.", Journal of Modern Optics, Vol 41, No 12, December 1994, pp. 2413 - 2424. Townsend, P.D. and Thompson, I., "A Quantum key distribution channel based on optical fibre.", Journal of Modern Optics, Vol 41, No 12, December 1994, pp. 2425 - 2434. Rarity, J. G., Owens, P. C. M. and Tapster, P. R., "Quantum random number generation and key sharing", Journal of Modern Optics, vol. 41, no. 12, December 1994, pp. 2435 - 2444. Crpeau, C., "Quantum oblivious transfer", [ D / P / G ] Journal of Modern Optics, Vol 41, No 12, December 1994, pp. 2445 - 2454. Huttner, B. and Ekert, A.K., "Information gain in quantum eavesdropping.", Journal of Modern Optics, Vol 41, No 12, December 1994, pp. 2455 - 2466. Various Sources Magniez, F., "Cryptographie Quantique", [ D / P / G ] mmoire de magistere, ENS-Cachan, mai 1993. Cachin, C. and Maurer, U., "Linking Information Reconciliation and Privacy Amplification", [ D / P / G ] Advances in Cryptology: Proceedings of Eurocrypt '94, May 1994, Springer - Verlag, pp. . Mayers, D. and Salvail, L., "Quantum Oblivious Transfer is Secure Against All Individual Measurements", [ D / P / G ] Proceedings of the workshop on Physics and Computation, PhysComp '94, Dallas, Nov 1994, pp. 69-77. Crpeau, C. and Salvail, L., "Quantum Oblivious Mutual Identification", [ D / P / G ] Advances in Cryptology: Proceedings of Eurocrypt '95, May 1995, Springer - Verlag, pp. 133- 147. Mayers, D., "On the security of the quantum oblivious transfer and key distribution protocols", [ D / P / G ] Advances in Cryptology: Proceedings of Crypto '95, Springer - Verlag, to appear. Yao, A., "Security of Quantum Protocols Against Coherent Measurements", [ D / P / G ] Proceedings of the 26th Symposium on the Theory of Computing, June 1995, pp. 67-75. Townsend, P. D., Phoenix, S. J. D., Blow, K. J. and Barnett, S. M., "Quantum cryptography for multi-user passive optical networks", [ P / G ] Electronics Letters, vol. 30, pp. 1875-1877 (1994). Mayers, D., "The trouble with Quantum Bit Commitment", [ P / G ] posted on quant-ph March 96. Lo, H.-K., and Chau, H.F., "Is Quantum Bit Commitment Really Possible?", [ P /docContentEnd
155docContentStartFRANÇAIS Claude Crépeau Addresses Scientific Activities CQIL My Publications My Courses and TalksdocContentEnd
156docContentStartFORMATS: D = DVI, P = POSTSCRIPT, G = POSTSCRIPT+GZIP Papers connecting Coding Theory and Cryptography G. Brassard, C. Crpeau and M. Sntha. Oblivious Transfers and Intersecting Codes. [ D / P / G ] to appear in IEEE Transaction on Information Theory  , 1996. C. Crpeau and L. Salvail. Oblivious Verification of Common String. [ D / P / G ] CWI Quarterly  , special issue for   Crypto Course 10th Anniversary  . Volume 8, Number 2, pp. 97-109, June 1995. C. Crpeau. Efficient Cryptographic Protocols Based on Noisy Channels. [ D / P / G ] Manuscript, 1996. G. Brassard and C. Crpeau. Oblivious Transfers and Privacy Amplification. [ D / P / G ] Manuscript, 1996. C. Crpeau, J. van de Graaf, and A. Tapp. Committed Oblivious Transfer and Private Multi-Party Computations. [ D / P / G ] Advances in Cryptology: Proceedings of Crypto '95  , Springer-Verlag, pages 110-123, 1995. C. Crpeau, and L. Salvail. Quantum Oblivious Mutual Identification. [ D / P / G ] Advances in Cryptology: Proceedings of Eurocrypt '95  , Springer-Verlag, pages 133-147, 1995. G. Brassard, C. Crpeau, R. Jozsa, and D. Langlois. A quantum bit commitment scheme provably unbreakable by both parties. [ D / P / G ] In   34th Symp. on Found. of Computer Sci.  , pages 42-52. IEEE, 1993. C.H. Bennett, G. Brassard, C. Crpeau, and M.-H. Skubiszewska. Practical quantum oblivious transfer protocols. [ D / P / G ] In   Advances in Cryptology: Proceedings of Crypto '91  , volume 576 of   Lecture Notes in Computer Science  , pages 351-366. Springer-Verlag, 1992. C. Crpeau and M. Sántha. Efficient reductions among oblivious transfer protocols based on new self-intersecting codes. [ D / P / G ] In   Sequences II, Methods in Communications, Security, and Computer Science  , pages 360-368. Springer-Verlag, 1991. D. Chaum, C. Crpeau, and I. Damgaard. Multiparty unconditionally secure protocols. [ P / G ] In   19th Symp. on Theory of Computing  , pages 11-19. ACM, 1988. G. Brassard, C. Crpeau, and J.-M. Robert. Information theoretic reductions among disclosure problems. [ P / G ] In   27th Symp. of Found. of Computer Sci.  , pages 168-173. IEEE, 1986. Some Coding Theory related papers I like Feng and Rao. Reflections on "Decoding Algebraic-Geometric Codes up to the Designed Minimum Distance". [ P / G ] Rob Calderbank and Peter Shor. Good Quantum Error-correcting Codes exist. [ P / G ] to appear. with figure. [ P / G ] N.J.A. Sloane. Covering Arrays and Intersecting Codes. [ P / G ] In Journal of Combinatorial Designs  1(1993), pp.51-63. M. Sipser and D. Spielman. Expander Codes. [ P / G ] In   36th Symp. of Found. of Computer Sci.  , pages . IEEE, 1995. D. Spielman. Linearly Encodable and Decodable Error-Correcting Codes. [ P / G ] as submitted. D. Spielman. Linearly Encodable and Decodable Error-Correcting Codes. [ P / G ] STOC '95. D. Spielman. MIT PhD Thesis. [ P / G ] N. Kahale. Eigenvalues and Expansion of Regular Graphs. [ P / G ] N. Kahale. Isoperimetric Inequalities and Eigenvalues. [ P / G ] N. Sendrier. On the structure of a randomly permuted concatenated code, [ P / G ]docContentEnd
